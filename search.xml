<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>java动态代理原理与实现</title>
      <link href="/2018/08/01/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/08/01/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="Java动态代理原理与实现"><a href="#Java动态代理原理与实现" class="headerlink" title="Java动态代理原理与实现"></a>Java动态代理原理与实现</h1><p>特征：代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。</p><p>代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。（有点像dubbo？） </p><p>简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>1、静态代理</p><p>由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。<br>在程序运行之前，代理类的.class文件就已经生成。</p><p>代理模式最主要的就是有一个公共接口（Person），一个具体的类（Student），一个代理类（StudentsProxy）,代理类持有具体类的实例，代为执行具体类实例方法。</p><p>假如一个班的同学要向老师交班费，但是都是通过班长把自己的钱转交给老师。这里，班长就是代理学生上交班费，</p><p>班长就是学生的代理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(name + <span class="string">"上交班费50元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理类(内置了被代理的对象）<br>StudentsProxy类，这个类也实现了Person接口，但是还另外<strong>持有一个学生类对象</strong>，由于实现了Peson接口，同时持有一个学生对象，那么他可以代理学生类对象执行上交班费（执行giveMoney()方法）行为。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentsProxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//被代理的学生</span></span><br><span class="line">    Student stu;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentsProxy</span><span class="params">(Person stu)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只代理学生对象</span></span><br><span class="line">        <span class="keyword">if</span>(stu.getClass() == Student.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.stu = (Student)stu;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代理上交班费，调用被代理学生的上交班费行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么，上交班费的时候，虽然操作的是代理类，而真正执行的是被代理的对象。<br>这里并没有直接通过张三（被代理对象）来执行上交班费的行为，而是通过班长（代理对象）来代理执行了。这就是代理模式。</p><p>上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指不直接调用实际对象的方法，那么我们在代理过程中就可以加上一些其他用途。就这个例子来说，加入班长在帮张三上交班费之前想要先反映一下张三最近学习有很大进步，直接在班长的递交中加上即可。</p><p>可以看到，只需要在代理类中帮张三上交班费之前，执行其他操作就可以了。这种操作，也是使用代理模式的一个很大的优点。最直白的就是在<strong>Spring中的面向切面编程（AOP），我们能在一个切点之前执行一些操作</strong>，在一个切点之后执行一些操作，这个切点就是一个个方法。这些方法所在类肯定就是被代理了，在代理过程中切入了一些其他操作。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="1-动态代理"><a href="#1-动态代理" class="headerlink" title="1.动态代理"></a>1.动态代理</h3><p><strong>定义：</strong>代理类在程序<strong>运行时创建的代理方式</strong>被成为动态代理。</p><p><strong>对比：</strong>静态代理的代理类(studentProxy)是自己定义好的，在程序运行之前就已经编译完成。<br>动态代理的代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的<strong>“指示”动态生成</strong>的。</p><p><strong>优势：</strong>可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 </p><p>比如说，想要在每个代理的方法前都加上一个处理方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用被代理方法前加入处理方法,</span></span><br><span class="line">        beforeMethod();</span><br><span class="line">        stu.giveMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里只有一个giveMoney方法，就写一次beforeMethod方法，但是如果除了giveMonney还有很多其他的方法，那就需要写很多次beforeMethod方法，麻烦。那看看下面动态代理如何实现。</p><h3 id="2、动态代理简单实现（Proxy类和InvocationHandler接口）"><a href="#2、动态代理简单实现（Proxy类和InvocationHandler接口）" class="headerlink" title="2、动态代理简单实现（Proxy类和InvocationHandler接口）"></a>2、动态代理简单实现（<code>Proxy类</code>和<code>InvocationHandler接口</code>）</h3><p>在java的<code>java.lang.reflect</code>包下提供了一个<code>Proxy类</code>和一个<code>InvocationHandler接口</code>，通过这个类和这个接口可以<strong>生成JDK动态代理类</strong>和<strong>动态代理对象。</strong></p><ul><li>创建一个<code>InvocationHandler对象(调用处理器）</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个与 代理对象 相关联的InvocationHandler</span></span><br><span class="line">InvocationHandler stuHandler = <span class="keyword">new</span> MyInvocationHandler&lt;Person&gt;(stu);</span><br></pre></td></tr></table></figure><ul><li>使用Proxy类的getProxyClass静态方法生成一个<code>动态代理类stuProxyClass类对象</code>（传入类加载器，类数组？）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123;Person.class&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>获得stuProxyClass 中一个带InvocationHandler参数的<code>构造器constructor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class);</span><br></pre></td></tr></table></figure></li><li><p>通过构造器constructor来创建一个<code>动态实例stuProxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person stuProxy = (Person) cons.newInstance(stuHandler);</span><br></pre></td></tr></table></figure></li></ul><h2 id="简化版本实现"><a href="#简化版本实现" class="headerlink" title="简化版本实现"></a>简化版本实现</h2><p>就此，一个动态代理对象就创建完毕，当然，上面四个步骤可以通过Proxy类的newProxyInstances方法来简化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//创建一个与 代理对象 相关联的InvocationHandler (调用处理器）</span></span><br><span class="line">InvocationHandler stuHandler = <span class="keyword">new</span> MyInvocationHandler&lt;Person&gt;(stu);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个 代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法</span></span><br><span class="line">  Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><blockquote><p>loader:一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载</p><p>interfaces:　一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口(多个接口）给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了</p><p>h:　　一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上</p></blockquote><h2 id="举例实现"><a href="#举例实现" class="headerlink" title="举例实现"></a>举例实现</h2><h3 id="1-被代理对象"><a href="#1-被代理对象" class="headerlink" title="1.被代理对象"></a>1.被代理对象</h3><p>相同的例子：班长需要帮学生代交班费。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被代理的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建需要被代理的实际类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//假设数钱花了一秒时间</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       System.out.println(name + <span class="string">"上交班费50元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再定义一个检测方法执行时间的工具类，在<strong>任何方法执行前</strong>先调用start方法，<strong>执行后</strong>调用finsh方法，就可以计算出该方法的运行时间，这也是一个最简单的方法执行时间检测工具。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonitorUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程本地变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tl.set(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//结束时打印耗时</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> finishTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(methodName + <span class="string">"方法耗时"</span> + (finishTime - tl.get()) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-被代理对象-的-调用处理器"><a href="#2-被代理对象-的-调用处理器" class="headerlink" title="2. 被代理对象 的 调用处理器"></a>2. 被代理对象 的 调用处理器</h3><p>创建<code>StuInvocationHandler类</code>，实现InvocationHandler接口，这个类中持有一个<strong>被代理对象的实例</strong> target。InvocationHandler中有一个invoke方法，所有执行代理对象的方法都会被<strong>替换成</strong>执行invoke方法。</p><p>也就是说。本来我们想调用代理对象的XX方法，进而调用被代理对象的XX方法，但是实际执行的，是调用处理器的invoke()方法。</p><p><strong>invoke v 调用<br>Invocation n 调用</strong></p><p>再在invoke方法中执行被代理对象target的相应方法。当然，在代理过程中，我们在真正执行被代理对象的方法前加入自己其他处理。这也是<strong>Spring中的AOP实现</strong>的主要原理，这里还涉及到一个很重要的关于java反射方面的基础知识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuInvocationHandler</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//invocationHandler持有的被代理对象</span></span><br><span class="line">    T target;</span><br><span class="line">    <span class="comment">//此调用处理器 根据 被代理对象实例 构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StuInvocationHandler</span><span class="params">(T target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * proxy:代表 动态代理对象 (班长大人）</span></span><br><span class="line"><span class="comment">     * method：代表 正在执行的方法 （缴费方法）</span></span><br><span class="line"><span class="comment">     * args：代表 调用目标方法时传入的实参  （这里缴费没用到参数）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"代理执行"</span> +method.getName() + <span class="string">"方法"</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//代理过程中插入监测方法,计算该方法耗时</span></span><br><span class="line">        MonitorUtil.start();</span><br><span class="line">        <span class="comment">//    当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 </span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        </span><br><span class="line">        MonitorUtil.finish(method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-创建动态代理对象"><a href="#3-创建动态代理对象" class="headerlink" title="3.创建动态代理对象"></a>3.创建动态代理对象</h3><p>做完上面的工作后，我们就可以具体来创建动态代理对象了，上面简单介绍了如何创建动态代理对象，我们使用简化的方式创建动态代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建 被代理对象 实例</span></span><br><span class="line">        Person zhangsan = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个与 代理对象相关联的InvocationHandler</span></span><br><span class="line">        InvocationHandler stuHandler = <span class="keyword">new</span> StuInvocationHandler&lt;Person&gt;(zhangsan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个 代理对象stuProxy来代理zhangsan，代理对象 的每个执行方法都会替换执行Invocation中的 invoke方法</span></span><br><span class="line">        <span class="comment">//使用方法 Proxy.newProxyInstance 创建 代理对象实例</span></span><br><span class="line">        <span class="comment">//参数：1.类加载器 2.没注明长度的类对象数组 3.调用 </span></span><br><span class="line">        Person stuProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler)；</span><br><span class="line"></span><br><span class="line">       <span class="comment">//代理执行上交班费的方法</span></span><br><span class="line">        stuProxy.giveMoney();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点：Proxy.newProxyInstance的第二个参数。是<br>一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口。<br>看到两种选择，一种是<code>Person.getClass().getInterfaces()</code><br>另一种是<code>new Class&lt;?&gt;[]{Person.class}</code></p><p>最后执行的是StuInvocationHandler中的invoke方法</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>很方便地对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。</p><p>例如，我想给被代理对象加上 一个临时的记时功能。我不用去修改接口加上方法。 而是只要去Handler的invoke中加上。因为我们调用代理类的giveMoney()，实际上是调用过了Handler的invoke方法。</p><p>动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行。带着这些问题，我们就需要对java动态代理的源码进行简要的分析，弄清楚其中缘由。</p><h1 id="动态代理原理分析"><a href="#动态代理原理分析" class="headerlink" title="动态代理原理分析"></a>动态代理原理分析</h1><h2 id="1、Java动态代理创建出来的动态代理类"><a href="#1、Java动态代理创建出来的动态代理类" class="headerlink" title="1、Java动态代理创建出来的动态代理类"></a>1、Java动态代理创建出来的动态代理类</h2><p>上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤(红色标准部分)：</p><p>查看newProxyInstance方法源码，可知</p><p>jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个<strong>类文件时放在内存中</strong>的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</p><p>我们可以对<strong>InvocationHandler看做一个中介类</strong>，中介类持有一个<strong>被代理对象</strong>，在invoke方法中<strong>调用了被代理对象的相应方法</strong>。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。</p><p>代理类调用自己方法时，通过<strong>自身持有的中介类对象</strong>来调用<strong>中介类对象的invoke方法</strong>，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。</p><p>通过 Proxy.newProxyInstance 创建的代理对象是在 jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。</p>]]></content>
      
      <categories>
          
          <category> 技术原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 动态代理 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>I/O模型与多路复用</title>
      <link href="/2018/07/24/I-O%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2018/07/24/I-O%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="I-O模型与多路复用"><a href="#I-O模型与多路复用" class="headerlink" title="I/O模型与多路复用"></a>I/O模型与多路复用</h1><p>本文转载自<a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html" target="_blank" rel="noopener">这里</a>，并加上了自身理解，感觉更透彻了</p><h1 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h1><h2 id="同步-amp-异步"><a href="#同步-amp-异步" class="headerlink" title="同步 &amp; 异步"></a>同步 &amp; 异步</h2><p>同步与异步是针对多个事件(线程/进程)来说的。</p><ul><li>如果事件A需要等待事件B的完成才能完成，这种串行执行机制可以说是同步的，这是一种可靠的任务序列，要么都成功，要么都失败。</li><li>如果事件B的执行不需要依赖事件A的完成结果，这种并行的执行机制可以说是异步的。事件B不确定事件A是否真正完成，所以是不可靠的任务序列。</li></ul><p>同步异步可以理解为多个事件的执行方式和执行时机如何，是串行等待还是并行执行。同步中依赖事件等待被依赖事件的完成，然后触发自身开始执行，异步<br>中依赖事件不需要等待被依赖事件，可以和被依赖事件并行执行，被依赖事件执行完成后，可以通过回调、通知等方式告知依赖事件。</p><h2 id="阻塞-amp-非阻塞"><a href="#阻塞-amp-非阻塞" class="headerlink" title="阻塞 &amp; 非阻塞"></a>阻塞 &amp; 非阻塞</h2><p>阻塞与非阻塞是针对单一事件(线程/进程)来说的。</p><ul><li>对于阻塞，如果一个事件在发起一个调用之后，在调用结果返回之前，该事件会被一直挂起，处于等待状态。</li><li>对于非阻塞，如果一个事件在发起调用以后，无论该调用当前是否得到结果，都会立刻返回，不会阻塞当前事件。</li></ul><p>阻塞与非阻塞可以理解为单个事件在发起其他调用以后，自身的状态如何，是苦苦等待还是继续干自己的事情。非阻塞虽然能提高CPU利用率，但是也带来了系统线程切换的成本，需要在CPU执行时间和系统切换成本之间好好估量一下。</p><h2 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h2><p>应用程序执行系统调用，应用程序会一直阻塞，直到系统调用完成。应用程序处于不再消费CPU而只是简单等待响应的状态。当响应返回时，数据被移动到用户空间的缓冲区，应用程序解除阻塞。</p><p><img src="http://static.zybuluo.com/rainybowe/brbkxdcpdl2dochf2ukt9ysz/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png" alt="此处输入图片的描述"></p><h2 id="同步非阻塞"><a href="#同步非阻塞" class="headerlink" title="同步非阻塞"></a>同步非阻塞</h2><p>设备以非阻塞形式打开，I/O操作不会立即完成，read操作可能会返回一个错误代码。应用程序可以执行其他操作，但需要请求多次I/O操作，直到数据可用。</p><p><img src="http://static.zybuluo.com/rainybowe/0agaz3rfsrlgxr5b5jtt4k1c/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%281%29.png" alt="此处输入图片的描述"></p><p>同步非阻塞形式实际上是效率低下的，因为：</p><ul><li>应用程序需要在不同的任务之间切换。异步非阻塞是你只需要执行当前任务，系统调用会主动通知你，不用频繁切换。</li><li>数据在内核中变为可用到调用read返回数据之间存在时间间隔，会造成整体数据吞吐量降低</li></ul><h2 id="异步非阻塞"><a href="#异步非阻塞" class="headerlink" title="异步非阻塞"></a>异步非阻塞</h2><p>应用程序的其他处理任务与I/O任务重叠进行。读请求会立即返回，说明<strong>请求已经成功发起(成不成功另说）</strong>，应用程序不被阻塞，继续执行其它处理操作。当read响应到达，将数据拷贝到用户空间，产生信号或者执行一个基于线程回调函数完成I/O处理。应用程序不用在多个任务之间切换。</p><p><img src="http://static.zybuluo.com/rainybowe/rhcelws3p3yjggxisd5xebz0/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%282%29.png" alt="此处输入图片的描述"></p><p>非阻塞I/O和异步I/O区别在于，在非阻塞I/O中，虽然进程大部分时间不会被block，但是需要<strong>不停的去主动check</strong>，并且当数据准备完成以后，也需要应用程序主动调用recvfrom将数据拷贝到用户空间；异步I/O则不同，就像是应用程序将整个<strong>I/O操作交给了内核完成，然后由内核发信号通知</strong>。期间<strong>应用程序不需要主动去检查I/O操作状态，也不需要主动从内核空间拷贝数据到用户空间。</strong><br>相当于应用程序将IO完全托管给了内核，自己则去做其他的事了。</p><p>非阻塞I/O看起来是non-blocking的，但是只是在内核数据没准备好时，当数据准备完成，recvfrom需要从内核空间拷贝到用户空间，这个时候其实是被block住的。<br>而异步I/O是当进程发起I/O操作后，再不用主动去请求，直到内核数据准备好并发出信号通知，整个过程完全没有block。</p><h2 id="没有异步阻塞，都异步了都不管了，还阻塞个P啊"><a href="#没有异步阻塞，都异步了都不管了，还阻塞个P啊" class="headerlink" title="没有异步阻塞，都异步了都不管了，还阻塞个P啊"></a>没有异步阻塞，都异步了都不管了，还阻塞个P啊</h2><h1 id="几种常用I-O模型"><a href="#几种常用I-O模型" class="headerlink" title="几种常用I/O模型"></a>几种常用I/O模型</h1><h2 id="BIO（同步阻塞）"><a href="#BIO（同步阻塞）" class="headerlink" title="BIO（同步阻塞）"></a>BIO（同步阻塞）</h2><p><strong>总结：</strong>一个连接一个线程<br>同步并阻塞，服务器实现模式为 一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 </p><p>服务器需要监听端口号，客户端通过IP和端口与服务器简历TCP连接，以同步阻塞的方式传输数据。服务端设计一般都是 客户端-线程模型，新来一个客户端连接请求，就新建一个线程处理连接和数据传输</p><p>当客户端连接较多时就会大大消耗服务器的资源，线程数量可能超过最大承受量</p><h2 id="伪异步I-O-（带线程池的同步阻塞）"><a href="#伪异步I-O-（带线程池的同步阻塞）" class="headerlink" title="伪异步I/O （带线程池的同步阻塞）"></a>伪异步I/O （带线程池的同步阻塞）</h2><p>与BIO类似，只是将客户端-线程的模式换成了<strong>线程池</strong>，可以灵活设置线程池的大小。但这只是对BIO的一种优化手段，并没有解决线程连接的阻塞问题。</p><h2 id="NIO-（异步非阻塞）"><a href="#NIO-（异步非阻塞）" class="headerlink" title="NIO （异步非阻塞）"></a>NIO （异步非阻塞）</h2><p>总结：一个请求一个线程，连接<strong>注册在多路复用器</strong>上，再启动线程，不停询问IO操作</p><p>同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。 </p><p>利用selector多路复用器轮询为每一个用户创建连接，这样就不用阻塞用户线程，也不用每个线程忙等待。只<strong>使用一个线程轮询I/O事件</strong>，比较适合高并发，高负载的网络应用，充分利用系统资源快速处理请求返回响应消息，</p><p><strong>适合：</strong>连接又多 IO时间又短</p><h2 id="AIO-（异步非阻塞，NIO升级版）"><a href="#AIO-（异步非阻塞，NIO升级版）" class="headerlink" title="AIO （异步非阻塞，NIO升级版）"></a>AIO （异步非阻塞，NIO升级版）</h2><p>总结：一个有效请求一个线程。</p><p>异步非阻塞，需要操作系统内核线程支持，一个用户线程发起一个请求后就可以<strong>继续执行</strong>，内核线程执行完系统调用后会根据回调函数完成处理工作。</p><p><strong>适合：</strong> I/O任务较长（不想等待浪费时间）</p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p><strong>速记：</strong>挨个访问，准备好了的再建立连接。</p><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。</p><p><img src="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/files/06fig03.gif" alt="此处输入图片的描述"><br>这样在处理1000个连接时，只需要<strong>1个线程监控</strong>就绪状态，对<strong>就绪的每个连接开一个线程处理</strong>就可以了，这样需要的线程数大大减少，减少了内存开销和上下文切换的CPU开销。</p><p><strong>本质：</strong>（NIO)同步非阻塞I/O</p><p><strong>优势：</strong>能处理<strong>更多</strong>的连接。系统开销小，不需要创建和维护额外线程或进程。</p><p><strong>适合：</strong>处理多个客户端接入请求时</p><p><strong>过程：</strong><br>通过把多个I/O的阻塞复用到同一个select阻塞上，一个进程监视多个描述符（Socket），一旦某个描述符就位， 能够通知程序进行读写操作。因为多路复用本质上是同步I/O，都需要应用程序在读写事件就绪后自己负责读写。</p><p><strong>应用场景</strong><br>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字<br>需要同时处理多种网络协议的套接字<br>一个服务器处理多个服务或协议<br>目前支持多路复用的<strong>系统调用有select, poll, epoll。</strong></p><p>未完持续</p>]]></content>
      
      <categories>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秒杀项目学习笔记 第一、二章——项目框架搭建 实现登陆功能</title>
      <link href="/2018/07/19/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E7%AB%A0%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%20%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD/"/>
      <url>/2018/07/19/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%80%E3%80%81%E4%BA%8C%E7%AB%A0%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%20%E5%AE%9E%E7%8E%B0%E7%99%BB%E9%99%86%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h1 id="秒杀项目学习笔记-第一、二章——项目框架搭建-实现登陆功能"><a href="#秒杀项目学习笔记-第一、二章——项目框架搭建-实现登陆功能" class="headerlink" title="秒杀项目学习笔记 第一、二章——项目框架搭建 实现登陆功能"></a>秒杀项目学习笔记 第一、二章——项目框架搭建 实现登陆功能</h1><p>redis有多个库，最多16个，默认为0库</p><h1 id="第一章："><a href="#第一章：" class="headerlink" title="第一章："></a>第一章：</h1><p>集成Redis：<br>1.添加Jedis依赖：<br>2.添加Fastjson：为了序列化，对象与字符串（json格式）的转化</p><h1 id="第二章-实现登陆功能）："><a href="#第二章-实现登陆功能）：" class="headerlink" title="第二章(实现登陆功能）："></a>第二章(实现登陆功能）：</h1><p>1.数据库设计<br>2.明文密码两次MD5处理<br>3.JSR303参数检验+全局异常处理器<br>4.分布式session(重要）</p><h2 id="两次MD5（安全）"><a href="#两次MD5（安全）" class="headerlink" title="两次MD5（安全）"></a>两次MD5（安全）</h2><p>http是明文传输，用户密码会在网络上传输<br>1.用户端： PASS = MD5 (明文+固定Salt）<br>    用户端先MD5后再传输给服务端，防止传输窃取<br>2.服务端:  PASS = MD5 (用户输入+ 随机Salt）<br>    接收后，会随机生成salt，与用户md5生成拼装，再做MD5, 结果再写入数据库，放置数据库被盗。防止彩虹表，由一次的MD5反查出密码，所以要再进行一次MD5。</p><h2 id="2-2-实现登陆功能"><a href="#2-2-实现登陆功能" class="headerlink" title="2-2 实现登陆功能"></a>2-2 实现登陆功能</h2><p>新建了一个LoginVo类<br>作用：用于在console中输入后台所接收到的mobile和password。<br>实现：在loginController中引入变量log，使用<code>log.info(loginVo.toString())</code>输出，loginVo就是前端传来的参数<br>前端:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function login()&#123;</span><br><span class="line">$(&quot;#loginForm&quot;).validate(&#123;</span><br><span class="line">        submitHandler:function(form)&#123;</span><br><span class="line">             doLogin();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doLogin()&#123;</span><br><span class="line">g_showLoading();//展示loading框</span><br><span class="line"></span><br><span class="line">var inputPass = $(&quot;#password&quot;).val();</span><br><span class="line">var salt = g_passsword_salt; //在common.js中提供</span><br><span class="line">var str = &quot;&quot;+salt.charAt(0)+salt.charAt(2) + inputPass +salt.charAt(5) + salt.charAt(4);</span><br><span class="line">var password = md5(str);  //md5.js提供</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url: &quot;/login/do_login&quot;,</span><br><span class="line">    type: &quot;POST&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">    mobile:$(&quot;#mobile&quot;).val(),</span><br><span class="line">    password: password</span><br><span class="line">    &#125;,</span><br><span class="line">    success:function(data)&#123;</span><br><span class="line">    layer.closeAll();   //不管成功失败，先关框</span><br><span class="line">            console.log(data);</span><br><span class="line">    if(data.code == 0)&#123;</span><br><span class="line">    layer.msg(&quot;成功&quot;);</span><br><span class="line">    window.location.href=&quot;/goods/to_list&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">    layer.msg(data.msg);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    error:function()&#123;</span><br><span class="line">    layer.closeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(LoginController.class);<span class="comment">//导入slf4j的Logger</span></span><br></pre></td></tr></table></figure><h2 id="2-3-JSR303参数校验-全局异常处理器"><a href="#2-3-JSR303参数校验-全局异常处理器" class="headerlink" title="2-3 JSR303参数校验 + 全局异常处理器"></a>2-3 JSR303参数校验 + 全局异常处理器</h2><p>在登陆的时候，传参的时候需要检验。<br>若每个页面服务都写loginController里的话，很麻烦</p><p>参数校验<br>1.引入spring-boot-starter-validation依赖<br>2.给前端传来的参数LoginVo加上@Valid注解<br>3.给参数LoginVo对象类，所需要验证的属性（如电话，密码）加上校验注解，比如NOTNULL，也可以自己创建符合的注解，比如手机号是1开头，共11位。<br>4.若要新建注解，应在validator文件夹中新建@注解，并传入所对应的验证类。如IsMobileValidator，<code>IsMobileValidator implements ConstraintValidator</code>，重写初始化和验证方法。<br>5.</p><p>异常拦截处理：<br>问题：当加上参数校验时，若未通过校验，会返回给浏览器400异常，但是并不会显示，添加异常处理显示，这样对用户更加友好<br>目的：拦截绑定异常，输出错误信息</p><p><strong>结构：</strong></p><p><strong>Controller类</strong>：负责业务的转发，接收传来的@Valid LoginVo(mobile password已装载)</p><p><strong>Service类</strong>：负责业务逻辑，包含业务上的校验（手机是否存在，密码是否正确）。校验成功返回true，失败则new GlobalException（CodeMsg）对应异常并抛出</p><p><strong>GlobalException类</strong>：根据CodeMsg构造，具有CodeMsg属性</p><p><strong>GlobalExceptionHandler类</strong>： 类名前添加注解@ControllerAdvice，类似切面功能，有exceptionHandler方法，能够捕获异常，根据异常类别，返回不同的Result.error(ex.getCodeMsg())</p><p><strong>@Valid</strong>：负责入参的格式校验，表明LoginVo(mobile password)受校验，可自定义添加注解校验<br>IsMobileValidator类：用于实现注解@IsMobile（用于验证手机号）的验证，里面可能会使用到工具类ValidatorUtil来校验。</p><p><strong>ValidatorUti类</strong>：提供了多种验证方法</p><h2 id="2-6-分布式Session"><a href="#2-6-分布式Session" class="headerlink" title="2-6 分布式Session"></a>2-6 分布式Session</h2><p>分布式多台服务器，处理用户的Session，</p><p>可选方法：1.Session同步（应用很少，因为多服务器同步实现复杂）</p><p><strong>所用方法：</strong><br>1.使用工具类UUID，修改并生成不带“-”的cookie字符串<code>String token = UUIDUtil.uuid();</code></p><p>2.将token保存在redis缓存中，以便于下次验证<br><code>redisService.set(MiaoshaUserKey.token, token, user);</code> 前缀，key，value</p><p>3.将cookie对象加入response，发送回给用户，以便用户下次发送给客户端<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(COOKI_NAME_TOKEN, token); <span class="comment">//作为name和value</span></span><br><span class="line">cookie.setMaxAge(MiaoshaUserKey.token.expireSeconds());</span><br><span class="line">cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">response.addCookie(cookie);<span class="comment">//加入response,</span></span><br></pre></td></tr></table></figure></p><p>4.验证Session如何实现？？<br>登陆成功后，在login.html中会有ajax异步<code>window.location.href=&quot;/goods/to_list&quot;;</code>跳转到商品列表,访问/goods/to_list，客户端会将session放在request中发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cookieToken COOKI_NAME_TOKEN是从request中所取的参数名字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramToken 有时候手机客户端会将token放在参数中传递，而不是cookie中发给客户端，为了兼容加上这个注解,并且优先取paramToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/to_list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLogin</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                          @CookieValue(value = MiaoshaUserService.COOKI_NAME_TOKEN,required = <span class="keyword">false</span>)</span> String cookieToken,</span></span><br><span class="line"><span class="function">                          @<span class="title">RequestParam</span><span class="params">(value = MiaoshaUserService.COOKI_NAME_TOKEN,required = <span class="keyword">false</span>)</span> String paramToken</span></span><br><span class="line"><span class="function">                          )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;<span class="comment">//优先取paramToken，为空才取cookieToken</span></span><br><span class="line">        <span class="comment">//根据token从redis中获取用户信息</span></span><br><span class="line">        MiaoshaUser user = userService.getByToken(token);</span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>最后goods.html通过thymeleaf:<code>&lt;p th:text=&quot;&#39;hello:&#39;+${user.nickname}&quot; &gt;&lt;/p&gt;</code></p></li><li><p>实现<strong>Session的更新功能</strong>，根据用户最后一次点击时间为起点，在to_list中调用getByToken获取user对象时，若取到了用户，就会重新<code>addCookie(response, token, user)</code></p></li></ol><h2 id="分布式Session的优化"><a href="#分布式Session的优化" class="headerlink" title="分布式Session的优化"></a>分布式Session的优化</h2><p>在很多的界面跳转时都要验证Session，若在每个方法内都加注解判断token，每个方法都增加根据token获取user的话很冗杂。想到可以将方法抽离出来也需要有没有实现Session更优雅的方式？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/to_list"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(HttpServletResponse response, Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">                      @CookieValue(value = MiaoshaUserService.COOKI_NAME_TOKEN,required = <span class="keyword">false</span>)</span> String cookieToken,</span></span><br><span class="line"><span class="function">                      @<span class="title">RequestParam</span><span class="params">(value = MiaoshaUserService.COOKI_NAME_TOKEN,required = <span class="keyword">false</span>)</span> String paramToken</span></span><br><span class="line"><span class="function">                      )</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;<span class="comment">//优先取paramToken，为空才取cookieToken</span></span><br><span class="line">    <span class="comment">//根据token从redis中获取用户信息</span></span><br><span class="line">    MiaoshaUser user = userService.getByToken(response,token);</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>能不能变成如下方式？直接就获取到了user，不用根据Token来判断了，需要实现argument resolvor参数处理，mvc框架提供了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/to_list"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model,  MiaoshaUser user)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们联想到了添加参数model，request，response实现的原理————argumentResolver，  通过WebMvcConfigurerAdapter（WebMVC配置适配器）<br>实现：<br>1.新建WebConfig继承WebMvcConfigurerAdapter，加上@Configuration<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserArgumentResolver userArgumentResolver;<span class="comment">//这是为了添加user实现的resolver</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;</span><br><span class="line">        argumentResolvers.add(userArgumentResolver);<span class="comment">//将其加入argumentResolver列表</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.新建UserArgumentResolver 实现 HandlerMethodArgumentResolver<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MiaoshaUserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是要引入的对应类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = methodParameter.getParameterType();</span><br><span class="line">        <span class="keyword">return</span> clazz == MiaoshaUser.class;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于根据各种参数，返回所引入得对象。（就跟引入model一样啦）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">        HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">        HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse.class);</span><br><span class="line"></span><br><span class="line">        String paramToken = request.getParameter(MiaoshaUserService.COOKI_NAME_TOKEN);<span class="comment">//参数中的根据名字就有</span></span><br><span class="line">        String cookieToken = getCookieValue(request, MiaoshaUserService.COOKI_NAME_TOKEN);<span class="comment">//取放在cookies中的cookie，只取cookie名字对上的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(cookieToken) &amp;&amp; StringUtils.isEmpty(paramToken)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String token = StringUtils.isEmpty(paramToken) ? cookieToken : paramToken;</span><br><span class="line">        <span class="comment">//根据token从redis中获取用户信息</span></span><br><span class="line">        <span class="keyword">return</span> userService.getByToken(response,token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCookieValue</span><span class="params">(HttpServletRequest request, String cookiNameToken)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//疑问：request.getCookies()会有很多个cookies吗？只取名为MiaoshaUserService.COOKI_NAME_TOKEN的</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cookie.getName().equals(cookiNameToken)) &#123;</span><br><span class="line">                <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>![此处输入图片的描述][1]<br>  [1]: <a href="http://pbw0qqogs.bkt.clouddn.com/cookie_token.png" target="_blank" rel="noopener">http://pbw0qqogs.bkt.clouddn.com/cookie_token.png</a></p><p>  这样，我们的GoodsController就变得异常简洁了。能够直接自动的取user，取不到会直接返回个null的user。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/to_list"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model,  MiaoshaUser user)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"goods_list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 秒杀项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 秒杀项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秒杀项目学习笔记 第七章————安全优化</title>
      <link href="/2018/07/19/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/19/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%83%E7%AB%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%AE%89%E5%85%A8%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><img src="http://pbw0qqogs.bkt.clouddn.com/%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97%E6%B5%81%E7%A8%8B.jpg" alt="此处输入图片的描述"></p><h1 id="秒杀项目学习笔记-第七章————安全优化"><a href="#秒杀项目学习笔记-第七章————安全优化" class="headerlink" title="秒杀项目学习笔记 第七章————安全优化"></a>秒杀项目学习笔记 第七章————安全优化</h1><p>1.秒杀接口地址隐藏<br>2.数学公式验证码（防止机器人，延迟请求分散并发量）<br>3.接口限流防刷（限制访问次数）</p><h1 id="7-1-秒杀接口地址隐藏"><a href="#7-1-秒杀接口地址隐藏" class="headerlink" title="7-1 秒杀接口地址隐藏"></a>7-1 秒杀接口地址隐藏</h1><p>思路：秒杀开始之间，先去请求接口  获取秒杀地址</p><p>1.接口改造，带上PathVariable参数<br>秒杀按钮不是秒杀，而是先异步请求<code>&quot;/miaosha/path&quot;</code>，生成path写入缓存，并且返回path</p><p>2.拿到path之后返回，异步请求miaosha，传入path，验证是否合法</p><p>3.秒杀收到请求，先验证PathVariable</p><h1 id="7-2-数学公式验证码"><a href="#7-2-数学公式验证码" class="headerlink" title="7-2 数学公式验证码"></a>7-2 数学公式验证码</h1><p>思路：防止机器人，分散用户的请求</p><p>1.添加生成验证码的接口<br>前端：添加 验证码图片展示模块，结果输入模块。设置好显示与隐藏逻辑。<br>在进入goods_ detail时候会异步访问，请求验证，得到返回的验证码渲染展示出来。</p><p>后端:</p><p>2.在获取秒杀路径的时候，验证验证码<br>3.SriptEngine使用（JDK1.6 添加）</p><h1 id="7-4-接口限流防刷"><a href="#7-4-接口限流防刷" class="headerlink" title="7-4 接口限流防刷"></a>7-4 接口限流防刷</h1><p>一般解决方法，加入一个访问次数缓存。每次访问一次+1，超过5次返回错误。</p><h1 id="7-5-通用化的-接口限流防刷"><a href="#7-5-通用化的-接口限流防刷" class="headerlink" title="7-5 通用化的 接口限流防刷"></a>7-5 通用化的 接口限流防刷</h1><p>通过 自定义拦截器 来限制流量。<br>这样在所需限制的方法上添加。<code>@AccessLimit(seconds=5, maxCount=5, needLogin=true)</code></p><p>1.创建注解@AccessLimit，内部添加 所需的限制对象。<br>2.<code>AccessInterceptor  extends HandlerInterceptorAdapter</code>。自定义拦截器类，继承适配器类，重写<code>preHandle</code>方法。在其中<br>通过HandlerMethod拿到注解，获得对外接口的限制属性。对这些属性，来做一些redis缓存。<br>没每访问一次就给缓存加一次</p>]]></content>
      
      <categories>
          
          <category> 秒杀项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 秒杀项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秒杀项目学习笔记 第六章————接口优化</title>
      <link href="/2018/07/19/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%85%AD%E7%AB%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/19/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%85%AD%E7%AB%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="秒杀项目学习笔记-第六章————接口优化"><a href="#秒杀项目学习笔记-第六章————接口优化" class="headerlink" title="秒杀项目学习笔记 第六章————接口优化"></a>秒杀项目学习笔记 第六章————接口优化</h1><p>1.redis预减库存 减少数据库访问<br>2.内存标记减少redius访问<br>3.请求先入队缓冲，异步下单，增强用户体验    MQ<br>4.RabbitMQ安装与springBoot集成<br>5.Nginx水平扩展<br>5.压测</p><p>分库分表中间件 ： mycat</p><h1 id="秒杀接口优化"><a href="#秒杀接口优化" class="headerlink" title="秒杀接口优化"></a>秒杀接口优化</h1><p>思路：减少数据库访问<br>1.系统初始化，把商品库存数量加载到Redis<br>2.收到请求，Redis预减库存，库存不足，直接返回，否则继续<br>3.请求入队，立即返回排队中响应。异步操作，（成功失败不明，只是在排队）</p><p>以下两部并发进行<br>4.服务端：请求出队，生成订单，减少库存<br>5.客户端：收到排队中消息之后，会轮询，是否秒杀成功</p><h1 id="6-2-RabbitMq安装"><a href="#6-2-RabbitMq安装" class="headerlink" title="6-2 RabbitMq安装"></a>6-2 RabbitMq安装</h1><p>安装erlang依赖<br>安装RabbitMq</p><p><a href="https://blog.csdn.net/zxl646801924/article/details/80435231" target="_blank" rel="noopener">https://blog.csdn.net/zxl646801924/article/details/80435231</a><br><a href="https://blog.csdn.net/weixin_39735923/article/details/79288578" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39735923/article/details/79288578</a></p><h1 id="6-2-RabbitMq集成"><a href="#6-2-RabbitMq集成" class="headerlink" title="6-2 RabbitMq集成"></a>6-2 RabbitMq集成</h1><p>若要远程访问，需要配置一个rabbitMq配置</p><p>1.添加spring-boot-stater-amqp依赖<br>在pom和application.property中加入依赖和设置参数</p><p>MQConfig中配置队列</p><p>2.创建消息接受者<br>新建rabbitmq包，创建MQsender类，属于服务类。<br>3.创建消息发送者<br>创建MQReceiver类</p><p><strong>一个空格引发的惨案：在application.property中的路径上多加了个空格，导致浪费两小时找BUG，所以路径一定要注意了</strong></p><p>注入MQSender实例（作为service），<code>sender.send(&quot;hello,imooc&quot;);</code><br><strong>重点！！：</strong> MQSender会引入amqpTemplate</p><p><code>amqpTemplate.convertAndSend(MQConfig.QUEUE, msg);</code><strong>参数：</strong>队列名，所传数据<br>这里不直接写“queue”，而是选用MQConfig中的常量来设置名字</p><h1 id="6-4-RabbitMQ四种交换方式"><a href="#6-4-RabbitMQ四种交换方式" class="headerlink" title="6-4 RabbitMQ四种交换方式"></a>6-4 RabbitMQ四种交换方式</h1><ol><li>DIRECT模式（直连交换机）：消息被发送的时候，需要指定一个binding_key，被这个交换机送到指定的队列里面去。</li><li>Topic模式：因为直连交换机，多队列情况需要绑定很多，不方便管理。发送到<strong>主题交换机</strong>上的消息需要携带指定规则的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 3. Fanout模式 广播模式 发送给**所有绑定在自己身上**的队列。（不需要思考，最快）</span><br><span class="line"> 4. Headers 模式路由器和交换机路由的规则是通过Headers信息来交换的，这个有点像HTTP的Headers，将一个交换机声明成首部交换机，绑定一个队列的时候，定义一个Hash的数据结构，消息发送的时候，会携带一组hash数据结构的信息，当Hash的内容匹配上的时候，消息就会被写入队列。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## **DIRECT模式：** 没有交换机Exchange  </span><br><span class="line">```amqpTemplate.convertAndSend(MQConfig.QUEUE, msg);</span><br></pre></td></tr></table></figure></li></ol><h2 id="Topic模式：-交换机Exchange"><a href="#Topic模式：-交换机Exchange" class="headerlink" title="Topic模式： 交换机Exchange"></a><strong>Topic模式：</strong> 交换机Exchange</h2><p>先将消息发送到交换机上，在由其发送到队列上，相当于做了个路由。</p><p><strong>实现：</strong></p><p>MQSender的sendTopic方法中，convertAndSend此时参数不同，多了个”topic.key1”，这是路由匹配的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE, <span class="string">"topic.key1"</span>, msg+<span class="string">"1"</span>);</span><br><span class="line">amqpTemplate.convertAndSend(MQConfig.TOPIC_EXCHANGE, <span class="string">"topic.key2"</span>, msg+<span class="string">"2"</span>);</span><br></pre></td></tr></table></figure><p><strong>这样匹配到的队列就不同了！！</strong></p><p>有两个队列，topicQ1  topicQ2。传入字符串name构造。<br>有两个topicExchange1 ， topicExchange2 。传入字符串name构造。<br>有两个绑定Binding。将topicQ和topicExchange绑定</p><p>topicExchange和是org.springframework.amqp.core中提供的类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">MQConfig的实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(topicQueue1()).to(topicExchage()).with(<span class="string">"topic.key1"</span>);</span><br><span class="line"><span class="comment">//bind(队列实例.to(topicExchange实例）.with(routingKey)</span></span><br><span class="line"><span class="comment">//routingKey是路由匹配的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">topicBinding2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(topicQueue2()).to(topicExchage()).with(<span class="string">"topic.#"</span>);</span><br><span class="line"><span class="comment">// *表示1个单词，#表示0个或多个，也就是这里会发送给多个队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Fanout模式-交换机Exchange-广播模式"><a href="#Fanout模式-交换机Exchange-广播模式" class="headerlink" title="Fanout模式 交换机Exchange  广播模式"></a>Fanout模式 交换机Exchange  广播模式</h2><p>向所有队列分发</p><p>原因：</p><h1 id="6-5-秒杀接口优化"><a href="#6-5-秒杀接口优化" class="headerlink" title="6-5 秒杀接口优化"></a>6-5 秒杀接口优化</h1><p>思路：减少数据库访问<br>1.系统初始化，把商品库存数量加载到Redis<br>2.收到请求，Redis预减库存，库存不足，直接返回，否则继续（redis库存为0后，之后对数据库请求几乎为0）<br>3.请求入队，<strong>立即返回排队中</strong>响应。异步操作，（成功失败不明，只是在排队）</p><p>以下两部并发进行<br>4.服务端：请求出队，生成订单，减少库存。订单写入缓存<br>5.客户端：收到排队中消息之后，会轮询，询问缓存 是否秒杀成功</p><hr><p>秒杀流程：<br><strong>MiaoshaController</strong><br>1.<code>afterPropertiesSet()</code>系统初始化，把所有商品库存数量加载到Redis<br>2.注解实现user通过token注入，判断是否登录<br>4.判断内存库存标记map，map对应商品标记over是否为true，是则直接返回错误。<br>3.判断redis缓存库存，预减库存。库存为&lt;0时,设置map对应商品标记为true<br>4.判断redis缓存订单，是否存在，表示已秒杀。<br>5.user和goodsid封装到message，由mqSender发送消息。<br>6.<code>return Result.success(0);//表示排队中</code></p><p><strong>MQSender</strong><br>1.将MiaoshaMessage给beanToString，传输string消息<br>2.发送消息<code>amqpTemplate.convertAndSend(MQConfig.MIAOSHA_QUEUE, msg);</code></p><p><strong>MQReceiver</strong><br>1.MQReceiver已绑定队列，将消息还原成BEAN，得到goodsId和user<br>2.根据goodsId生产GoodsVo，判断GoodsVo库存（数据库）<br>3.根据goodsId和user查询order，判断是否已经存在订单（是否已秒杀）（数据库）<br>4.<code>miaoshaService.miaosha(user, goods)</code></p><p><strong>MiaoshaService</strong><br>1.调用数据库，减库存。<code>goodsService.reduceStock</code>的DAO操作Update要满足，stock&gt;0,返回 success<br>2.根据success，决定是否新建order订单（不是miaoshaOrder）</p><p>客户端：<br>接收到0，轮询服务端</p><p>负载到25  2534</p><h1 id="6-7-压力测试对比"><a href="#6-7-压力测试对比" class="headerlink" title="6-7 压力测试对比"></a>6-7 压力测试对比</h1><h2 id="nginx-反向代理"><a href="#nginx-反向代理" class="headerlink" title="nginx 反向代理"></a>nginx 反向代理</h2><p>监听80端口，转发给 集群</p><p><strong>负载均衡</strong><br>转发给本机  weight = 1<br>转发给其他服务器  weight = 2 </p><p><strong>探活机制</strong><br>max_fail = 2 最多允许失败两次 </p><p>LVS：集成到linux内核了，分发给</p>]]></content>
      
      <categories>
          
          <category> 秒杀项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 秒杀项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-15 三数之和</title>
      <link href="/2018/07/19/LeetCode-6%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2018/07/19/LeetCode-6%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-6-三数之和"><a href="#LeetCode-6-三数之和" class="headerlink" title="LeetCode-6 三数之和"></a>LeetCode-6 三数之和</h1><p>难度：middle</p><p>给定一个包含 n 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><blockquote><p>例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</p><p>满足要求的三元组集合为： [   [-1, 0, 1],   [-1, -1, 2] ]</p></blockquote><p>前面做过一道TwoSum的题，思路是对于每一个数a，在HashMap中查找是否有n-a这个数，有则找到，没有则把a添加进Map，a为key，索引为value。</p><p>这道题，一开始思路也是想这样，但是存在两个问题：1.数有重复，所以不能以数为索引。2.可能会有-1，-1，2这样的情况，无法解决。</p><p>这一题大思路肯定是找通过a，查找两数之和-a，可以肯定的是，三个数中肯定有正有负。定下一个数后，就可以通过双指针来变量。</p><p><code>双指针解法往往对有序数组格外生效</code>，所以我们将数组排序。</p><p>一些剪纸优化：假如第一个数是4，我们要寻找的twoSum是-4，第二个确定的数是-1，那么我们在遍历到正数的时候就break，</p><p>然后我们还要加上重复就跳过的处理，处理方法是从第二个数开始，如果和前面的数字相等，就跳过（-1，-1，2如何解决呢？），因为我们不想把相同的数字fix两次。对于遍历到的数，用0减去这个fix的数得到一个target，然后只需要再之后找到两个数之和等于target即可。</p><p>用两个指针分别指向fix数字之后 开始的数组<strong>首尾两个数</strong>，如果两个数<strong>和正好为target</strong>，则将这两个数和fix的数一起存入结果中。<br>如果<strong>和小于target</strong>，说明需要一个更大的数，所以左指针右移。<br>如果<strong>和大于target</strong>，说明需要一个更小的数，所以右指针左移。</p><p>然后就是跳过重复数字的步骤了，两个指针都需要检测重复数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leetcode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leetcode_15</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fix = nums[<span class="number">0</span>], target = - fix;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums.length - <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//右边都是比nums[i]大的数，也就是都大于0 不可能找到了</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) &#123; <span class="comment">//第二个数开始，遇到一个重复的数，不想重复找两次，跳过</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            target = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">int</span> p1 = i + <span class="number">1</span>, p2 = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (p1 &lt; p2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[p1] + nums[p2] == target ) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(p2 != nums.length -<span class="number">1</span> &amp;&amp; nums[p1] == nums[p1 -<span class="number">1</span>] &amp;&amp; nums[p2] == nums[p2+<span class="number">1</span>])&#123; <span class="comment">//避免-2 0 0 2 2 重复的问题</span></span><br><span class="line">                        ++p1; --p2;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    List listThree = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                    listThree.add(nums[i]);</span><br><span class="line">                    listThree.add(nums[p1]);</span><br><span class="line">                    listThree.add(nums[p2]);</span><br><span class="line">                    list.add(listThree);</span><br><span class="line">                    ++p1; --p2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[p1] + nums[p2] &lt; target) &#123;</span><br><span class="line">                    p1++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p2--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List list1 : threeSum(a))</span><br><span class="line">            <span class="keyword">for</span> (Object i : list1) &#123;</span><br><span class="line">                System.out.println(<span class="string">""</span>+ i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秒杀项目学习笔记 第五章————页面优化技术</title>
      <link href="/2018/07/18/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
      <url>/2018/07/18/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%BA%94%E7%AB%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<h1 id="秒杀项目学习笔记-第五章————页面优化技术"><a href="#秒杀项目学习笔记-第五章————页面优化技术" class="headerlink" title="秒杀项目学习笔记 第五章————页面优化技术"></a>秒杀项目学习笔记 第五章————页面优化技术</h1><p><strong>核心思路：减少对数据库的访问</strong></p><h1 id="5-1-页面缓存"><a href="#5-1-页面缓存" class="headerlink" title="5-1 页面缓存"></a>5-1 页面缓存</h1><p>特点：有效期往往比较短<br>1.取缓存，html存放在缓存中，可取出则<br>2.不可则 手动渲染模板  ，并且存放在redis中<br>3.结果输出</p><p>以<strong>goods_list</strong>为例，在Controller中，添加注解，直接返回html<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取缓存,取到返回。html是长文本，一堆</span></span><br><span class="line"> String html = redisService.get(GoodsKey.getGoodsList, <span class="string">""</span>, String.class);</span><br><span class="line"> <span class="keyword">if</span> (!StringUtils.isEmpty(html)) &#123;</span><br><span class="line">     <span class="keyword">return</span> html;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//取不到，手动渲染并且加入到redis中，ThemleafViewResolver,</span></span><br><span class="line"> SpringWebContext ctx = <span class="keyword">new</span> SpringWebContext(request, response, request.getServletContext(),</span><br><span class="line">         request.getLocale(), model.asMap(), applicationContext);<span class="comment">//配置一下环境，下面会用到，配起来就是根据接口， 缺啥补啥</span></span><br><span class="line"> html = thymeleafViewResolver.getTemplateEngine().process(<span class="string">"goods_list"</span>, ctx);<span class="comment">//选择模板（页面），进行渲染（成字符串）</span></span><br><span class="line"> <span class="keyword">if</span> (StringUtils.isEmpty(html)) &#123;</span><br><span class="line">     redisService.set(GoodsKey.getGoodsList, <span class="string">""</span>, html);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> html;</span><br></pre></td></tr></table></figure></p><p>时间一般较短，显示前两页</p><h1 id="5-2-对象缓存（重点：更新对象缓存！！）"><a href="#5-2-对象缓存（重点：更新对象缓存！！）" class="headerlink" title="5-2 对象缓存（重点：更新对象缓存！！）"></a>5-2 对象缓存（重点：更新对象缓存！！）</h1><p><strong>获取对象操作</strong><br>比如user对象的缓存，对于对象，设置过期时间为永不过期。<br>1.取对象缓存<br>2.取为null则从数据库中取，并且写入redis缓存。<br><strong>更新密码操作。</strong><br>1.取对象（以上）<br>2.更新对象密码，update写入数据库，<br>3.更新缓存：删除原缓存，<code>user.setPassword</code>，user写入缓存</p><p>不能去调用其他类的DAO，只能调用其他类的Service，<br>Jmeter查询发现mysql的内存占用还是很高。</p><h1 id="5-4-商品详情静态化、也就是前后端分离"><a href="#5-4-商品详情静态化、也就是前后端分离" class="headerlink" title="5-4 商品详情静态化、也就是前后端分离"></a>5-4 商品详情静态化、也就是前后端分离</h1><p>常用技术AngularJs  Vue.js<br>优点：利用浏览器的缓存</p><p>1.将goods_detail.htm放在resoucrse的static中，<br>2.将静态页面放在static中，后缀为htm，因为在application中配置了会去resources中寻找.html后缀<br><code>&lt;td&gt;&lt;a th:href=&quot;&#39;/goods_detail.htm?goodsId=&#39;+${goods.id}&quot;&gt;详情&lt;/a&gt;&lt;/td&gt;</code><br>3.在客户端写入异步获取请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">//countDown();</span><br><span class="line">getDetail();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function getDetail()&#123;</span><br><span class="line">var goodsId = g_getQueryString(&quot;goodsId&quot;);</span><br><span class="line">$.ajax(&#123; //异步访问客户端，获取参数</span><br><span class="line">url:&quot;/goods/detail/&quot;+goodsId,</span><br><span class="line">type:&quot;GET&quot;,</span><br><span class="line">success:function(data)&#123;</span><br><span class="line">if(data.code == 0)&#123;</span><br><span class="line">render(data.data);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">layer.msg(data.msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">error:function()&#123;</span><br><span class="line">layer.msg(&quot;客户端请求有误&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="5-5-秒杀静态化"><a href="#5-5-秒杀静态化" class="headerlink" title="5-5 秒杀静态化"></a>5-5 秒杀静态化</h1><p>1.改造后端，<br>不是 不停地<code>model.addAttribute(&quot;orderInfo&quot;, orderInfo);</code><br>最后再返回”order_detail”客户端跳转，获取model熟悉</p><p>而是返回一个<code>Result.success(orderInfo)</code>表单，从客户端调用ajax跳转。然后取客户端传来的参数。</p><p>2.改造前端，前端goods_detail.htm的秒杀按钮，对应函数如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function doMiaosha()&#123;</span><br><span class="line"></span><br><span class="line">    //点击了秒杀按钮后， ajax异步调用 发送表单请求（传goodsId），得到结果，success则跳转到订单详情，失败则，error</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">url:&quot;/miaosha/do_miaosha&quot;,</span><br><span class="line">type:&quot;POST&quot;,</span><br><span class="line">data:&#123;</span><br><span class="line">goodsId:$(&quot;#goodsId&quot;).val(),</span><br><span class="line">&#125;,</span><br><span class="line">success:function(data)&#123; //这里的data就是do_miaosha返回的Result了</span><br><span class="line">if(data.code == 0)&#123;</span><br><span class="line">window.location.href=&quot;/order_detail.htm?orderId=&quot;+data.data.id;//秒杀成功，跳转到订单详情//data.data就是vo</span><br><span class="line">&#125;else&#123;</span><br><span class="line">layer.msg(data.msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">error:function()&#123;</span><br><span class="line">layer.msg(&quot;客户端请求有误&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>秒杀返回的状态码是304，表示服务端表示你本地的页面没有变化，页面不用下载了，但是客户端与服务端还是有交互。</p><h2 id="利用SpringBoot的-SPRING-RESOURCES-HANDLING"><a href="#利用SpringBoot的-SPRING-RESOURCES-HANDLING" class="headerlink" title="利用SpringBoot的 SPRING RESOURCES HANDLING"></a>利用SpringBoot的 SPRING RESOURCES HANDLING</h2><p>参考文档：<a href="https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/</a></p><p>然后在浏览器访问一次后，后台就会判断，不会发生交互。直接返回200状态码。</p><h1 id="5-6-订单详情静态化-解决超卖"><a href="#5-6-订单详情静态化-解决超卖" class="headerlink" title="5-6 订单详情静态化 解决超卖"></a>5-6 订单详情静态化 解决超卖</h1><p>生成的订单放到redis缓存中，秒杀判断是否已经生成订单的时候，可以不用去数据库查询了，直接从缓存中查询</p><h1 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h1><p>秒杀逻辑： 1.先判断库存 &gt;0 2.再判断是否已经秒杀过，也就是是否存在秒杀订单。<br>3.再减库存下订单。（这里再判断一下库存？？）</p><p><strong>问题：同一用户买多个</strong><br>同一个用户两个请求，判断有库存，判断都没有秒杀，然后下了两个订单。<br><strong>解决：更新加判断，并且秒杀订单表加唯一索引报错，秒杀事务回滚</strong><br><strong>优化1：</strong>给更新库存，减库存的时候加了一个判断。只在stock_count&gt;0的情况下减库存。<br><strong>优化2：</strong>:对其数据表建立唯一索引，第二个订单就插不进表，从而报错，秒杀请求事务回滚。</p><h1 id="5-7-静态资源优化"><a href="#5-7-静态资源优化" class="headerlink" title="5-7 静态资源优化"></a>5-7 静态资源优化</h1><p>1.JS/CSS压缩， 减少流量（去掉空格之类）<br>2.多个JS/CSS组合，减少连接数<br>一般并发3 4个链接 从服务端获取资源，提高页面加载速度</p><p>淘宝：Tengine<br><a href="http://tengine.taobao.org/" target="_blank" rel="noopener">http://tengine.taobao.org/</a><br><a href="http://tengine.taobao.org/document_cn/http_concat_cn.html" target="_blank" rel="noopener">http://tengine.taobao.org/document_cn/http_concat_cn.html</a></p><p>webpack：打包前端文件</p><p>3.CDN就近访问<br>CDN：内容分发网络，把数据缓存到全网节点上，根据用户请求，分发到离用户最近（最快）的位置上。</p><p>瓶颈：数据库，所以要削减请求到数据库的数量</p><h2 id="并发解决流程"><a href="#并发解决流程" class="headerlink" title="并发解决流程"></a>并发解决流程</h2><p>用户开始：</p><ol><li>浏览器页面静态化，缓存到浏览器端。</li><li>部署CDN节点，请求首先访问到就近CDN缓存，</li><li>ngiinx缓存</li><li>redis应用程序页面缓存 –对象缓存 </li><li>数据库</li></ol>]]></content>
      
      <categories>
          
          <category> 秒杀项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 秒杀项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秒杀项目学习笔记 第四章————秒杀压测 Jmeter压力测试</title>
      <link href="/2018/07/15/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E5%8E%8B%E6%B5%8B%20Jmeter%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/07/15/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%A7%92%E6%9D%80%E5%8E%8B%E6%B5%8B%20Jmeter%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h1 id="秒杀项目学习笔记-第四章————秒杀压测-Jmeter压力测试"><a href="#秒杀项目学习笔记-第四章————秒杀压测-Jmeter压力测试" class="headerlink" title="秒杀项目学习笔记 第四章————秒杀压测 Jmeter压力测试"></a>秒杀项目学习笔记 第四章————秒杀压测 Jmeter压力测试</h1><h1 id="4-1-Jmeter入门"><a href="#4-1-Jmeter入门" class="headerlink" title="4-1 Jmeter入门"></a>4-1 Jmeter入门</h1><p>可以对网页进行压测</p><h1 id="4-2-自定义变量"><a href="#4-2-自定义变量" class="headerlink" title="4-2 自定义变量"></a>4-2 自定义变量</h1><h1 id="4-3-命令行压测"><a href="#4-3-命令行压测" class="headerlink" title="4-3  命令行压测"></a>4-3  命令行压测</h1><p>redis压测 <strong>redis-benchmark</strong></p><ol><li><p>redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000    100个并发 100000次访问<br>1.6s完成 100000次get  1s内完成79% 2s 96%    <strong>6W/S</strong></p></li><li><p>redis-benchmark -h 127.0.0.1 -p 6379 -q -d 100   存储大小为以100字节的数据包 </p></li></ol><p>3.redis-benchmark -t set, lpush - q -n 100000  只测试set和lpush命令</p><ol start="4"><li>redis-benchmark -n 100000 -q script load “redis.call(‘set’,’foo’,’bar’)”<br>只执行此命令的压测</li></ol><h1 id="Spring-Boot-打war包-与jar包的区别？？？"><a href="#Spring-Boot-打war包-与jar包的区别？？？" class="headerlink" title="Spring Boot 打war包  与jar包的区别？？？"></a>Spring Boot 打war包  与jar包的区别？？？</h1><p>1.添加spring-boot-starter-tomcat的provided依赖（编译时依赖，运行时不需要）<br>2.添加maven-war-plugin插件<br>3.修改 <code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>4 修改启动类,添加<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiaoshaApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.sources(MainApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5.到目录下  <code>mvn clean package</code> 与install有什么区别？？</p><h1 id="服务器上压力测试"><a href="#服务器上压力测试" class="headerlink" title="服务器上压力测试"></a>服务器上压力测试</h1><p>上传goods_list.jmx到服务器<br>`./apache-jmeter-3.3/bin/jmeter.sh -n -t goods_list.jmx -l result.jtl</p>]]></content>
      
      <categories>
          
          <category> 秒杀项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 秒杀项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秒杀项目学习笔记 第三章————秒杀功能开发及管理后台</title>
      <link href="/2018/07/15/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%89%E7%AB%A0(%E7%A7%92%E6%9D%80%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E5%8F%8A%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%EF%BC%89/"/>
      <url>/2018/07/15/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20%E7%AC%AC%E4%B8%89%E7%AB%A0(%E7%A7%92%E6%9D%80%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%E5%8F%8A%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="秒杀项目学习笔记-第三章-秒杀功能开发及管理后台）"><a href="#秒杀项目学习笔记-第三章-秒杀功能开发及管理后台）" class="headerlink" title="秒杀项目学习笔记 第三章(秒杀功能开发及管理后台）"></a>秒杀项目学习笔记 第三章(秒杀功能开发及管理后台）</h1><h1 id="3-1-商品列表页的设计"><a href="#3-1-商品列表页的设计" class="headerlink" title="3-1 商品列表页的设计"></a>3-1 商品列表页的设计</h1><p>1.表设计：分为商品表，订单表，秒杀商品表，秒杀订单表<br>分开是为了易于维护。</p><p><img src="http://pbw0qqogs.bkt.clouddn.com/%E7%A7%92%E6%9D%80%E6%A8%A1%E5%9D%97%E6%B5%81%E7%A8%8B.jpg" alt="此处输入图片的描述"></p><p>2.使用IDEA的数据表生成pojo功能：datebase→连接→Scripted Extensions→generatePojo</p><p>3.goodsService的会调用goodsDao.listGoodsVo方法取出来的是GoodsVo而不是Goods，GoodsVo内的属性是从数据库多表中联立取出。</p><p>4.取出的list加入到model中，在html中通过thymleaf循环取出</p><h1 id="3-3-商品详情页的设计"><a href="#3-3-商品详情页的设计" class="headerlink" title="3-3 商品详情页的设计"></a>3-3 商品详情页的设计</h1><p>彩蛋：数据库ID一般不用自增，容易被他人遍历，而用snowflake算法</p><p>前端部分：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:if</span>=<span class="string">"$&#123;user eq null&#125;"</span>&gt;</span> 您还没有登录，请登陆后再操作<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">td</span>&gt;</span>秒杀开始时间<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(goods.startDate, 'yyyy-MM-dd HH:mm:ss')&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">td</span> <span class="attr">id</span>=<span class="string">"miaoshaTip"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 隐藏域临时保存$&#123;remainSeconds&#125;，在进行中和已结束也有remainSeconds，只是不显示--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"remainSeconds"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;remainSeconds&#125;"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:if</span>=<span class="string">"$&#123;miaoshaStatus eq 0&#125;"</span>&gt;</span>秒杀倒计时：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"countDown"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;remainSeconds&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>秒<span class="tag">&lt;/<span class="name">span</span>&gt;</span>//倒计时的设计</span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:if</span>=<span class="string">"$&#123;miaoshaStatus eq 1&#125;"</span>&gt;</span>秒杀进行中<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:if</span>=<span class="string">"$&#123;miaoshaStatus eq 2&#125;"</span>&gt;</span>秒杀已结束<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"miaoshaForm"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">action</span>=<span class="string">"/miaosha/do_miaosha"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-primary btn-block"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">id</span>=<span class="string">"buyButton"</span>&gt;</span>立即秒杀<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"goodsId"</span> <span class="attr">th:value</span>=<span class="string">"$&#123;goods.id&#125;"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure><p>秒杀倒计时的设计：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:if</span>=<span class="string">"$&#123;miaoshaStatus eq 0&#125;"</span>&gt;</span>秒杀倒计时：<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"countDown"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;remainSeconds&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>秒<span class="tag">&lt;/<span class="name">span</span>&gt;</span>//倒计时的设计</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">$(function()&#123;</span><br><span class="line">countDown();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function countDown()&#123;</span><br><span class="line"></span><br><span class="line">var remainSeconds = $(&quot;#remainSeconds&quot;).val();</span><br><span class="line">    var timeout;</span><br><span class="line">    </span><br><span class="line">if(remainSeconds &gt; 0)&#123;//秒杀还没开始，倒计时</span><br><span class="line">$(&quot;#buyButton&quot;).attr(&quot;disabled&quot;, true);</span><br><span class="line"></span><br><span class="line">timeout = setTimeout(function()&#123;</span><br><span class="line">$(&quot;#countDown&quot;).text(remainSeconds - 1);</span><br><span class="line">$(&quot;#remainSeconds&quot;).val(remainSeconds - 1);</span><br><span class="line">countDown();//回调函数，回调自己</span><br><span class="line">&#125;,1000);</span><br><span class="line">&#125;else if(remainSeconds == 0)&#123;//秒杀进行中</span><br><span class="line">$(&quot;#buyButton&quot;).attr(&quot;disabled&quot;, false);</span><br><span class="line">if(timeout)&#123;</span><br><span class="line">clearTimeout(timeout);</span><br><span class="line">&#125;</span><br><span class="line">$(&quot;#miaoshaTip&quot;).html(&quot;秒杀进行中&quot;);</span><br><span class="line">&#125;else&#123;//秒杀已经结束</span><br><span class="line">$(&quot;#buyButton&quot;).attr(&quot;disabled&quot;, true);</span><br><span class="line">$(&quot;#miaoshaTip&quot;).html(&quot;秒杀已经结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="controller类里接收参数-PathVariable和-RequestParam的区别"><a href="#controller类里接收参数-PathVariable和-RequestParam的区别" class="headerlink" title="controller类里接收参数@PathVariable和@RequestParam的区别"></a>controller类里接收参数@PathVariable和@RequestParam的区别</h2><p>1.@PathVariable 路径变量，是用来获得请求url中的动态参数的，用于<strong>将请求URL中的模板变量</strong>映射到功能处理方法的参数上。<br><figure class="highlight plain"><figcaption><span>th:href</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后</span><br><span class="line">```Java</span><br><span class="line">    @RequestMapping(&quot;/to_detail/&#123;goodsId&#125;&quot;)</span><br><span class="line">    public String detail(Model model, MiaoshaUser user,</span><br><span class="line">                         @PathVariable(&quot;goodsId&quot;) long goodsId)&#123;</span><br></pre></td></tr></table></figure></p><p>2.@RequestParam ：请求参数  用于接收request发来的参数</p><p>在SpringMVC后台控制层获取参数的方式主要有两种:<br>一种是request.getParameter(“name”)，另外一种是用注解@RequestParam直接获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/do_miaosha"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model, MiaoshaUser user, @RequestParam(<span class="string">"goodsId"</span>)</span> <span class="keyword">long</span> goodsId)</span>&#123;</span><br></pre></td></tr></table></figure></p><p>接下来我们看一下@RequestParam注解主要有哪些<strong>参数</strong>：<br><strong>value：</strong>参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入；<br><strong>required：</strong>是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码；<br><strong>defaultValue：</strong>默认值，表示如果请求中没有同名参数时的默认值，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;EasyUITreeNode&gt; <span class="title">getItemTreeNode</span><span class="params">(@RequestParam(value=<span class="string">"id"</span>,defaultValue=<span class="string">"0"</span>)</span><span class="keyword">long</span> parentId)</span></span><br></pre></td></tr></table></figure></p><h1 id="3-4-秒杀方法的实现-秒杀需要user，和gooodsId"><a href="#3-4-秒杀方法的实现-秒杀需要user，和gooodsId" class="headerlink" title="3-4 秒杀方法的实现  秒杀需要user，和gooodsId"></a>3-4 秒杀方法的实现  秒杀需要user，和gooodsId</h1><p>1.点击秒杀，传入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id=&quot;miaoshaForm&quot; method=&quot;post&quot; action=&quot;/miaosha/do_miaosha&quot;&gt;</span><br><span class="line">    &lt;button class=&quot;btn btn-primary btn-block&quot; type=&quot;submit&quot; id=&quot;buyButton&quot;&gt;立即秒杀&lt;/button&gt;&lt;!-- 只有在进行中才可以点击--&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;goodsId&quot; th:value=&quot;$&#123;goods.id&#125;&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p><p>2.MiaoshaController只需要两个</p><ul><li>判断user是否为空，为空跳转到login</li><li>判断商品是否还有库存，user是否已经秒杀过（这个用户是否有order）。是的话跳转到miaosha_fail</li><li>调用miaoshaService。<code>OrderInfo orderInfo = miaoshaService.miaosha(user, goods);</code></li></ul><p>3.<code>MiaoshaService</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span><span class="comment">//事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderInfo <span class="title">miaosha</span><span class="params">(MiaoshaUser user, GoodsVo goods)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减库存根据逻辑应该在goodsService中完成而不是在miaoshaService里完成</span></span><br><span class="line">    goodsService.reduceStock(goods);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新建订单,返回一个orderInfo对象</span></span><br><span class="line">    <span class="keyword">return</span> orderService.createOrder(user, goods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>3.1 <code>goodsService</code>减库存操作</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">goodsService.reduceStock(goods.getId());<span class="comment">//使用了ID而没有像教程一样传入GoodsVo,会根据goodsId去减少Miaosha_goods中对应的库存</span></span><br></pre></td></tr></table></figure></p><p><strong>3.2 <code>orderService</code>新建订单操作</strong><br>orderService中。先创建一个OrderInfo对象，然后根据GoodsVogoods对其设置其属性值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成订单后插入orderInfo到order表里</span></span><br><span class="line"><span class="keyword">long</span> orderId = orderDao.insert(orderInfo);</span><br></pre></td></tr></table></figure></p><p>再创建miaoshaOrder并设置其属性值，这里用到了生成的orderId，然后<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成订单后插入miaoshaOrder到miaosha_order表里</span></span><br><span class="line">orderDao.insertMiaoshaOrder(miaoshaOrder);</span><br><span class="line"><span class="keyword">return</span> orderInfo;</span><br></pre></td></tr></table></figure></p><p>最后orderService返回订单，并MiaoshaService返回订单，MiaoshaController添加对象到视图中，跳转到order_detail显示属性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OrderInfo orderInfo = miaoshaService.miaosha(user, goods);</span><br><span class="line"></span><br><span class="line">model.addAttribute(<span class="string">"orderInfo"</span>, orderInfo);</span><br><span class="line">model.addAttribute(<span class="string">"goods"</span>, goods);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"order_detail"</span>;</span><br></pre></td></tr></table></figure></p><h1 id="3-5-订单详情页"><a href="#3-5-订单详情页" class="headerlink" title="3-5 订单详情页"></a>3-5 订单详情页</h1><p>很简单。在order_detail中取出显示出来即可。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;订单状态&lt;/td&gt;  </span><br><span class="line">   &lt;td &gt;</span><br><span class="line">   &lt;span th:if="$&#123;orderInfo.status eq 0&#125;"&gt;未支付&lt;/span&gt;</span><br><span class="line">   &lt;span th:if="$&#123;orderInfo.status eq 1&#125;"&gt;待发货&lt;/span&gt;</span><br><span class="line">   &lt;span th:if="$&#123;orderInfo.status eq 2&#125;"&gt;已发货&lt;/span&gt;</span><br><span class="line">   &lt;span th:if="$&#123;orderInfo.status eq 3&#125;"&gt;已收货&lt;/span&gt;</span><br><span class="line">   &lt;span th:if="$&#123;orderInfo.status eq 4&#125;"&gt;已退款&lt;/span&gt;</span><br><span class="line">   &lt;span th:if="$&#123;orderInfo.status eq 5&#125;"&gt;已完成&lt;/span&gt;</span><br><span class="line">   &lt;/td&gt;  </span><br><span class="line">   &lt;td&gt;</span><br><span class="line">   &lt;button class="btn btn-primary btn-block" type="submit" id="payButton"&gt;立即支付&lt;/button&gt;</span><br><span class="line">   &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> 秒杀项目 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式沉思录（一）之工厂模式</title>
      <link href="/2018/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式沉思录（二）之抽象工厂模式"><a href="#设计模式沉思录（二）之抽象工厂模式" class="headerlink" title="设计模式沉思录（二）之抽象工厂模式"></a>设计模式沉思录（二）之抽象工厂模式</h1><p>本文整理自四人帮著作：<strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong></p><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该<strong>超级工厂又称为其他工厂的工厂</strong>。这种类型的设计模式属于创建型模式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><p>介绍<br>意图：提供一个 <strong>创建一系列相关或相互依赖对象</strong> 的接口，而无需指定它们具体的类。<br>主要解决：主要解决<strong>接口选择</strong>的问题。<br>何时使用：系统的产品有<strong>多于一个的产品族（需要多个产品工厂），比如需要手机工厂，又需要手机壳工厂</strong>，而系统只消费其中某一族的产品。</p><p>如何解决：在一个产品族里面，定义多个产品。<br>关键代码：在一个工厂里聚合多个同类产品。手机工厂既生产小米手机，又生产华为手机（富土康？？？），也有对应的手机壳工厂</p><p>应用实例：<br>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即<strong>一系列</strong>具体产品。</p><p>假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的<strong>衣柜</strong>（具体工厂）都是<strong>衣柜类</strong>的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><p>优点：当一个产品族中的多个对象被设计成<strong>一起工作</strong>时，它能保证客户端始终<strong>只使用同一个产品族</strong>中的对象。<br>缺点：<strong>产品族扩展非常困难</strong>，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。如果想要添加一个新的产品，需要对接口进行改动，对接口的改动就意味着要改动所有实现该接口的类，这是很可怕的事情。这里要注意是不容易添加产品族，而不是添加产品等级，因为添加产品等级不需要对现有的接口进行改变。（举例：</p><p>使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。<br>注意事项：产品族难扩展，产品等级易扩展。</p><p>实现</p><p><a href="http://www.runoob.com/wp-content/uploads/2014/08/abstractfactory_pattern_uml_diagram.jpg" target="_blank" rel="noopener">此处输入链接的描述</a><br>ShapeFactory和ColorFactory继承AbstractFactory，生产实现了shape和color的实现类</p><p>1.前面的shape和color接口，以及各自的实现类可以类比。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.获取对应工厂， 为 Color 和 Shape 对象创建抽象类 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工厂类的父类————抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个抽象工厂抽象类吧，有两个建造产品类</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span> </span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.只写出shapeFactory，继承自抽象工厂，若需要增加工厂，直接添加工厂类并且继承抽象工厂<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.创建一个工厂创造器/生成器类，通过传递形状或颜色信息来<strong>获取工厂</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"SHAPE"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice.equalsIgnoreCase(<span class="string">"COLOR"</span>))&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.Demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">      <span class="comment">//获取形状工厂,抽象工厂对象 指向 具体工厂实例</span></span><br><span class="line">      AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">"SHAPE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>1.在抽象工厂模式中，假设我们需要增加一个工厂<br>很简单，直接增加一个工厂类（继承抽象工厂），并且实现这个新工厂的所有产品方法</p><p>2.在抽象工厂模式中，假设我们需要增加一个产品<br>很麻烦，因为要修改接口，多一个生产方法，导致所有继承了这个抽象工厂的工厂都要加上。<br>再添加新产品父类。</p>]]></content>
      
      <categories>
          
          <category> 原理理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式沉思录（四）之建造者模式</title>
      <link href="/2018/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式沉思录（四）之建造者模式"><a href="#设计模式沉思录（四）之建造者模式" class="headerlink" title="设计模式沉思录（四）之建造者模式"></a>设计模式沉思录（四）之建造者模式</h1><p>建造者模式（Builder Pattern）使用多个<strong>简单的对象</strong>一步一步<strong>构建成</strong>一个<strong>复杂的对象</strong>。这种类型的设计模式属于创建型模式。</p><p>本文整理自四人帮著作：<strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong></p><p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p><p>介绍<br>意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p>主要解决：主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的<strong>算法构成</strong>；由于需求的变化，这个<strong>复杂对象的各个部分经常面临着剧烈的变化</strong>，但是将它们组合在一起的算法却相对稳定。</p><p>何时使用：一些基本部件不会变，而其<strong>组合经常变化</strong>的时候。<br>如何解决：<strong>将变与不变分离开。</strong><br>关键代码：建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p>应用实例： 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”<strong>套餐</strong>“。 2、JAVA 中的 <strong>StringBuilder</strong>。</p><p>优点： 1、建造者独立，易扩展。 2、便于控制细节风险。<br>缺点： 1、产品必须有<strong>共同点</strong>，范围有限制。 2、如内部变化复杂，会有<strong>很多的建造类（钉子锤子桌椅板凳一大堆）</strong>。</p><p>使用场景： 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身<strong>相互依赖（相互包装）</strong>。</p><p>注意事项：与工厂模式的区别是：建造者模式<strong>更加关注与零件装配的顺序。</strong></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是<strong>包在纸盒中</strong>。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是<strong>装在瓶子中</strong>。</p><p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示<strong>食物包装的 Packing 接口</strong>和实现 Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p><p>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的 MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal。<br><img src="http://www.runoob.com/wp-content/uploads/2014/08/builder_pattern_uml_diagram.jpg" alt="此处输入图片的描述"></p><p>  步骤1：Item接口和Packing接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤2：创建实现 这俩接口的实体类，瓶子和冷饮的实现类似，省略了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Burger</span> <span class="keyword">implements</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Wrapper();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Wrapper"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤三。创建扩展了 Burger 和 ColdDrink 的实体类。如蔬菜汉堡包，其他的扩展子类类似，省略了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span> </span>&#123;</span><br><span class="line"><span class="comment">//蔬菜汉堡包</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">25.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Veg Burger"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤四，重点来了~~！！！创建一个 Meal 类，带有上面定义的 Item 对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;Item&gt;();    </span><br><span class="line"> <span class="comment">//将套餐所有东西，添加到这个类的列表中，搭建起来</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">      items.add(item);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">float</span> cost = <span class="number">0.0f</span>;</span><br><span class="line">      <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">         cost += item.price();</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">return</span> cost;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showItems</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">         System.out.print(<span class="string">"Item : "</span>+item.name());</span><br><span class="line">         System.out.print(<span class="string">", Packing : "</span>+item.packing().pack());</span><br><span class="line">         System.out.println(<span class="string">", Price : "</span>+item.price());</span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤五：创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MealBuilder</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareVegMeal</span> <span class="params">()</span></span>&#123;<span class="comment">//素食套餐</span></span><br><span class="line">      Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> VegBurger());</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> Coke());</span><br><span class="line">      <span class="keyword">return</span> meal;</span><br><span class="line">   &#125;   </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareNonVegMeal</span> <span class="params">()</span></span>&#123;<span class="comment">//肉食套餐</span></span><br><span class="line">      Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> Pepsi());</span><br><span class="line">      <span class="keyword">return</span> meal;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="此处理解不够透彻。建议在看看书上。再做更多总结"><a href="#此处理解不够透彻。建议在看看书上。再做更多总结" class="headerlink" title="此处理解不够透彻。建议在看看书上。再做更多总结"></a>此处理解不够透彻。建议在看看书上。再做更多总结</h2>]]></content>
      
      <categories>
          
          <category> 原理理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式沉思录（三）之单例模式</title>
      <link href="/2018/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式沉思录（三）之单例模式"><a href="#设计模式沉思录（三）之单例模式" class="headerlink" title="设计模式沉思录（三）之单例模式"></a>设计模式沉思录（三）之单例模式</h1><p>本文整理自四人帮著作：<strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong></p><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时<strong>确保只有单个对象被创建</strong>。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>注意：<br>1、单例类<strong>只能有一个</strong>实例。<br>2、单例类必须<strong>自己创建</strong>自己的唯一实例。<br>3、单例类必须<strong>给所有其他对象提供</strong>这一实例。</p><p>介绍<br>意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>主要解决：一个<strong>全局使用的类</strong>频繁地创建与销毁。<br>何时使用：当您想控制实例数目，节省系统资源的时候。<br>如何解决：判断系统<strong>是否已经有</strong>这个单例，如果有则返回，如果没有则创建。<br>关键代码：构造函数是私有的。</p><p>应用实例：<br>1、一个党只能有一个主席。<br>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p><p>优点：<br>1、在内存里只有一个实例，<strong>减少了内存</strong>的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<br>2、避免对资源的<strong>多重占用</strong>（比如写文件操作）。</p><p>缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p>使用场景：<br>1、要求生产唯一序列号。<br>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。<br>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p><p>注意事项：getInstance() 方法中需要使用同步锁防止多线程同时进入造成 instance 被多次实例化。</p><h1 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h1><h2 id="1、懒汉式，线程不安全"><a href="#1、懒汉式，线程不安全" class="headerlink" title="1、懒汉式，线程不安全"></a>1、懒汉式，线程不安全</h2><p><strong>叫懒汉是因为他很懒，平时不叫他他就不实例化，要用到他了才匆匆忙忙实例化</strong><br>是否 Lazy 初始化：是<br>是否多线程安全：否<br>实现难度：易</p><p>描述：最基本，最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。在多线程不能正常工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、懒汉式，线程安全（一次同步锁）"><a href="#2、懒汉式，线程安全（一次同步锁）" class="headerlink" title="2、懒汉式，线程安全（一次同步锁）"></a>2、懒汉式，线程安全（一次同步锁）</h2><p>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是<strong>效率很低</strong>，因为99% 情况下不需要同步，你却每次getInstance的时候都锁一下。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用较少）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;<span class="comment">//对构造方法加锁，性能差  </span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3、饿汉式，线程安全"><a href="#3、饿汉式，线程安全" class="headerlink" title="3、饿汉式，线程安全"></a>3、饿汉式，线程安全</h2><p>他很饿，饿就很勤奋呀，还没用到他呢，就实例化（静态）了。占用内存啊。</p><p>描述：这种方式比较常用，但<strong>容易产生垃圾对象</strong>。<br>优点：利用static唯一性实现线程安全，<strong>没有加锁</strong>，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton(); <span class="comment">//其他的静态方法被调用会导致实例化 （静态变量实例先于静态方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  <span class="comment">//暴露的静态构造方法</span></span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#4-双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="4.双检锁/双重校验锁（DCL，即 double-checked locking）"></a>4.双检锁/双重校验锁（DCL，即 double-checked locking）</h2><p>JDK 版本：JDK1.5 起<br>是否 Lazy 初始化：是<br>是否多线程安全：是</p><p>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton; <span class="comment">//保证可见性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  <span class="comment">//在创建时，先验证，解决了一上来就加锁的性能缺陷</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  <span class="comment">//避免加锁后已经被创建了，再检验</span></span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-登记式-静态内部类"><a href="#5-登记式-静态内部类" class="headerlink" title="5.登记式/静态内部类"></a>5.登记式/静态内部类</h2><p>是否 Lazy 初始化：是<br>是否多线程安全：是</p><p>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用<strong>延迟初始化</strong>，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在<strong>实例域需要延迟初始化</strong>时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式<strong>只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果）</strong>，而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。<br>想象一下，如果<strong>实例化 instance 很消耗资源，所以想让它延迟加载</strong>，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//静态内部类的构造，要后于静态方法，所以其他静态方法被调用的时候，不会触发实例化 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>#6.枚举 饿汉 enum 特性</p><p>是否 Lazy 初始化：否<br>是否多线程安全：是</p><p>描述：这种实现方式还没有被广泛采用，<br>特点：最佳方法。简洁，自动<strong>支持序列化机制</strong>，绝对防止多次实例化。<br>不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用<strong>第 3 种饿汉方式</strong>。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到<strong>反序列化</strong>创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>]]></content>
      
      <categories>
          
          <category> 原理理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式沉思录（一）之工厂模式</title>
      <link href="/2018/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式沉思录（一）之工厂模式"><a href="#设计模式沉思录（一）之工厂模式" class="headerlink" title="设计模式沉思录（一）之工厂模式"></a>设计模式沉思录（一）之工厂模式</h1><p>本文整理自四人帮著作：<strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong></p><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p>1、开闭原则（Open Close Principle）</p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔（即便是带电也能部署）的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，<strong>关键部分是需要使用接口和抽象类</strong>。</p><p>2、里氏代换原则（我称之为父子原则）（Liskov Substitution Principle）</p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，<strong>任何基类可以出现的地方，子类一定可以出现</strong>。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而<strong>基类与子类的继承关系</strong>就是<strong>抽象化的具体实现</strong>，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p>3、依赖倒转原则（Dependence Inversion Principle）</p><p>这个原则是开闭原则的基础，具体内容：<strong>针对接口编程，依赖于抽象而不依赖于具体</strong>。</p><p>4、接口隔离原则（Interface Segregation Principle）</p><p>这个原则的意思是：<strong>使用多个隔离的接口（抽象出更多更具体的接口配合，而不是一个啥都能干的接口）</strong>，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p>5、迪米特法则，又称<strong>最少知道</strong>原则（Demeter Principle）</p><p>最少知道原则是指：一个实体应当<strong>尽量少地与其他实体之间发生相互作用</strong>，使得系统功能模块相对独立。</p><p>6、合成复用原则（Composite Reuse Principle）</p><p>合成复用原则是指：尽量<strong>使用合成/聚合</strong>的方式，而不是使用继承。</p><h1 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h1><p>23 种设计模式分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。</p><h2 id="创建型模式（Creational-Patterns）"><a href="#创建型模式（Creational-Patterns）" class="headerlink" title="创建型模式（Creational Patterns）"></a>创建型模式（Creational Patterns）</h2><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个<strong>共同的接口</strong>来指向新创建的对象。</p><p>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>主要解决：主要解决<strong>接口选择</strong>的问题。<br>何时使用：我们明确地计划不同条件下创建不同实例时。<br>如何解决：让<strong>其子类实现工厂接口</strong>，返回的也是一个抽象的产品。<br>关键代码：创建过程在<strong>其子类执行</strong>。<br>应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p><p><strong>优点：</strong><br>1、一个调用者想创建一个对象，只要知道其名称就可以了。并且不用设置属性。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p><strong>缺点：</strong>每次增加一个产品时，都需要<strong>增加一个具体类和对象实现工厂</strong>，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p><strong>使用场景：</strong><br>1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到<strong>什么地方</strong>。<br>2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p><p><strong>注意事项：</strong><br>不要滥用工厂模式：在任何需要生成<strong>复杂对象</strong>的地方，都可以使用工厂方法模式。而简单对象，特别是只需要通过 new 就可以完成创建的对象，因为如果使用工厂模式，就需要<strong>引入一个工厂类，会增加系统的复杂度。</strong></p><p><strong>实现：</strong><br>我们将创建一个 Shape 接口和实现 Shape 接口的实体类。下一步是定义工厂类 ShapeFactory。<br><img src="http://www.runoob.com/wp-content/uploads/2014/08/factory_pattern_uml_diagram.jpg" alt="此处输入图片的描述"></p><p>FactoryPatternDemo，我们的演示类使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。</p><p>1.产品接口（Shape形状）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.实现产品接口的实体类,这里只列出Rectangle，Square和Circle同理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.工厂类，根据信息来生产不同的产品<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//使用 getShape 方法,利用反射机制，通过类对象获取形状类型的对象</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T extends Shape&gt; <span class="function">T <span class="title">getShape</span><span class="params">(Class&lt;T&gt; shapeType)</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> shapeType.newInstance();<span class="comment">//利用反射返回一个对应的shape实例</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.使用该工厂类，通过传递类型信息来获取实体类的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      shapeFactory.getShape(<span class="string">"CIRCLE"</span>).draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>).draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>).draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结：<br>通过使用工厂类，产品类被屏蔽，高层模块中只知道产品类的接口，而不需要对产品有过多的了解。这符合我们面向抽象编程的原则。符合迪米特法则（少知道）。也符合里氏替换（父子）原则。</p><p>工厂方法模式在实际中应用十分广泛，举个简单的例子。我们在用jdbc进行数据库连接的时候，我们获取连接的时候用的getConnection方法直接获取，而不用了解具体的获取过程。当数据库从oracle变成mysql的时候。我们写的数据库的操作语句根本不用变化。因为底层的数据库连接获取被jdbc屏蔽了。这就是一个工厂方法模式的典型应用。</p><p>工厂方法模式有很多扩展，也可以和其他的很多模式进行结合使用。比如在上面的这个例子中。由于只有一个工厂，我们没必要将其实例化，也没必要在增加一个工厂接口。像这样的简单的情况。我们可以直接将<strong>工厂接口删除掉</strong>，然后把工厂中创建类的方法声明为静态方法。直接通过静态方法进行创建对象调用就可以，这种对一般工厂方法模式的缩小，我们称之为简单工厂模式。</p><p>这种模式的应用也十分广泛。在某个项目比较复杂时候，如果实例化一个产品很复杂，如果将所有的实例化过程都写到同一个工厂中，那么该工厂的实例化部分将会显得十分臃肿。这样的情况下。我们可以声明<strong>多个工厂类，实现工厂接口</strong>，每个工厂类对应着不同的产品的实例化。另外，工厂方法模式也可以直接代替单例模式进行使用，我们会在单例模式中具体的进行阐述。</p>]]></content>
      
      <categories>
          
          <category> 原理理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式沉思录</title>
      <link href="/2018/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95/"/>
      <url>/2018/07/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>非递归和递归实现链表翻转</title>
      <link href="/2018/07/11/%E9%9D%9E%E9%80%92%E5%BD%92%E5%92%8C%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC/"/>
      <url>/2018/07/11/%E9%9D%9E%E9%80%92%E5%BD%92%E5%92%8C%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-5 最长回文子串</title>
      <link href="/2018/07/11/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2018/07/11/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-5-最长回文子串"><a href="#LeetCode-5-最长回文子串" class="headerlink" title="LeetCode-5 最长回文子串"></a>LeetCode-5 最长回文子串</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p><p><strong>示例 1：</strong></p><blockquote><p>输入: “babad” &gt; 输出: “bab” &gt; 注意: “aba”也是一个有效答案。</p></blockquote><p>示例 2：</p><blockquote><p>输入: “cbbd”</p><p>输出: “bb”</p></blockquote><h1 id="解法一：暴力破解"><a href="#解法一：暴力破解" class="headerlink" title="解法一：暴力破解"></a>解法一：暴力破解</h1><p>遍历每一个子串的方法要O（n^2），判断每一个子串是不是回文的时间复杂度是O(n)</p><p>时间复杂度： O（n^3)</p><h1 id="解法二：带剪枝的，中心扩展"><a href="#解法二：带剪枝的，中心扩展" class="headerlink" title="解法二：带剪枝的，中心扩展"></a>解法二：带剪枝的，中心扩展</h1><p>中心扩展就是把给定的字符串的每一个字母当做中心，向两边扩展，这样来找最长的子回文串。算法复杂度为O(N^2)。<br>但是要考虑两种情况：</p><ol><li>像aba，这样长度为奇数。</li><li>想abba，这样长度为偶数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> low;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxLen;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String sub;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 剪枝的中心扩散法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length()-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        findLongestSub(s, i, i);</span><br><span class="line">        findLongestSub(s, i, i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sub = s.substring(low, low+maxLen);</span><br><span class="line">    <span class="keyword">return</span> sub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findLongestSub</span><span class="params">(String s, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;=<span class="number">0</span> &amp;&amp; k &lt;= s.length()-<span class="number">1</span> &amp;&amp; s.charAt(j)==s.charAt(k))&#123;</span><br><span class="line">        j--;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxLen &lt; k-j-<span class="number">1</span>)&#123;</span><br><span class="line">        low = j+<span class="number">1</span>;</span><br><span class="line">        maxLen = k-j-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((s.length()- <span class="number">1</span> - k) &lt; (maxLen / <span class="number">2</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//最后部分可以剪枝</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Manacher’s-ALGORITHM-马拉车算法"><a href="#Manacher’s-ALGORITHM-马拉车算法" class="headerlink" title="Manacher’s ALGORITHM:马拉车算法"></a>Manacher’s ALGORITHM:马拉车算法</h1><p>O(n)时间求字符串的最长回文子串</p><p>记忆细节：</p><ol><li>插入#，奇偶数组都能解决, p[]数组存每个位置最长回文长度</li><li>id表示最长回文中心点，max表示最长回文半径，用于监控</li><li>i from 0 to n，i若处在max中，p[i]取min(p[2*id - i], max-i)</li><li>再看看p[i]能否左右扩张</li><li>更新最长回文串，更新ip和max，保存p[]中对应maxC，maxP</li></ol><p><a href="https://www.felix021.com/blog/read.php?2040" target="_blank" rel="noopener">详细介绍</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 骚气的马拉车算法求解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">longestPalindrome2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先给新数组插入#</span></span><br><span class="line">    String t = <span class="string">"#"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        t += s.charAt(i) + <span class="string">"#"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[t.length()];  <span class="comment">//定义数组p[]，代表对应数组上i位置的回文半径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max = id + p[id];<span class="comment">//定义id，为最长回文中心。定义max，为最长回文右端。</span></span><br><span class="line">    <span class="keyword">int</span> maxC = <span class="number">0</span>; <span class="keyword">int</span> maxP = <span class="number">0</span>;<span class="comment">//定义maxC，maxP，为数组p中最大值和对应的中心位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环，分别求得p[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">        <span class="comment">//判断：i是否在max的范围内</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; max)&#123;</span><br><span class="line">            p[i] = Math.min(p[<span class="number">2</span>*id - i], max-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( i-p[i] &gt;= <span class="number">0</span> &amp;&amp; i+p[i] &lt; t.length() &amp;&amp; t.charAt(i - p[i]) == t.charAt(i + p[i]))&#123;</span><br><span class="line">            p[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最长回文串，更新ip和max</span></span><br><span class="line">        <span class="keyword">if</span> (i + p[i] &gt; max)&#123;</span><br><span class="line">            id = i;<span class="comment">//中心转移</span></span><br><span class="line">            max = id + p[id]; <span class="comment">//最右影响位置转移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保存数组p中位置</span></span><br><span class="line">        <span class="keyword">if</span> (p[i] &gt; maxP)&#123;</span><br><span class="line">            maxP = p[i];</span><br><span class="line">            maxC = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还原数组,在中心为是不是#</span></span><br><span class="line">    <span class="keyword">if</span> (t.charAt(maxC) == <span class="string">'#'</span>) &#123; <span class="comment">// 还原长度为偶数的回文串</span></span><br><span class="line">        <span class="keyword">return</span> s.substring((maxC - <span class="number">2</span>) / <span class="number">2</span> - (maxP - <span class="number">2</span>) / <span class="number">2</span>, (maxC - <span class="number">2</span>) / <span class="number">2</span> + <span class="number">1</span> + (maxP - <span class="number">2</span>) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                     <span class="comment">// 还原长度为奇数的回文串</span></span><br><span class="line">        <span class="keyword">return</span> s.substring((maxC - <span class="number">1</span>) / <span class="number">2</span> - (maxP - <span class="number">1</span>) / <span class="number">2</span>, (maxC - <span class="number">1</span>) / <span class="number">2</span> + (maxP - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.jianshu.com/p/7c3f074b380b" target="_blank" rel="noopener">https://www.jianshu.com/p/7c3f074b380b</a></p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MD5信息摘要算法原理及破解原理</title>
      <link href="/2018/07/09/MD5%E4%BF%A1%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/07/09/MD5%E4%BF%A1%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>虽然目前MD5已经宣布可破解了，但是其算法思想还是可以学习的。</p><h1 id="MD5应用"><a href="#MD5应用" class="headerlink" title="MD5应用"></a>MD5应用</h1><p>1.一致性验证<br>典型应用是对一段信息（Message）产生信息摘要（Message-Digest），以防止被篡改。比如，在Unix下有很多软件在下载的时候都有一个文件名相同，文件扩展名为.md5的文件，在这个文件中通常只有一行文本，大致结构如：</p><blockquote><p>MD5 (tanajiya.tar.gz) = 38b8c2c1093dd0fec383a9d9ac940515</p></blockquote><p>作用：在我们可以在下载该软件后，对下载回来的文件用专门的软件（如Windows MD5 Check等）做一次MD5校验，以确保我们获得的文件与该站点提供的文件为同一文件。</p><p>2.数字签名</p><p>MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹），以防止被“篡改”。举个例子，你将一段话写在一个叫readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现（两个MD5值不相同）。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。</p><p>3.安全访问认证</p><p>MD5还广泛用于操作系统的登陆认证上，如在Unix系统中用户的密码是以MD5（或其它类似的算法）经Hash运算后存储在文件系统中。</p><p>当用户登录的时候，系统把用户输入的密码进行MD5Hash运算，然后再去和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。<br>通过这样的步骤，系统在并不知道用户密码的明码的情况下就可以确定用户登录系统的合法性。这可以避免用户的密码被具有系统管理员权限的用户知道。</p><p>MD5将任意长度的“字节串”映射为一个128bit的大整数，并且是通过该128bit反推原始字符串是困难的，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。所以，要遇到了md5密码的问题，比较好的办法是：你可以用这个系统中的md5（）函数重新设一个密码，如admin，把生成的一串密码的Hash值覆盖原来的Hash值就行了。<br>（不去用MD5反运算明文密码，而是用大量的字符串去生成MD5密码并比对）</p><p>正是因为这个原因，现在被黑客使用最多的一种破译密码的方法就是一种被称为”跑字典”的方法。有两种方法得到字典，一种是日常搜集的用做密码的字符串表，另一种是用排列组合方法生成的，先用MD5程序计算出这些字典项的MD5值，然后再用目标的MD5值在这个字典中检索。我们假设密码的最大长度为8位字节（8 Bytes），同时密码只能是字母和数字，共26+26+10=62个字节，排列组合出的字典的项数则是P（62,1）+P（62,2）….+P（62,8），那也已经是一个很天文的数字了，存储这个字典就需要TB级的磁盘阵列，而且这种方法还有一个前提，就是能获得目标账户的密码MD5值的情况下才可以。这种加密技术被广泛的应用于Unix系统中，这也是为什么Unix系统比一般操作系统更为坚固一个重要原因。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这<strong>四个32位分组级联</strong>后将生成一个128位散列值。</p><h2 id="1-填充"><a href="#1-填充" class="headerlink" title="1.填充"></a>1.填充</h2><p>在MD5算法中，首先需要对信息进行填充，并且填充必须进行，即使其位长对512求余的结果等于448（因为后面还有个64位表示长度，合起来就是512）。<br>因此，信息的位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零。</p><p>填充的方法如下：</p><ol><li>在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。</li><li>在这个结果后面附加一个以64位二进制表示的   <strong>填充前信息长度</strong>（单位为Bit），如果二进制表示的填充前信息长度超过64位，则取低64位。</li></ol><p>经过这两步的处理，信息的位长=N<em>512+448+64=(N+1）</em>512，即长度恰好是<strong>512的整数倍</strong>。这样做的原因是为满足后面处理中对信息长度的要求。</p><h2 id="2-初始化变量"><a href="#2-初始化变量" class="headerlink" title="2. 初始化变量"></a>2. 初始化变量</h2><p>初始的128位值为<strong>初始链接变量</strong>，这些参数用于第一轮的运算，以大端字节序来表示，他们分别为： A=0x01234567，B=0x89ABCDEF，C=0xFEDCBA98，D=0x76543210。</p><p>（每一个变量给出的数值是<strong>高字节存于内存低地址</strong>，<strong>低字节存于内存高地址</strong>，即<strong>大端字节序</strong>。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476）</p><ol start="3"><li>处理分组数据</li></ol><p>准备需要用到的数据：</p><blockquote><p>4个常数： A = 0x67452301, B = 0x0EFCDAB89, C = 0x98BADCFE, D = 0x10325476;</p><p>4个函数：F(X,Y,Z)=(X &amp; Y) | ((~X) &amp; Z); G(X,Y,Z)=(X &amp; Z) | (Y &amp; (~Z));<br>H(X,Y,Z)=X ^ Y ^ Z; I(X,Y,Z)=Y ^ (X | (~Z));</p></blockquote><p>把消息分以512位为一分组进行处理，每一个分组进行4轮变换，以上面所说4个常数为起始变量进行计算，重新输出4个变量，以这4个变量再进行下一分组的运算，如果已经是最后一个分组，则这4个变量为最后的结果，即MD5值。</p><p>每一分组的算法流程如下：</p><p>第一分组需要将<strong>上面四个链接变量</strong>复制到<strong>另外四个变量</strong>中：A到a，B到b，C到c，D到d。从第二分组开始的变量为上一分组的运算结果，即A = a， B = b， C = c， D = d。</p><p>主循环有四轮（MD4只有三轮），每轮循环都很相似。第一轮进行16次操作。每次操作对a、b、c和d中的<strong>其中三个作一次非线性函数运算</strong>，然后将所得结果<strong>加上第四个变量</strong>，文本的一个子分组和一个常数。再将所得结果向左环移一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。</p><p>以下是每次操作中用到的四个非线性函数（每轮一个）。</p><p>F( X ,Y ,Z ) = ( X &amp; Y ) | ( (~X) &amp; Z )</p><p>G( X ,Y ,Z ) = ( X &amp; Z ) | ( Y &amp; (~Z) )</p><p>H( X ,Y ,Z ) =X ^ Y ^ Z</p><p>I( X ,Y ,Z ) =Y ^ ( X | (~Z) )</p><p>（&amp;是与（And），|是或（Or），~是非（Not），^是异或（Xor））</p><p>这四个函数的说明：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。</p><p>F是一个逐位运算的函数。即，如果X，那么Y，否则Z。函数H是逐位奇偶操作符。</p><p>假设Mj表示消息的第j个子分组（从0到15），常数ti是4294967296*abs( sin(i) ）的整数部分，i 取值从1到64，单位是弧度。（4294967296=232）</p><p>现定义：</p><p>FF(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + F(b,c,d) + Mj + ti) &lt;&lt; s)</p><p>GG(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + G(b,c,d) + Mj + ti) &lt;&lt; s)</p><p>HH(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + H(b,c,d) + Mj + ti) &lt;&lt; s)</p><p>II(a ,b ,c ,d ,Mj ,s ,ti) 操作为 a = b + ( (a + I(b,c,d) + Mj + ti) &lt;&lt; s)</p><p>注意：“&lt;&lt;”表示循环左移位，不是左移位。</p><h1 id="彩虹表"><a href="#彩虹表" class="headerlink" title="彩虹表"></a>彩虹表</h1><p>如果将哈希后的密文比作一把锁，暴力破解的方法就是现场制作各种各样不同齿形的钥匙，再来尝试能否开锁，这样耗时无疑很长；我以前错误理解的“彩虹表”是事先制作好所有齿形的钥匙，全部拿过来尝试开锁，这样虽然省去了制作钥匙的时间，但是后来发现这些钥匙实在是太多了，没法全部带在身上。而真正的彩虹表，是将<strong>钥匙按照某种规律进行分组</strong>，每组钥匙中只需要带<strong>最有特点的一个</strong>，当发现某个“特征钥匙” <strong>差一点就能开锁</strong>了，则当场对该钥匙进行简单的<strong>打磨</strong>，直到能开锁为止。这种方法是既省力又省时的.</p><h1 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h1><p>哈希碰撞就是一种优化过算法,其基本原理就是把密码明文对应的MD5与你的MD5进行对比,因为经过一些优化,所以无论是时间上,还是空间都很很快，感兴趣的可以查一下王小云教授关于哈希碰撞的论文.</p><h1 id="常用破解MD5方法"><a href="#常用破解MD5方法" class="headerlink" title="常用破解MD5方法"></a>常用破解MD5方法</h1><p>目前来说,破解MD5加密的最有效的方法就是 <strong>哈希碰撞+彩虹表+对应秘钥</strong>,一些网络黑客会在一些明文存储用户密码的网站上窃取信息,假如黑客有一亿条数据,因为都是真实用户所以经过哈希碰撞之后,你的密码被破译出来的几率就真的非常大了,那破译不出来的可能就是因为大小写和一些特殊符号,这就用到了彩虹表,最后就是你的秘钥,比如你是之前对用户的密码进行加盐,还是之后对MD5之后的字符串进行的特殊处理,只要对方知道你的秘钥,那么你密码被破译出来的几率就非常非常高了,所以我们说: 一个密码系统的安全性只在于密钥的保密性，而不在于算法的保密性.</p><p>总结<br>MD5本身是不可逆和无冲突的,但是用一些巧妙地方法会被破解出来.一个密码系统的是没有绝对安全的,密码系统只是增加了被破解的代价.</p><p>参考链接：<a href="https://www.jianshu.com/p/2e75c64dbc4f" target="_blank" rel="noopener">https://www.jianshu.com/p/2e75c64dbc4f</a></p>]]></content>
      
      <categories>
          
          <category> 技术博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MD5 </tag>
            
            <tag> 加密算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>APM工具-分布式跟踪监控工具pinpoint搭建与使用</title>
      <link href="/2018/07/09/APM%E5%B7%A5%E5%85%B7-%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7pinpoint%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/09/APM%E5%B7%A5%E5%85%B7-%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7pinpoint%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>在公司实习期间，主管让我了解一下pinpoint的搭建和使用细则。然后我就根据这个关键词开始了我的面向谷歌编程。</p><h1 id="配置与搭建"><a href="#配置与搭建" class="headerlink" title="配置与搭建"></a>配置与搭建</h1><p><a href="https://www.cnblogs.com/yyhh/p/6106472.html#yy01" target="_blank" rel="noopener">https://www.cnblogs.com/yyhh/p/6106472.html#yy01</a><br><a href="https://blog.csdn.net/qq_21816375/article/details/80455681" target="_blank" rel="noopener">https://blog.csdn.net/qq_21816375/article/details/80455681</a></p><p>看了很多博客，各自有各自的坑，我在这里做了一个精华总结版本。</p><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ol><li>jdk1.8 — Java运行环境</li><li>hbase-1.0 — 数据库，用来存储监控信息</li><li>tomcat8.0 — Web服务器</li><li>pinpoint-collector.war — pp的控制器</li><li>pinpoint-web.war — pp展示页面</li></ol><p><a href="https://github.com/naver/pinpoint/releases/tag/1.7.3" target="_blank" rel="noopener">pp-collector和pp-web资源下载</a></p><h2 id="hbase的安装"><a href="#hbase的安装" class="headerlink" title="hbase的安装"></a>hbase的安装</h2><p>1.首先安装hbase，根据系统版本选择合适的hbase（我使用的是hbase-1.2.4）</p><blockquote><p>wget <a href="http://archive.apache.org/dist/hbase/1.2.6/hbase-1.2.6-bin.tar.gz" target="_blank" rel="noopener">http://archive.apache.org/dist/hbase/1.2.6/hbase-1.2.6-bin.tar.gz</a><br>速度较慢，建议下载后上传到服务器</p></blockquote><p>1.解压</p><blockquote><p>tar -zxvf hbase-1.2.6-bin.tar.gz</p></blockquote><p>2.启动并初始化hbase<br>编辑hbase-1.2.4/conf/hbase-env.sh,添加JAVA_HOME配置：</p><blockquote><p>export JAVA_HOME=/root/jdk1.8.0_144</p></blockquote><p>3.编辑hbase-site.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:///Users/tangliu/Tmp/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/Users/tangliu/Tmp/zookeeper<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分别表示数据和zookeeper数据存放地点。这样配置是本地单实例模式启动，具体和集群配置可以参考hbase官网。</p><ol start="4"><li>./hbase-1.2.4/bin/start-hbase.sh启动</li><li>./hbase-1.2.4/bin/hbase shell hbase-create.hbase这是初始化pinpoint需要的表,在git上的位置上可以下载到</li><li>验证页面：<a href="http://localhost:16010/master-status" target="_blank" rel="noopener">http://localhost:16010/master-status</a></li></ol><h2 id="坑1：这里正常后，页面应该会有显示table"><a href="#坑1：这里正常后，页面应该会有显示table" class="headerlink" title="坑1：这里正常后，页面应该会有显示table"></a>坑1：这里正常后，页面应该会有显示table</h2><p><img src="http://paxblmm0h.bkt.clouddn.com/pp-1.png" alt="此处输入图片的描述"><br>确保有显示表，没有的话不用往下做了。先解决这个bug，一般是hbase表的问题，可能是hbase和zookeeper的不一致，需要将hbase和zk里的表都删除，然后再重新导入一次表。</p><h2 id="安装pinpoint-collector"><a href="#安装pinpoint-collector" class="headerlink" title="安装pinpoint-collector"></a>安装pinpoint-collector</h2><p>其实就是，将collector的war包放到一个tomcat容器中的ROOT位置。将tomcat重命名为pp-col，然后再配置一下pp-col的端口。（我选择了tomcat端口全部加1，如18080）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /data/service/pp-col/conf/</span><br><span class="line">sed -i &apos;s/port=&quot;8005&quot;/port=&quot;18005&quot;/g&apos; server.xml</span><br><span class="line">sed -i &apos;s/port=&quot;8080&quot;/port=&quot;18080&quot;/g&apos; server.xml</span><br><span class="line">sed -i &apos;s/port=&quot;8443&quot;/port=&quot;18443&quot;/g&apos; server.xml</span><br><span class="line">sed -i &apos;s/port=&quot;8009&quot;/port=&quot;18009&quot;/g&apos; server.xml</span><br><span class="line">sed -i &apos;s/redirectPort=&quot;8443&quot;/redirectPort=&quot;18443&quot;/g&apos; server.xml</span><br><span class="line">sed -i &quot;s/localhost/`ifconfig eth0 | grep &apos;inet addr&apos; | awk &apos;&#123;print $2&#125;&apos; | awk -F: &apos;&#123;print $2&#125;&apos;`/g&quot; server.xml</span><br></pre></td></tr></table></figure><p>部署pinpoint-collector.war包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/pp_res/</span><br><span class="line">rm -rf /data/service/pp-col/webapps/*</span><br><span class="line">tar -zxvf pinpoint-collector-1.5.2.war -d /data/service/pp-col/webapps/ROOT</span><br></pre></td></tr></table></figure><p>启动tomcat，看一下日志是否启动成功<br><code>tail -f ../logs/catalina.out</code></p><h2 id="安装pinpoint-web（用于展示）"><a href="#安装pinpoint-web（用于展示）" class="headerlink" title="安装pinpoint-web（用于展示）"></a>安装pinpoint-web（用于展示）</h2><p>原理和col全部相同，不同的地方只有放在ROOT位置的包不同，以及配置的端口不同（我选择了tomcat端口全部加2，如28080）</p><h1 id="conf中的一些配置参数"><a href="#conf中的一些配置参数" class="headerlink" title="conf中的一些配置参数"></a>conf中的一些配置参数</h1><ul><li>hbase.properties 配置我们pp-web从哪个数据源获取采集数据，这里我们只指定Hbase的zookeeper地址。</li><li>jdbc.properties pp-web连接自身Mysql数据库的连接认证配置。 </li><li>sql目录 pp-web本身有些数据需要存放在MySQL数据库中，这里需要初始化一下表结构。</li><li>pinpoint-web.properties 这里pp-web集群的配置文件，如果你需要pp-web集群的话。</li><li>applicationContext-* .xml 这些文件在后续的调优工作中会用到。</li><li><p>log4j.xml 日志相关配置。</p><p>同样的，配置好后启动并查看是否启动。<br>这时候我们可以访问一下这个地址，在浏览器中输入”<a href="http://localhost:28080&quot;，就会出现主页面了。如果访问不了的话，看一下端口是否开放，或者关闭防火墙。" target="_blank" rel="noopener">http://localhost:28080&quot;，就会出现主页面了。如果访问不了的话，看一下端口是否开放，或者关闭防火墙。</a></p></li></ul><h2 id="部署pp-agent采集监控数据"><a href="#部署pp-agent采集监控数据" class="headerlink" title="部署pp-agent采集监控数据"></a>部署pp-agent采集监控数据</h2><p>相关说明请参考<a href="http://naver.github.io/pinpoint/installation.html#installation-2" target="_blank" rel="noopener">Pinpoint Agent</a></p><p>将包解压在service目录下，命名为pp-agent，此处是不需要容器的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /data/service</span><br><span class="line">cp /root/demo/pinpoint/agent/target/pinpoint-agent-1.7.3.tar.gz .</span><br><span class="line">mkidr pp-agent</span><br><span class="line">cd pp-agent</span><br><span class="line">tar -zvxf pinpoint-agent-1.7.3.tar.gz</span><br><span class="line"></span><br><span class="line">vi pinpoint.config</span><br><span class="line">profiler.collector.ip= your ip</span><br></pre></td></tr></table></figure></p><h2 id="部署pp-test作为测试用例"><a href="#部署pp-test作为测试用例" class="headerlink" title="部署pp-test作为测试用例"></a>部署pp-test作为测试用例</h2><p>这个需要用户在服务启动时添加上这个三行就可以了，安插探针<br>修改tomcat的catalina.sh文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CATALINA_OPTS=&quot;$CATALINA_OPTS -javaagent:/data/service/pp-agent/pinpoint-bootstrap-1.7.3.jar&quot;</span><br><span class="line">CATALINA_OPTS=&quot;$CATALINA_OPTS -Dpinpoint.agentId=qinzhao-ID&quot;</span><br><span class="line">CATALINA_OPTS=&quot;$CATALINA_OPTS -Dpinpoint.applicationName=qinzhao&quot;</span><br></pre></td></tr></table></figure></p><p>监控Tomcat ,启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./startup.sh</span><br><span class="line">tail -f ../logs/catalina.out</span><br></pre></td></tr></table></figure></p><p>然后能看到tomcat启动页面。</p><p>最后访问 ip:28080 ,可以看到pinpoint的web界面了。</p><p>选择监控应用，并开始监控。<br><img src="http://paxblmm0h.bkt.clouddn.com/pp-2.png" alt="此处输入图片的描述"></p><h2 id="坑2-没法选择应用"><a href="#坑2-没法选择应用" class="headerlink" title="坑2 没法选择应用"></a>坑2 没法选择应用</h2><p>如果没法选择应用的话，多半是数据库hbase出问题了，去确认一下表是否齐全。此外pp-agent的部署是否正确。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>APM工具-分布式跟踪监控工具pinpoint的使用</title>
      <link href="/2018/07/09/APM%E5%B7%A5%E5%85%B7-%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7pinpoint%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/07/09/APM%E5%B7%A5%E5%85%B7-%E5%88%86%E5%B8%83%E5%BC%8F%E8%B7%9F%E8%B8%AA%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7pinpoint%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>#APM工具-分布式跟踪监控工具pinpoint的使用</p><h1 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h1><p>前提是pinpoint-collector和pinpoint-web已经部署在服务器上，具体部署可参考。<br><a href="https://www.cnblogs.com/yyhh/p/6106472.html#yy05" target="_blank" rel="noopener">参考1</a> <a href="https://blog.csdn.net/qq_21816375/article/details/80455681" target="_blank" rel="noopener">参考2</a></p><p>所监控的客户端（pp-test）只需要配置两个位置。</p><h1 id="部署pp-agent采集监控数据"><a href="#部署pp-agent采集监控数据" class="headerlink" title="部署pp-agent采集监控数据"></a>部署pp-agent采集监控数据</h1><p><a href="https://github.com/naver/pinpoint/releases" target="_blank" rel="noopener">下载地址</a>，只需要下载pp-agent</p><p>下载较慢的话可以从我的源这<a href="http://paxblmm0h.bkt.clouddn.com/pinpoint-1.7.7z" target="_blank" rel="noopener">下载</a></p><p>相关参数说明请参考<a href="http://naver.github.io/pinpoint/installation.html#installation-2" target="_blank" rel="noopener">Pinpoint Agent</a></p><p>将包解压在service目录下（位置随意，方便查找即可），命名为pp-agent，此处是不需要容器的。作为监控应用的采集器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /data/service</span><br><span class="line">cp /root/demo/pinpoint/agent/target/pinpoint-agent-1.7.3.tar.gz .</span><br><span class="line">mkidr pp-agent</span><br><span class="line">cd pp-agent</span><br><span class="line">tar -zvxf pinpoint-agent-1.7.3.tar.gz</span><br></pre></td></tr></table></figure></p><p>改采集ip为采集应用的服务器的ip（安装了pp-col的服务器ip）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi pinpoint.config</span><br><span class="line">profiler.collector.ip= 安装了pp-col服务器的ip</span><br></pre></td></tr></table></figure></p><p>主要修改IP，只需要指定到安装pp-col的IP就行了，安装pp-col启动后，自动就开启了9994，9995，9996的端口了。这里就不需要操心了，如果有端口需求，要去pp-col的配置文件(“pp-col/webapps/ROOT/WEB-INF/classes/pinpoint-collector.properties”)中，修改这些端口</p><h1 id="部署pp-test作为测试用例（所监控的应用）"><a href="#部署pp-test作为测试用例（所监控的应用）" class="headerlink" title="部署pp-test作为测试用例（所监控的应用）"></a>部署pp-test作为测试用例（所监控的应用）</h1><p>这个需要用户在服务启动时添加上这个三行就可以了，安插探针</p><p>修改tomcat的catalina.sh文件<br>在20行左右增加如下字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CATALINA_OPTS=&quot;$CATALINA_OPTS -javaagent:/data/service/pp-agent/pinpoint-bootstrap-1.7.3.jar&quot;</span><br><span class="line">CATALINA_OPTS=&quot;$CATALINA_OPTS -Dpinpoint.agentId=ID&quot;</span><br><span class="line">CATALINA_OPTS=&quot;$CATALINA_OPTS -Dpinpoint.applicationName=appName&quot;</span><br></pre></td></tr></table></figure><p>第一行是pp-agent的jar包位置（关键）<br>第二行是agent的ID，这个ID是唯一的，我是用pp + 今天的日期命名的，只要与其他的项目的ID不重复就好了<br>第三行是采集项目的名字，这个名字可以随便取，只要各个项目不重复就好了</p><p>启动所需要监控的应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./startup.sh</span><br></pre></td></tr></table></figure></p><p>查看日志，确实启动了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f ../logs/catalina.out</span><br></pre></td></tr></table></figure></p><p>访问8080端口，然后能看到tomcat启动页面。</p><h2 id="使用参考"><a href="#使用参考" class="headerlink" title="使用参考"></a>使用参考</h2><p>访问部署pp- ip:28080 ,可以看到pinpoint的web界面了。</p><p>左上角选择所监控的应用。右上选择监控时间段与更新间隔。</p><p>选择监控应用，并开始监控。<br><img src="http://paxblmm0h.bkt.clouddn.com/pp-2.png" alt="此处输入图片的描述"></p><p>鼠标可以在右上角拉框选取。会弹出各访问信息。<br><img src="http://paxblmm0h.bkt.clouddn.com/pp-3.png" alt="此处输入图片的描述"></p><p>点击右上Inspector可进入应用详细监控界面。<br>能够查看内存，cpu，线程，反应时间等</p><p><a href="https://blog.csdn.net/kangguang/article/details/77290209" target="_blank" rel="noopener">参考使用教程博客</a></p><p>警报功能：<br><a href="https://blog.csdn.net/xvshu/article/details/79814549#t5" target="_blank" rel="noopener">APM监控–Pinpoint扩展报警</a></p>]]></content>
      
      <categories>
          
          <category> 技术博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具部署 </tag>
            
            <tag> apm监控 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL 优化</title>
      <link href="/2018/07/04/SQL%20%E4%BC%98%E5%8C%96%EF%BC%88%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%89%EF%BC%88%E8%BD%AC%EF%BC%89/"/>
      <url>/2018/07/04/SQL%20%E4%BC%98%E5%8C%96%EF%BC%88%E7%90%86%E8%AE%BA%E7%AF%87%EF%BC%89%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="SQL-优化（理论篇）（转）"><a href="#SQL-优化（理论篇）（转）" class="headerlink" title="SQL 优化（理论篇）（转）"></a>SQL 优化（理论篇）（转）</h1><p>原文点击<a href="%E5%8E%9F%E6%96%87%EF%BC%9Ahttps://mp.weixin.qq.com/s__biz=MzI4NTA1MDEwNg==&amp;mid=2650763421&amp;idx=1&amp;sn=2515421f09c150d31e8d1b8b59243bd5&amp;chksm=f3f9c508c48e4c1ea64b00b25c226efa2b9e32910f83290bf383ce0d16ee0991c42ad59527da&amp;mpshare=1&amp;scene=1&amp;srcid=0928OiKJlDAtIO4rBFdN6Lec#rd">这里</a>，本文基于此文优化补充</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说起MySQL的查询优化，相信大家收藏了一堆奇技淫巧：<br>不能使用SELECT *、不使用NULL字段、合理创建索引、为字段选择合适的数据类型…..<br>你是否真的理解这些优化技巧？是否理解其背后的工作原理？在实际场景下性能真有提升吗？我想未必。因而理解这些优化建议背后的原理就尤为重要，希望本文能让你重新审视这些优化建议，并在实际业务场景下合理的运用。</p><h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><p>如果能在头脑中构建一幅MySQL各组件之间如何协同工作的架构图，有助于深入理解MySQL服务器。下图展示了MySQL的逻辑架构图。<br><img src="http://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtt5WD7PStDP8xn9FCAqN0HhtLD3ju6wYXyrKKaNIOTOqS2CQmAYhZVBf3mxMDARtaicjjO6jRMDAg/0?wx_fmt=png" alt="此处输入图片的描述"><br>MySQL逻辑架构，来自：高性能MySQL</p><p>MySQL逻辑架构整体分为三层，最上层为<strong>客户端层</strong>，并非MySQL所独有，诸如：连接处理、授权认证、安全等功能均在这一层处理。</p><p>MySQL大多数<strong>核心服务均在中间</strong>这一层，包括查询解析、分析、优化、缓存、内置函数(比如：时间、数学、加密等函数)。所有的跨存储引擎的功能也在这一层实现：存储过程、触发器、视图等。</p><p>最下层为<strong>存储引擎</strong>，其负责MySQL中的数据存储和提取。和Linux下的文件系统类似，每种存储引擎都有其优势和劣势。中间的服务层通过API与存储引擎通信，这些API接口屏蔽了不同存储引擎间的差异。</p><h2 id="MySQL查询过程"><a href="#MySQL查询过程" class="headerlink" title="MySQL查询过程"></a>MySQL查询过程</h2><p>我们总是希望MySQL能够获得更高的查询性能，最好的办法是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，就会发现：很多的查询优化工作实际上就是遵循一些原则让MySQL的优化器能够按照预想的合理方式运行而已。</p><p>当向MySQL发送一个请求的时候，MySQL到底做了些什么呢？<br><img src="http://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtt5WD7PStDP8xn9FCAqN0Hc2PLZUxDUsebS6dLW6fKHyGVfosuX3XeLwClNP3GWNGvw0dicv8mficw/0?wx_fmt=png" alt="MySQL查询过程"></p><h3 id="客户端-服务端通信协议"><a href="#客户端-服务端通信协议" class="headerlink" title="客户端/服务端通信协议"></a>客户端/服务端通信协议</h3><p><strong>总结：</strong>保持查询简单且只返回必需的数据，（避免使用SELECT *以及加上LIMIT限制）<br><strong>原理：</strong>半双工的协议，发与收只能实现一个，无法拆分。避免长度过长。</p><p>MySQL客户端/服务端通信协议是<strong>“半双工”</strong>的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</p><p>客户端用一个单独的数据包将查询请求发送给服务器，所以当<strong>查询语句很长</strong>的时候，需要设置max_allowed_packet参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p><p>与之相反的是，服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用SELECT *以及加上LIMIT限制的原因之一。</p><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p><strong>原理：</strong>每次读都会查询缓存，不规范的语句会缓存不命中，写操作会更新对应表的缓存。</p><p><strong>总结：</strong><br>避免无效缓存（规范SQL语句书写（大小写，空格，注释），一点不同就会造成缓存不命中。</p><ol start="2"><li>用多个小表代替一个大表，注意不要过度设计</li><li>批量插入 代替 循环单条插入（避免不停查缓存）</li><li>合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适（写操作会使缓存失效，避免缓存过期时</li><li>写密集型不要打开缓存。</li></ol><p>可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存</p><p>在解析一个查询语句前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p><p>MySQL将缓存存放在一个引用表（不要理解成table，可以认为是类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</p><p>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果都不会被缓存。比如函数NOW()或者CURRENT_DATE()会因为不同的查询时间，返回不同的查询结果，再比如包含CURRENT_USER或者CONNECION_ID()的查询语句会因为不同的用户而返回不同的结果，将这样的查询结果缓存起来没有任何的意义。</p><p>既然是缓存，就会失效，那查询缓存何时失效呢？MySQL的查询缓存系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗，甚至导致系统僵死一会儿。而且查询缓存对系统的额外消耗也不仅仅在写操作，读操作也不例外：</p><p>任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存<br>如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗</p><p>基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。但要如何评估打开缓存是否能够带来性能提升是一件非常困难的事情，也不在本文讨论的范畴内。如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：</p><p>用多个小表代替一个大表，注意不要过度设计<br>批量插入代替循环单条插入<br>合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适<br>可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存</p><p>最后的忠告是不要轻易打开查询缓存，特别是写密集型应用。如果你实在是忍不住，可以将query_cache_type设置为DEMAND，这时只有加入SQL_CACHE的查询才会走缓存，其他查询则不会，这样可以非常自由地控制哪些查询需要被缓存。</p><p>当然查询缓存系统本身是非常复杂的，这里讨论的也只是很小的一部分，其他更深入的话题，比如：缓存是如何使用内存的？如何控制内存的碎片化？事务对查询缓存有何影响等等，读者可以自行阅读相关资料，这里权当抛砖引玉吧。</p><h3 id="语法解析和预处理"><a href="#语法解析和预处理" class="headerlink" title="语法解析和预处理"></a>语法解析和预处理</h3><p>MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等。</p><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>经过前面的步骤生成的语法树被认为是合法的了，并且由优化器将其转化成查询计划。多数情况下，一条查询可以有很多种执行方式，最后都返回相应的结果。<strong>优化器的作用就是找到这其中最好的执行计划</strong>。</p><p>MySQL使用基于成本的优化器，它尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。在MySQL可以通过查询当前会话的last_query_cost的值来得到其计算当前查询的成本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t_message limit 10;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//计算上一语句成本</span><br><span class="line">mysql&gt; show status like &apos;last_query_cost&apos;;</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Variable_name   | Value       |</span><br><span class="line">+-----------------+-------------+</span><br><span class="line">| Last_query_cost | 6391.799000 |</span><br><span class="line">+-----------------+-------------+</span><br></pre></td></tr></table></figure><p>示例中的结果表示优化器认为大概需要做6391个数据页的随机查找才能完成上面的查询。这个结果是根据一些列的统计信息计算得来的，这些统计信息包括：<strong>每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等。</strong></p><p>有非常多的原因会导致MySQL选择错误的执行计划，比如<strong>统计信息不准确</strong>、<strong>不会考虑不受其控制的操作成本</strong>（用户自定义函数、存储过程）、MySQL认为的最优跟我们想的不一样（我们希望执行时间尽可能短，但MySQL值选择它认为成本小的，但成本小并不意味着执行时间短）等等。</p><p>MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：</p><ul><li>重新定义表的<strong>关联顺序</strong>（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）</li><li><strong>优化MIN()和MAX()函数</strong>（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值，具体原理见下文）</li><li><strong>提前终止</strong>查询（比如：使用Limit时，查找到<strong>满足数量的结果</strong>集后会立即终止查询）</li><li>优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I/O密集型应用，效率会高很多）</li></ul><p>随着MySQL的不断发展，优化器使用的优化策略也在不断的进化，这里仅仅介绍几个非常常用且容易理解的优化策略，其他的优化策略，大家自行查阅吧。</p><h3 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h3><p>在完成解析 和 优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API。<br>查询过程中的每一张表由<strong>一个handler实例</strong>表示。实际上，MySQL在查询优化阶段就为每一张表创建了一个handler实例，优化器可以根据这些实例的接口来获取表的相关信息，包括表的所有列名、索引统计信息等。存储引擎接口提供了非常丰富的功能，但其底层仅有几十个接口，这些接口像搭积木一样完成了一次查询的大部分操作。</p><h3 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h3><p>查询执行的最后一个阶段就是将结果返回给客户端。即使查询不到数据，MySQL仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等。</p><p>如果查询缓存被打开且这个查询<strong>可以被缓存</strong>，MySQL也会将结果存放到缓存中。</p><p>结果集返回客户端是一个<strong>增量且逐步返回</strong>的过程。<br>有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。需要注意的是，结果集中的每一行都会以一个满足①中所描述的通信协议的数据包发送，再通过TCP协议进行传输，在传输过程中，可能对MySQL的数据包进行缓存然后批量发送。</p><h2 id="过程总结"><a href="#过程总结" class="headerlink" title="过程总结"></a>过程总结</h2><p>回头总结一下MySQL整个查询执行过程，总的来说分为：</p><ol><li>客户端向MySQL服务器发送一条查询请求</li><li>服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li><li>服务器进行SQL解析、预处理、再由优化器生成对应的执行计划</li><li>MySQL根据执行计划，调用存储引擎的API来执行查询</li><li>将结果返回给客户端，同时缓存查询结果</li></ol><h1 id="性能优化建议"><a href="#性能优化建议" class="headerlink" title="性能优化建议"></a>性能优化建议</h1><p>看了这么多，你可能会期待给出一些优化手段，是的，下面会从3个不同方面给出一些优化建议。但请等等，还有一句忠告要先送给你：不要听信你看到的关于优化的“绝对真理”，包括本文所讨论的内容，而应该是在实际的业务场景下通过测试来验证你关于执行计划以及响应时间的假设。</p><h2 id="1-Scheme设计与数据类型优化"><a href="#1-Scheme设计与数据类型优化" class="headerlink" title="1.Scheme设计与数据类型优化"></a>1.Scheme设计与数据类型优化</h2><p>选择数据类型只要遵循小而简单的原则就好，越小的数据类型通常会更快，占用更少的磁盘、内存，处理时需要的CPU周期也更少。<br>越简单的数据类型在计算时需要更少的CPU周期，比如，整型就比字符操作代价低，因而会使用整型来存储ip地址，使用DATETIME来存储时间，而不是使用字符串。</p><p>这里总结几个可能<strong>容易理解错误的技巧</strong>：</p><ol><li>通常来说把可为NULL的列改为NOT NULL不会对性能提升有多少帮助，只是如果计划在列上<strong>创建索引</strong>，就应该将该列设置为NOT NULL。</li><li>对整数类型指定宽度，比如INT(11)，只对业务限制有用，对于性能优化没有任何卵用。INT使用32位（4个字节）存储空间，那么它的<strong>表示范围已经确定</strong>，所以INT(1)和INT(20)对于存储和计算是相同的。</li><li>UNSIGNED表示不允许负值，大致可以使正数的<strong>上限提高</strong>一倍。比如TINYINT存储范围是-128 ~ 127，而UNSIGNED<br>TINYINT存储的范围却是0 - 255。</li><li>通常来讲，没有太大的必要使用DECIMAL数据类型（小数）。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据<strong>乘以一百万然后使用BIGINT存储</strong>。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题。</li><li>TIMESTAMP使用4个字节存储空间，DATETIME使用8个字节存储空间。因而，TIMESTAMP只能表示1970 -2038年，比DATETIME表示的范围小得多，而且TIMESTAMP的值因时区不同而不同。</li><li>大多数情况下没有使用枚举类型的必要，其中一个缺点是枚举的字符串列表是固定的，添加和删除字符串（枚举选项）必须使用ALTER<br>TABLE（如果只只是在列表末尾追加元素，不需要重建表）。</li><li>schema的列不要太多。原因是存储引擎的API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列，这个转换过程的代价是非常高的。如果<strong>列太多而实际使用的列又很少</strong>的话，有可能会导致CPU占用过高。</li><li>大表ALTER TABLE（修改表结构）非常耗时，MySQL执行大部分修改表结果操作的方法是用新的结构创建一个张空表，从旧表中<strong>查出所有的数据插入新表，然后再删除旧表</strong>。尤其当内存不足而表又很大，而且还有很大索引的情况下，耗时更久。当然有一些奇技淫巧可以解决这个问题，有兴趣可自行查阅。</li></ol><h2 id="2-创建高性能索引"><a href="#2-创建高性能索引" class="headerlink" title="2.创建高性能索引"></a>2.创建高性能索引</h2><p>索引是提高MySQL查询性能的一个重要途径，但<strong>过多的索引</strong>可能会导致过高的磁盘使用率以及过高的内存占用，从而影响应用程序的整体性能。<br>应当尽量避免事后才想起添加索引，因为事后可能需要监控大量的SQL才能定位到问题所在，而且添加索引的时间肯定是远大于初始添加索引所需要的时间，可见索引的添加也是非常有技术含量的。</p><p>接下来将向你展示一系列创建高性能索引的策略，以及每条策略其背后的工作原理。但在此之前，先了解与索引相关的一些算法和数据结构，将有助于更好的理解后文的内容。</p><h3 id="3索引相关的数据结构和算法"><a href="#3索引相关的数据结构和算法" class="headerlink" title="3索引相关的数据结构和算法"></a>3索引相关的数据结构和算法</h3><p>通常我们所说的索引是指<strong>B-Tree索引</strong>，它是目前关系型数据库中查找数据最为常用和有效的索引，大多数存储引擎都支持这种索引。使用B-Tree这个术语，是因为MySQL在CREATE TABLE或其它语句中使用了这个关键字，但实际上不同的存储引擎可能使用不同的数据结构，比如<strong>InnoDB就是使用的B+Tree</strong>。</p><p>B+Tree中的B是指balance，意为平衡。需要注意的是，B+树索引并不能找到一个给定键值的具体行，它找到的只是被查找数据行<strong>所在的页</strong>，接着数据库会把页读入到内存，再在内存中进行查找，最后得到要查找的数据。</p><p>在介绍B+Tree前，先了解一下二叉查找树，它是一种经典的数据结构，其左子树的值总是小于根的值，右子树的值总是大于根的值，如下图①。如果要在这课树中查找值为5的记录，其大致流程：先找到根，其值为6，大于5，所以查找左子树，找到3，而5大于3，接着找3的右子树，总共找了3次。同样的方法，如果查找值为8的记录，也需要查找3次。所以二叉查找树的平均查找次数为(3 + 3 + 3 + 2 + 2 + 1) / 6 = 2.3次，而顺序查找的话，查找值为2的记录，仅需要1次，但查找值为8的记录则需要6次，所以顺序查找的平均查找次数为：(1 + 2 + 3 + 4 + 5 + 6) / 6 = 3.3次，因此大多数情况下二叉查找树的平均查找速度比顺序查找要快。</p><h3 id="二叉查找树和平衡二叉树"><a href="#二叉查找树和平衡二叉树" class="headerlink" title="二叉查找树和平衡二叉树"></a>二叉查找树和平衡二叉树</h3><p>由于二叉查找树可以任意构造，同样的值，可以构造“瘸子树”，显然这棵二叉树的查询效率和顺序查找差不多。若想二叉查找数的查询性能最高，需要这棵二叉查找树是平衡的，也即<strong>平衡二叉树</strong>（AVL树）。</p><p>平衡二叉树首先需要符合二叉查找树的定义，其次必须满足<strong>任何节点的两个子树的高度差不能大于1</strong>。平衡二叉树的查找性能是比较高的（性能最好的是最优二叉树），查询性能越好，维护的成本就越大。当用户需要插入一个新的值9的节点时，就需要做出如下变动。</p><h2 id="平衡二叉树旋转"><a href="#平衡二叉树旋转" class="headerlink" title="平衡二叉树旋转"></a>平衡二叉树旋转</h2><p>通过一次左旋操作就将插入后的树重新变为平衡二叉树是最简单的情况了，实际应用场景中可能需要旋转多次。至此我们可以考虑一个问题，平衡二叉树的查找效率还不错，实现也非常简单，相应的维护成本还能接受，为什么MySQL索引不直接使用平衡二叉树？</p><p>随着数据库中数据的增加，索引本身大小随之增加，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级。可以想象一下<strong>一棵几百万节点的二叉树的深度</strong>是多少？如果将这么大深度的一颗二叉树放磁盘上，每读取一个节点，需要一次磁盘的I/O读取，整个查找的耗时显然是不能够接受的。那么如何减少查找过程中的I/O存取次数？</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>一种行之有效的解决方法是减少树的深度，将二叉树变为m叉树（多路搜索树），而B+Tree就是一种多路搜索树。理解B+Tree时，只需要理解其最重要的两个特征即可：</p><ul><li>第一，所有的关键字（可以理解为数据）都存储在叶子节点（Leaf Page），非叶子节点（Index Page）并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li><li>其次，所有的叶子节点由指针连接。如下图为高度为2的简化了的B+Tree。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/175724-52306456815a0919.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="简化B+Tree"></p><p>怎么理解这两个特征？MySQL将每个节点的大小设置为一个页的整数倍（原因下文会介绍），也就是在节点空间大小一定的情况下，每个节点可以存储更多的内结点，这样每个结点能索引的范围更大更精确。所有的叶子节点使用指针链接的好处是可以<strong>进行区间访问</strong>，比如上图中，如果查找大于20而小于30的记录，只需要找到节点20，就可以遍历指针依次找到25、30。如果<strong>没有链接指针的话，就无法进行区间查找</strong>。这也是MySQL使用B+Tree作为索引存储结构的重要原因。</p><p><strong>MySQL为何将节点大小设置为页的整数倍</strong>，这就需要理解磁盘的存储原理。磁盘本身存取就比主存慢很多，在加上机械运动损耗（特别是普通的机械硬盘），磁盘的存取速度往往是主存的几百万分之一，为了尽量减少磁盘I/O，磁盘往往不是严格按需读取，而是每次都会<strong>预读</strong>，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存，<strong>预读的长度一般为页的整数倍</strong>。</p><blockquote><p>页是计算机管理存储器的逻辑块，硬件及OS往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（许多OS中，<strong>页的大小通常为4K</strong>）。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读<strong>取一页或几页</strong>载入内存中，然后一起返回，程序继续运行。</p></blockquote><p>MySQL巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样<strong>每个节点只需要一次I/O就可以完全载入</strong>。为了达到这个目的，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了读取一个节点<strong>只需一次I/O</strong>。</p><p>假设B+Tree的高度为h，一次检索最多需要h-1次I/O（根节点常驻内存），复杂度$O(h) = O(\log_{M}N)$。实际应用场景中，M通常较大，常常超过100，因此树的高度一般都比较小，通常不超过3。</p><p>最后简单了解下B+Tree节点的操作，在整体上对索引的维护有一个大概的了解，虽然索引可以大大提高查询效率，但维护索引仍要花费很大的代价，因此合理的创建索引也就尤为重要。</p><p>我们假设<strong>每个节点只能存储4个内节点</strong>。首先要插入第一个节点28，如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/175724-a862bb909a8ed6a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="leaf page和index page都没有满"><br>leaf page和index page都没有满</p><p>接着插入下一个节点70，在Index Page中查询后得知应该插入到50 - 70之间的叶子节点，但叶子节点已满，这时候就需要进行也分裂的操作，当前的叶子节点起点为50，所以<strong>根据中间值</strong>来拆分叶子节点，如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/175724-ce47c776928bc6b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="Leaf Page拆分"><br>Leaf Page拆分</p><p>最后插入一个节点95，这时候Index Page和Leaf Page<strong>都满了</strong>，就需要做两次拆分，如下图所示。<br><img src="https://upload-images.jianshu.io/upload_images/175724-33cee181795b3dcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="此处输入图片的描述"><br>拆分后最终形成了这样一颗树。<br><img src="https://upload-images.jianshu.io/upload_images/175724-5289c6ec5d11216e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="此处输入图片的描述"></p><p><strong>为了避免拆分而旋转</strong><br>B+Tree为了保持平衡，对于新插入的值需要做大量的拆分页操作，而页的<strong>拆分</strong>需要I/O操作，为了尽可能的减少页的拆分操作，B+Tree也提供了类似于平衡二叉树的旋转功能。当Leaf Page已满但其左右兄弟节点没有满的情况下，B+Tree并不急于去做拆分操作，而是将记录移到当前所在页的兄弟节点上。通常情况下，<strong>左兄弟会被先检查用来做旋转操作</strong>。就比如上面第二个示例，当插入70的时候，并不会去做页拆分，而是左旋操作。<br><img src="https://upload-images.jianshu.io/upload_images/175724-bafd2fbc93cf45ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="此处输入图片的描述"><br>通过旋转操作可以最大限度的减少页分裂，从而减少索引维护过程中的磁盘的I/O操作，也提高索引维护效率。需要注意的是，删除节点跟插入节点类似，仍然需要旋转和拆分操作，这里就不再说明。</p><h2 id="高性能策略"><a href="#高性能策略" class="headerlink" title="高性能策略"></a>高性能策略</h2><p>通过上文，相信你对B+Tree的数据结构已经有了大致的了解，但MySQL中索引是如何组织数据的存储呢？以一个简单的示例来说明，假如有如下数据表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE People(</span><br><span class="line">    last_name varchar(50) not null,</span><br><span class="line">    first_name varchar(50) not null,</span><br><span class="line">    dob date not null,</span><br><span class="line">    gender enum(`m`,`f`) not null,</span><br><span class="line">    key(last_name,first_name,dob)//索引</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>对于表中每一行数据，索引中包含了last_name、first_name、dob列的值，下图展示了索引是如何组织数据存储的。<br><img src="https://upload-images.jianshu.io/upload_images/175724-3ba760afbae4a52d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="此处输入图片的描述"><br>可以看到，索引首先根据第一个字段来排列顺序，当名字相同时，则根据第三个字段，即出生日期来排序，正是因为这个原因，才有了索引的“最左原则”。</p><h3 id="1、MySQL不会使用索引的情况：非独立的列"><a href="#1、MySQL不会使用索引的情况：非独立的列" class="headerlink" title="1、MySQL不会使用索引的情况：非独立的列"></a>1、MySQL不会使用索引的情况：非独立的列</h3><p>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。比如：</p><figure class="highlight plain"><figcaption><span>* from where id + 1 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">我们很容易看出其等价于 id = 4，但是MySQL无法自动解析这个表达式，它并不认识id + 1，所以使用函数是同样的道理。</span><br><span class="line"></span><br><span class="line">### 2、前缀索引</span><br><span class="line">如果列很长，通常可以索引 **开始的部分字符**，这样可以有效节约索引空间，从而提高索引效率。</span><br><span class="line"></span><br><span class="line">### 3、多列索引 和 索引顺序</span><br><span class="line"></span><br><span class="line">**总结：**</span><br><span class="line">1.explain发现索引合并（Extra字段出现Using union），检查表结构和索引</span><br><span class="line">2.将选择性更高的字段放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在多数情况下，在多个列上建立独立的索引并不能提高查询性能。理由非常简单，MySQL不知道选择哪个索引的查询效率更好，所以在老版本，比如MySQL5.0之前就会随机选择一个列的索引，而新的版本会采用**合并索引**的策略。举个简单的例子，在一张电影演员表中，在actor_id和film_id两个列上都建立了**独立的索引**，然后有如下查询：</span><br></pre></td></tr></table></figure><p>select film_id,actor_id from film_actor where actor_id = 1 or film_id = 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">老版本的MySQL会随机选择一个索引，但新版本做如下的优化：</span><br></pre></td></tr></table></figure></p><p>select film_id,actor_id from film_actor where actor_id = 1<br>union all<br>select film_id,actor_id from film_actor where film_id = 1 and actor_id &lt;&gt; 1//or转化成and<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> - 当出现 多个索引 做**相交操作**时（多个**AND**条件），通常来说**一个包含所有相关列的索引(组合索引）**要优于多个独立索引。</span><br><span class="line"> - 当出现 多个索引 做**联合操作**时（多个**OR**条件），对结果集的合并、排序等操作需要耗费大量的CPU和内存资源，特别是当其中的某些索引的选择性不高，需要返回合并大量数据时，查询成本更高。所以这种情况下还不如走全表扫描。</span><br><span class="line"></span><br><span class="line">因此`explain`时如果发现有索引合并（Extra字段出现Using union（说明Mysql觉得你的索引不好，给你合并优化了），应该好好检查一下**查询和表结构**是不是已经是最优的，如果查询和表都没有问题，那只能说明索引建的非常糟糕，应当慎重考虑索引是否合适，有可能一个包含所有相关列的多列索引更适合。</span><br><span class="line"></span><br><span class="line">前面我们提到过索引如何组织数据存储的，从图中可以看到**多列索引**时，索引的顺序对于查询是至关重要的，很明显应该把选择性更高的字段放到索引的前面，这样通过第一个字段就可以过滤掉大多数不符合条件的数据。</span><br><span class="line"></span><br><span class="line">&gt; **索引选择性**是指 不重复的索引值 和数据表的 总记录数 的比值，选择性越高查询效率越高，因为选择性越高的索引可以让MySQL在查询时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</span><br><span class="line"></span><br><span class="line">理解索引选择性的概念后，就不难确定哪个字段的选择性较高了，查一下就知道了，比如：</span><br><span class="line"></span><br><span class="line">```SELECT * FROM payment where staff_id = 2 and customer_id = 584</span><br></pre></td></tr></table></figure></p><p>是应该创建(staff_id,customer_id)的索引还是应该颠倒一下顺序？执行下面的查询，哪个字段的选择性更接近1就把哪个字段索引前面就好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct staff_id)/count(*) as staff_id_selectivity,</span><br><span class="line">       count(distinct customer_id)/count(*) as customer_id_selectivity,</span><br><span class="line">       count(*) from payment</span><br></pre></td></tr></table></figure></p><p>多数情况下使用这个原则没有任何问题，但仍然注意你的数据中是否存在一些特殊情况。举个简单的例子，比如要查询某个用户组下有过交易的用户信息：</p><figure class="highlight plain"><figcaption><span>user_id from trade where user_group_id </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MySQL为这个查询选择了索引`(user_group_id,trade_amount)`，如果不考虑特殊情况，这看起来没有任何问题，但实际情况是这张表的大多数数据都是从老系统中迁移过来的，由于新老系统的数据不兼容，所以就给老系统迁移过来的数据赋予了一个默认的用户组。这种情况下，通过索引扫描的行数跟全表扫描基本没什么区别，索引也就起不到任何作用。</span><br><span class="line"></span><br><span class="line">推广开来说，经验法则和推论在多数情况下是有用的，可以指导我们开发和设计，但实际情况往往会更复杂，实际业务场景下的某些特殊情况可能会摧毁你的整个设计。</span><br><span class="line"></span><br><span class="line">### 4、避免多个范围条件</span><br><span class="line"> **原因：**范围查找时，无法同时使用两个列的索引（根据B+tree的结构，范围是到叶子节点后再通过指针移动）</span><br><span class="line"></span><br><span class="line">实际开发中，我们会经常使用多个范围条件，比如想查询某个时间段内登录过的用户：</span><br></pre></td></tr></table></figure><p>select user.* from user where login_time &gt; ‘2017-04-01’ and age between 18 and 30;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">这个查询有一个问题：它有两个范围条件，login_time列和age列，MySQL可以使用login_time列的索引或者age列的索引，但无法同时使用它们。</span><br><span class="line"></span><br><span class="line">### 5、覆盖索引</span><br><span class="line">如果索引**包含所有满足查询需要的数据的索引**成为覆盖索引(Covering Index)，也就是平时所说的不需要回表操作</span><br><span class="line"></span><br><span class="line">使用explain，，显示为using index</span><br><span class="line"></span><br><span class="line">覆盖索引是非常有用的工具，可以极大的提高性能，因为查询只需要扫描索引会带来许多好处：</span><br><span class="line"></span><br><span class="line"> - 索引条目远小于数据行大小，如果只读取索引，极大减少数据访问量，MySQL访问更少的数据</span><br><span class="line"> - 索引 是有按照列值顺序存储的，对于I/O密集型的范围查询要比随机从磁盘读取每一行数据的IO要少的多</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 6、使用索引扫描来排序</span><br><span class="line">MySQL有两种方式可以生产有序的结果集，其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的。</span><br><span class="line">如果explain的结果中type列的值为index表示使用了索引扫描来做排序。</span><br><span class="line"></span><br><span class="line">扫描索引本身很快，因为只需要从一条索引记录移动到相邻的下一条记录。</span><br><span class="line">但如果索引本身不能覆盖所有需要查询的列（不是覆盖索引），那么就不得不每扫描一条索引记录就回表查询一次对应的行。这个读取操作基本上是随机I/O，因此按照索引顺序读取数据的速度通常要比顺序地全表扫描要慢。</span><br><span class="line"></span><br><span class="line">在设计索引时，如果一个索引既能够满足排序，又满足查询，是最好的。</span><br><span class="line"></span><br><span class="line">只有当索引的列顺序和`ORDER BY`子句的**顺序完全一致**，并且所有列的**排序方向**也一样时，才能够使用索引来对结果做排序。</span><br><span class="line">如果查询需要关联多张表，则只有`ORDER BY`子句引用的字段**全部为第一张表**时，才能使用索引做排序。`ORDER BY`子句和查询的限制是一样的，都要满足最左前缀的要求（有一种情况例外，就是最左的列被指定为常数，下面是一个简单的示例），其他情况下都需要执行排序操作，而无法利用索引排序。</span><br></pre></td></tr></table></figure></p><p>// 最左列为常数，索引：(date,staff_id,customer_id)<br>// 虽然<br>select  staff_id,customer_id from demo where date = ‘2015-06-01’ order by staff_id,customer_id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">### 7、冗余和重复索引</span><br><span class="line">冗余索引是指在**相同的列**上按照**相同的顺序**创建的**相同类型的索引**，应当尽量避免这种索引，发现后立即删除。</span><br><span class="line">比如有一个索引(A,B)，再创建索引(A)就是冗余索引。冗余索引经常发生在为表添加新索引时，比如有人新建了索引(A,B)，但这个索引不是扩展已有的索引(A)。</span><br><span class="line"></span><br><span class="line">大多数情况下都应该尽**量扩展已有的索引而不是创建新索引**。但有极少情况下出现性能方面的考虑需要冗余索引，比如扩展已有索引而导致其变得过大，从而影响到其他使用该索引的查询。</span><br><span class="line"></span><br><span class="line">### 8、删除长期未使用的索引</span><br><span class="line">定期删除一些长时间未使用过的索引是一个非常好的习惯。</span><br><span class="line"></span><br><span class="line">关于索引这个话题打算就此打住，最后要说一句，索引并不总是最好的工具，只有当索引帮助提高查询速度带来的好处大于其带来的额外工作时，索引才是有效的。</span><br><span class="line">对于非常小的表，简单的全表扫描更高效。对于中到大型的表，索引就非常有效。对于超大型的表，建立和维护索引的代价随之增长，这时候其他技术也许更有效，比如分区表。最后的最后，`explain`后再提测是一种美德。</span><br><span class="line"></span><br><span class="line">## 特定类型查询优化</span><br><span class="line">### 优化COUNT()查询</span><br><span class="line">COUNT()可能是被大家误解最多的函数了，它有两种不同的作用，其一是统计某个列值的数量，其二是统计行数。统计列值时，要求列值是非空的，**它不会统计NULL**。如果确认括号中的表达式不可能为空时，实际上就是在统计行数。最简单的就是当使用COUNT(*)时，并不是我们所想象的那样扩展成所有的列，实际上，它会忽略所有的列而直接统计行数。</span><br><span class="line"></span><br><span class="line">我们最常见的误解也就在这儿，在括号内指定了一列却希望统计结果是行数，而且还常常误以为前者的性能会更好。但实际并非这样，**如果要统计行数，直接使用COUNT(*)，意义清晰，且性能更好。**</span><br><span class="line"></span><br><span class="line">有时候某些业务场景并不需要完全精确的COUNT值，可以用近似值来代替，EXPLAIN出来的行数就是一个不错的近似值，而且执行EXPLAIN并不需要真正地去执行查询，所以成本非常低。通常来说，执行COUNT()都需要扫描大量的行才能获取到精确的数据，因此很难优化，MySQL层面还能做得也就只有覆盖索引了。如果不还能解决问题，只有从架构层面解决了，比如**添加汇总表**，或者使用redis这样的外部缓存系统。</span><br><span class="line"></span><br><span class="line">### 优化关联查询</span><br><span class="line">在大数据场景下，表与表之间**通过一个冗余字段**来关联，要比直接使用JOIN有更好的性能。如果确实需要使用关联查询的情况下，需要特别注意的是：</span><br><span class="line"></span><br><span class="line"> - 确保ON和USING字句中的列上有索引。在创建索引的时候就要考虑到关联的顺序。当表A和表B用列c关联的时候，如果优化器关联的顺序是A、B，那么就不需要在A表的对应列上创建索引。没有用到的索引会带来额外的负担，一般来说，除非有其他理由，只需要在关联顺序中的**第二张表的相应列上创建索引**（具体原因下文分析）。</span><br><span class="line"> - 确保任何的`GROUP BY`和`ORDER BY`中的表达式只涉及到一个表中的列，这样MySQL才有可能使用索引来优化。（不同表，不同数据没法使用索引）</span><br><span class="line"></span><br><span class="line">要理解优化关联查询的第一个技巧，就需要理解MySQL是如何执行关联查询的。当前MySQL关联执行的策略非常简单，它对任何的关联都执行嵌套循环关联操作，</span><br><span class="line">即先在一个表中循环取出单条数据，然后在嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为为止。然后根据各个表匹配的行，返回查询中需要的各个列。</span><br><span class="line"></span><br><span class="line">太抽象了？以上面的示例来说明，比如有这样的一个查询：</span><br></pre></td></tr></table></figure></p><p>SELECT A.xx,B.yy<br>FROM A INNER JOIN B USING(c)<br>WHERE A.xx IN (5,6)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设MySQL按照查询中的关联顺序A、B来进行关联操作，那么可以用下面的伪代码表示MySQL如何完成这个查询：</span><br></pre></td></tr></table></figure></p><p>outer_iterator = SELECT A.xx,A.c FROM A WHERE A.xx IN (5,6);<br>outer_row = outer_iterator.next;<br>while(outer_row) {<br>    inner_iterator = SELECT B.yy FROM B WHERE B.c = outer_row.c;<br>    inner_row = inner_iterator.next;<br>    while(inner_row) {<br>        output[inner_row.yy,outer_row.xx];<br>        inner_row = inner_iterator.next;<br>    }<br>    outer_row = outer_iterator.next;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">可以看到，最外层的查询是根据`A.xx`列来查询的，`A.c`上如果有索引的话，整个关联查询也不会使用。再看内层的查询，很明显`B.c`上如果有索引的话，能够加速查询，因此只需要在关联顺序中的第二张表的相应列上创建索引即可。</span><br><span class="line"></span><br><span class="line">### 优化LIMIT分页</span><br><span class="line">当需要分页操作时，通常会使用LIMIT加上偏移量的办法实现，同时加上合适的ORDER BY字句。如果有**对应的索引**，通常效率会不错，否则，MySQL需要做大量的文件排序操作。</span><br><span class="line"></span><br><span class="line">一个常见的问题是当偏移量非常大的时候，比如：LIMIT 10000 20这样的查询，MySQL需要查询10020条记录然后只返回20条记录，前面的10000条都将被抛弃，这样的代价非常高。</span><br><span class="line"></span><br><span class="line">优化这种查询一个最简单的办法就是尽可能的**使用覆盖索引扫描**，而不是查询所有的列。然后根据需要做一次关联查询再返回所有的列。对于偏移量很大时，这样做的效率会提升非常大。考虑下面的查询：</span><br></pre></td></tr></table></figure></p><p>SELECT film_id,description FROM film ORDER BY title LIMIT 50,5;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果这张表非常大，那么这个查询最好改成下面的样子：</span><br></pre></td></tr></table></figure></p><p>SELECT film.film_id,film.description<br>FROM film INNER JOIN (<br>    SELECT film_id FROM film ORDER BY title LIMIT 50,5<br>) AS tmp USING(film_id);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里的延迟关联将大大提升查询效率，让MySQL扫描尽可能少的页面，获取需要访问的记录后在根据关联列回原表查询所需要的列。</span><br><span class="line"></span><br><span class="line">有时候如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET，比如下面的查询：</span><br></pre></td></tr></table></figure></p><p>SELECT id FROM t LIMIT 10000, 10;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">改为：</span><br><span class="line">```SELECT id FROM t WHERE id &gt; 10000 LIMIT 10;</span><br></pre></td></tr></table></figure></p><p>其他优化的办法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表中只包含主键列和需要做排序的列。</p><h3 id="优化UNION"><a href="#优化UNION" class="headerlink" title="优化UNION"></a>优化UNION</h3><p>MySQL处理UNION的策略是先创建临时表，然后再把各个查询结果插入到临时表中，最后再来做查询。因此很多优化策略在UNION查询中都没有办法很好的时候。经常需要手动将WHERE、LIMIT、ORDER BY等字句“下推”到各个子查询中，以便优化器可以充分利用这些条件先优化。</p><p>除非确实需要服务器去重，否则就一定要使用UNION ALL，如果没有ALL关键字，MySQL会给临时表加上DISTINCT选项，这会导致整个临时表的数据做唯一性检查，这样做的代价非常高。当然即使使用ALL关键字，MySQL总是将结果放入临时表，然后再读出，再返回给客户端。虽然很多时候没有这个必要，比如有时候可以直接把每个子查询的结果返回给客户端。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>理解查询是如何执行以及时间都消耗在哪些地方，再加上一些优化过程的知识，可以帮助大家更好的理解MySQL，理解常见优化技巧背后的原理。希望本文中的原理、示例能够帮助大家更好的将理论和实践联系起来，更多的将理论知识运用到实践中。</p><p>其他也没啥说的了，给大家留两个思考题吧，可以在脑袋里想想答案，这也是大家经常挂在嘴边的，但很少有人会思考为什么？</p><ul><li>有非常多的程序员在分享时都会抛出这样一个观点：尽可能不要使用存储过程，存储过程非常不容易维护，也会增加使用成本，应该把业务逻辑放到客户端。既然客户端都能干这些事，那为什么还要存储过程？</li><li>JOIN本身也挺方便的，直接查询就好了，为什么还需要视图呢？</li></ul>]]></content>
      
      <categories>
          
          <category> 技术原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-53 最大子序和</title>
      <link href="/2018/07/03/LeetCode-53%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
      <url>/2018/07/03/LeetCode-53%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
      <content type="html"><![CDATA[<p>给定一个整数数组 <code>nums</code>，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><blockquote><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></blockquote><p>进阶:如果你已经实现复杂度为 O(n)的解法，尝试使用更为精妙的分治法求解。</p><h1 id="解决方法（一）：暴力破解"><a href="#解决方法（一）：暴力破解" class="headerlink" title="解决方法（一）：暴力破解"></a>解决方法（一）：暴力破解</h1><p>笨蛋的JAE第一想法当然是暴力求解。从第一个元素开始进行遍历，时间复杂度是n+(n-1)+……+1 = (n^2+n)/2  。但是这样写，肯定会。</p><p>面试官：好的，我知道了，回家等消息去吧。<br>JAE： QAQ</p><h1 id="解决方法（二）-分治法"><a href="#解决方法（二）-分治法" class="headerlink" title="解决方法（二）:  分治法"></a>解决方法（二）:  分治法</h1><p>分治法当然是分治递归的思想。一般是二分。</p><p>将数组分为两部分，它的最大子序列要么在左半边，要么在右半边，要么在中间。</p><p>左边和右边的最大值，递归调用此方法即可求出，边界条件是当数组只剩下一个元素。<br>而求中间位置的最大值较麻烦，可用处于中间位置的数，先后向左向右累加，并保存下最大值，即可获得中部的最大子序列。</p><p>最后我们只要比较，这三部分那部分的最大子序列的和最大即可。<br>复杂度：因为是二分，且包含一次循环。故为 <code>O(nlogn)</code></p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxSubArray(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[left];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lmax = maxSubArray(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> rmax = maxSubArray(nums, mid +<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">int</span> mmax = nums[mid];</span><br><span class="line">        <span class="keyword">int</span> temp = mmax;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">            temp += nums[i];</span><br><span class="line">            mmax = Math.max(temp, mmax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &#123;-2,1,-3,4,-1,2,1,-5,400&#125;  temp=3,是从4，-1开始的，并不是从-1开始，所以让temp = mmax而不是nums[mid]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        temp = mmax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            temp += nums[i];</span><br><span class="line">            mmax = Math.max(temp, mmax);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = Math.max(lmax, Math.max(rmax, mmax));</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="解决方法（三）-kadane算法，动态规划"><a href="#解决方法（三）-kadane算法，动态规划" class="headerlink" title="解决方法（三）:  kadane算法，动态规划"></a>解决方法（三）:  kadane算法，动态规划</h1><p>kadane算法利用了数学归纳法和动态规划的思想。随意给你一个现成的数组，比如说−2, 1, −3, 4, −1, 2, 1, −5, 4，如果我们能从第一个数开始，随着数组的扩充，可以轻易的求出任意一个数组的最大子列和，先求1，再求2，最后根据i求到i+1.<br>就像走10阶楼梯，能走一步，能走两步，有多少种走法。你可能不知道，但是1阶你肯定知道，2阶你也肯定知道，3阶就是一阶走法加二阶走法。推广到10阶。</p><h2 id="思路一："><a href="#思路一：" class="headerlink" title="思路一："></a>思路一：</h2><p> maxSum 必然是以<code>nums[i]</code>结尾的某段构成的，也就是说maxSum的candidate必然是以nums[i]结果的。如果遍历每个candidate，然后进行比较，那么就能找到最大的maxSum了。</p><p>假设把<code>nums[i]之前</code>的连续段叫做<code>sum</code>。可以很容易想到:</p><ol><li>如果<code>sum&gt;=0</code>，就可以和nums[i]拼接在一起构成新的sum。因为不管nums[i]多大，<code>加上一个正数(sum)</code>总会更大，这样形成一个新的candidate。</li><li>反之，如果<code>sum&lt;0</code>，就没必要和nums[i]拼接在一起了。因为不管nums[i]多小，<code>加上一个负数(sum)</code>总会更小。此时由于题目要求数组连续，所以没法保留原sum，所以只能让sum等于<code>从nums[i]重新开始</code>的新的一段数了，这一段数字形成新的candidate。</li><li>如果每次得到新的candidate都和全局的maxSum进行比较，那么必然能找到最大的max sum subarray.</li></ol><p>总结：用两个数。sum为单纯的累加和，逐数添加。若sum&gt;0，则让其加上num[i],若sum&lt;0,则舍弃，让新的sum等于num[i]。<br>第二个数maxSum用于保存最大，当sum &gt; maxSum时maxSum = sum<br>在循环过程中，用maxSum记录历史最大的值。从nums[0]到nums[n-1]一步一步地进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> thisSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (thisSum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                thisSum += nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                thisSum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (thisSum &gt; maxSum) &#123;</span><br><span class="line">                maxSum = thisSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="思路二：动态规划"><a href="#思路二：动态规划" class="headerlink" title="思路二：动态规划"></a>思路二：动态规划</h2><p>遍历array，对于，我们判断（此位置之前的maxSum + nums[i]） 和 nums[i]比大小，如果nums[i]&gt;（sum + nums[i]） 大的话，那么说明不需要再继续加了，直接让这个数字作为新的nums[i]，开始继续，因为nums[i]已经比之前的sum都大了。</p><p>反过来，如果 （之前的sum + 这个数字）大于 （这个数字）就继续加下去。</p><blockquote><p>  利用动态规划做题。 只遍历数组一遍，当从头到尾部遍历数组A， 遇到一个数有两种选择<br>（1）加入之前subArray<br>（2）自己另起一个subArray</p></blockquote><p>设状态S[i], 表示以A[i]结尾的最大连续子序列和，状态转移方程如下:</p><blockquote><p>S[i] = max(S[i-1] + A[i],A[i])</p></blockquote><p>从状态转移方程上S[i]只与S[i-1]有关，与其他都无关，因此可以用一个变量来记住前一个的最大连续数组和就可以了。这样就可以节省空间了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间复杂度：O(n)     空间复杂度：O(1)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubArray_2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//或者初始化为  sum = INT_MIN 也OK。</span></span><br><span class="line">        <span class="keyword">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//S[i] = max(S[i-1] + A[i],A[i])</span></span><br><span class="line">        <span class="comment">//等号左边sum是最新的i，等号右边的sum是i-1的</span></span><br><span class="line">        </span><br><span class="line">            sum = Math.max(sum + nums[i], nums[i]); <span class="comment">//当前最大值</span></span><br><span class="line">            maxSum = Math.max(sum, maxSum);<span class="comment">//用于保存总体最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 分治法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL的btree索引和hash索索引的区别</title>
      <link href="/2018/07/03/MySQL%E7%9A%84btree%E7%B4%A2%E5%BC%95%E5%92%8Chash%E7%B4%A2%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/07/03/MySQL%E7%9A%84btree%E7%B4%A2%E5%BC%95%E5%92%8Chash%E7%B4%A2%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="hash索引优点：因结构的特殊性，其检索效率非常高。"><a href="#hash索引优点：因结构的特殊性，其检索效率非常高。" class="headerlink" title="hash索引优点：因结构的特殊性，其检索效率非常高。"></a>hash索引优点：因结构的特殊性，其检索效率非常高。</h1><p>hash索引：检索可以一次定位<br>B-Tree索引：需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问。<br>总结：Hash索引的查询效率要远高于 B-Tree 索引。</p><p>任何事物都是有两面性的，Hash 索引也一样，虽然 Hash索引效率高，但是 Hash 索引本身由于其特殊性也带来了很多限制和弊端，主要有以下这些。</p><h1 id="hash索引弊端：因其hash映射原则"><a href="#hash索引弊端：因其hash映射原则" class="headerlink" title="hash索引弊端：因其hash映射原则"></a>hash索引弊端：因其hash映射原则</h1><p>（1）Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，<strong>不能使用范围查询</strong>。</p><p>由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，<strong>因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。</strong></p><p>（2）Hash 索引无法被用来避免数据的排序操作。</p><p>由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库<strong>无法利用索引的数据来避免任何排序运算</strong>；</p><p>（3）Hash 索引不能利用部分索引键查询。</p><p>对于组合索引，Hash 索引在计算 Hash 值的时候是<strong>组合索引键合并后再一起计算 Hash 值</strong>，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。</p><p>（4）Hash 索引在任何时候都不能避免表扫描。</p><p>前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于<strong>不同索引键存在相同 Hash 值</strong>，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。</p><p>（5）Hash 索引遇到大量Hash值相等（hash碰撞）的情况后性能并不一定就会比B-Tree索引高。</p><p>对于选择性比较低的索引键（重复性比较大的），如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。</p><h1 id="如何选定使用类型"><a href="#如何选定使用类型" class="headerlink" title="如何选定使用类型"></a>如何选定使用类型</h1><p>hash索引：适合分布分散的，重复值较少的，无排序要求的，无范围查询要求的，独立或组合的索引</p><p>btree索引： 适合有排序要求，有范围查找要求，有部分索引要求的索引。</p>]]></content>
      
      <categories>
          
          <category> 技术原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode-28 实现strStr()</title>
      <link href="/2018/06/29/LeetCode-28%20%E5%AE%9E%E7%8E%B0strStr()/"/>
      <url>/2018/06/29/LeetCode-28%20%E5%AE%9E%E7%8E%B0strStr()/</url>
      <content type="html"><![CDATA[<h1 id="实现-strStr-函数。"><a href="#实现-strStr-函数。" class="headerlink" title="实现 strStr() 函数。"></a>实现 strStr() 函数。</h1><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: haystack = “hello”, needle = “ll”<br>输出: 2</p></blockquote><p>示例 2:</p><blockquote><p>输入: haystack = “aaaaa”, needle = “bba”<br>输出: -1</p></blockquote><p>说明:</p><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>显然，要用两个引用（指针）i,j，从两个字符串头部开始判断。<br>相同则同时后移（i++，j++），不同则i++。<br>终止条件：i，j其中之一达到底端。</p><p>第一次尝试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, n1 = haystack.length(), n2 = needle.length();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n1 &amp;&amp; j &lt; n2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == n2) <span class="keyword">return</span> i-j;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>输入： “mississippi” “issip”<br>输出： -1<br>预期：4</p></blockquote><p>踩坑错误：忽视了i这个指针，在与j相遇时，应进入一个内循环，终止条件是j到底或i到底，若中途有不相等的，要回到进入位置，故后修改，用一新指针head表示头部。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, n1 = haystack.length(), n2 = needle.length();</span><br><span class="line">        <span class="keyword">if</span>(n1 &lt; n2) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n1 &amp;&amp; j &lt; n2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">                head = i;</span><br><span class="line">                <span class="keyword">while</span>(haystack.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == n2-<span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">                    <span class="keyword">if</span>(i == n1-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//这里没写好，处理边界防止i到底移除</span></span><br><span class="line">                    i++;j++;                    </span><br><span class="line">                    &#125;</span><br><span class="line">                i = head;</span><br><span class="line">                &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == n2) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="看看别人的代码思路。"><a href="#看看别人的代码思路。" class="headerlink" title="看看别人的代码思路。"></a>看看别人的代码思路。</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(needle.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> first = needle.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> max = haystack.length()-needle.length();<span class="comment">//差值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) != first) &#123;</span><br><span class="line">                <span class="keyword">while</span> (++i &lt;= max &amp;&amp; haystack.charAt(i) != first);<span class="comment">//若i与needle第一个不同，++i直到相同</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= max) &#123;<span class="comment">//所在位置没超过差值，有戏</span></span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> end = j + needle.length() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; j &lt; end &amp;&amp; haystack.charAt(j) == needle.charAt(k); j++, k++);</span><br><span class="line">                <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//长度超了，则-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>狗屁无赖的答案如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haystack.indexOf(needle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Java高并发]有借有还——Java线程池</title>
      <link href="/2018/06/29/Java%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%9C%89%E5%80%9F%E6%9C%89%E8%BF%98%E2%80%94%E2%80%94Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2018/06/29/Java%E9%AB%98%E5%B9%B6%E5%8F%91-%E6%9C%89%E5%80%9F%E6%9C%89%E8%BF%98%E2%80%94%E2%80%94Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<h1 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h1><ol><li>降低资源消耗。  通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。  当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。  线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ol><h1 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h1><h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p>通过ThreadPoolExecutor来创建一个线程池。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class="line">keepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);</span><br></pre></td></tr></table></figure></p><p>创建一个线程池需要输入几个参数：(下面参数废话很多，可以一扫而过，用到再细看）</p><p><code>corePoolSize</code>（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。</p><p><code>runnableTaskQueue</code>（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ol><li><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li><li><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出）<br>排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列。</li><li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li><li><code>PriorityBlockingQueue</code>：一个具有优先级得无限阻塞队列。<br>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</li></ol><p><code>ThreadFactory</code>：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字，Debug和定位问题时非常又帮助。</p><p><code>RejectedExecutionHandler</code>（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。n  AbortPolicy：直接抛出异常。</p><p><code>CallerRunsPolicy</code>：只用调用者所在线程来运行任务。<br><code>DiscardOldestPolicy</code>：丢弃队列里最近的一个任务，并执行当前任务。</p><p><code>DiscardPolicy</code>：不处理，丢弃掉。<br>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</p><p><code>keepAliveTime</code>（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p><p><code>TimeUnit</code>（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</p><h2 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h2><p>我们可以使用<code>execute</code>提交的任务，但是execute方法没有返回值，所以无法判断任务知否被线程池执行成功。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>我们也可以使用<code>submit</code>方法来提交任务，它会返回一个future对象,那么我们可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p><h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><p>通过调用线程池的shutdown或shutdownNow方法来关闭线程池，但是它们的实现原理不同。</p><p>shutdown原理：是只是将线程池的状态设置成SHUTDOWN状态，然后中断所有<strong>没有正在执行任务</strong>的线程。<br>shutdownNow原理：是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</p><p>shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</p><h1 id="线程池分析"><a href="#线程池分析" class="headerlink" title="线程池分析"></a>线程池分析</h1><p>流程分析：线程池的主要工作流程如下图：<br><img src="http://ifeve.com/wp-content/uploads/2012/12/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BB%E8%A6%81%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="此处输入图片的描述"></p><p>按顺序分别判断基本线程池、工作队列、整个线程池是否已满</p><h1 id="合理的配置线程池"><a href="#合理的配置线程池" class="headerlink" title="合理的配置线程池"></a>合理的配置线程池</h1><p>要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：</p><ol><li>任务的性质：CPU密集型任务，IO密集型任务和混合型任务。</li><li>任务的优先级：高，中和低。</li><li>任务的执行时间：长，中和短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li></ol><p>任务性质不同的任务可以用不同规模的线程池分开处理。</p><p>CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。</p><p>IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。</p><p>混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p><p>优先级不同的任务可以使用<code>优先级队列PriorityBlockingQueue</code>来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p><p>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。</p><p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。</p><p><strong>建议使用有界队列</strong>，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如<strong>几千</strong>。如后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成<strong>无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用</strong>，而不只是后台任务出现问题。当然系统所有的任务是用的单独的服务器部署的，使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。</p><h1 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h1><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p><p>taskCount：线程池需要执行的任务数量。<br>completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。<br>largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。<br>getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。<br>getActiveCount：获取活动的线程数。<br>通过扩展线程池进行监控。通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;b&gt;protected&lt;/b&gt; &lt;b&gt;void&lt;/b&gt; beforeExecute(Thread t, Runnable r) &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>参考资料<br>Java并发编程实战。<br>JDK1.6源码。<br>转载自<a href="http://ifevee.com/java-threadpool/" target="_blank" rel="noopener">http://ifevee.com/java-threadpool/</a></p>]]></content>
      
      <categories>
          
          <category> 技术博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Java高并发]Java内存模型中的原子性、有序性及可见性</title>
      <link href="/2018/06/29/%5BJava%E9%AB%98%E5%B9%B6%E5%8F%91%5DJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E5%8F%8A%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
      <url>/2018/06/29/%5BJava%E9%AB%98%E5%B9%B6%E5%8F%91%5DJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E5%8F%8A%E5%8F%AF%E8%A7%81%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>[Java高并发]Java内存模型中的原子性、有序性及可见性</p><p>我们都知道Java内存模型都会运用主存，每个工作线程有自己的工作内存。数据在主存中会有一份，在工作内存中也有一份。工作内存和主存之间会有各种原子操作去进行同步。<br><img src="http://static.oschina.net/uploads/space/2016/0108/144136_jZqc_2243330.png" alt="此处输入图片的描述"></p><p>内存模型的原型基于上图</p><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。</p><p>一般认为cpu的指令都是原子操作，有些代码就不一定是原子操作了。<br>比如说i++。这个操作不是原子操作，基本分为3个操作，读取i，进行+1，赋值给i。</p><p>假设有两个线程，当第一个线程读取i=1时，还没进行+1操作，切换到第二个线程，此时第二个线程也读取的是i=1。随后两个线程进行后续+1操作，再赋值回去以后，i不是3，而是2。显然数据出现了不一致性。</p><p>再比如在32位的JVM上面去读取64位的long型数值，也不是一个原子操作。当然32位JVM读取32位整数是一个原子操作。</p><h2 id="原子性的实现：Atomic类"><a href="#原子性的实现：Atomic类" class="headerlink" title="原子性的实现：Atomic类"></a>原子性的实现：Atomic类</h2><p>就拿AtomicLong来说，它既解决了volatile的原子性没有保证的问题，又具有可见性。它是通过CAS（比较并交换）指令实现的。 其实AtomicLong的源码里也用到了volatile，但只是用来读取或写入。</p><h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><ul><li>计算机在执行代码时，不一定会按照程序的顺序来执行。</li></ul><p>那么为什么会发生乱序呢？这个要从cpu指令说起，Java中的代码被编译以后，最后也是转换成汇编码的。</p><p>一条指令的执行是可以分为很多步骤的，假设cpu指令分为以下几步</p><ul><li>取指 IF</li><li>译码和取寄存器操作数 ID</li><li>执行或者有效地址计算 EX</li><li>存储器访问 MEM</li><li>写回 WB</li></ul><p>假设这里有两条指令 <img src="http://static.oschina.net/uploads/space/2016/0108/180541_1fSx_2243330.jpg" alt="此处输入图片的描述"></p><p>一般来说我们会认为指令是串行执行的，先执行指令1，然后再执行指令2。假设每个步骤需要消耗1个cpu时间周期，那么执行这两个指令需要消耗10个cpu时间周期，这样做效率太低。事实上指令都是并行执行的，当然在第一条指令在执行IF的时候，第二条指令是不能进行IF的，因为 指令寄存器等 不能被同时占用。所以就如上图所示，两条指令是一种相对错开的方式并行执行。当指令1执行ID的时候，指令2执行IF。这样只用6个cpu时间周期就执行了两个指令，效率比较高。</p><p>按照这个思路我们来看下A=B+C的指令是如何执行的。<br><img src="http://static.oschina.net/uploads/space/2016/0108/181137_lXP7_2243330.jpg" alt="此处输入图片的描述"></p><p>这里注意，ADD操作时有一个空闲（X）操作，因为当想让B和C相加的时候，在图中ADD的X操作时，C还没从内存中读取（当MEM操作完成时，C才从内存中读取。这里会有一个疑问，此时还没有进行到R2的回写（WB），怎么会将R1与R2相加。那是因为在硬件电路当中，会使用一种叫“旁路”的技术直接把数据从硬件当中读取出来（不用放进去再取），所以不需要等待WB执行完才进行ADD）。所以ADD操作中会有一个空闲（X）时间。在SW操作中，因为EX指令不能和ADD的EX指令同时进行，所以也会有一个空闲（X）时间。</p><p>我们发现，这里的X很多，浪费的时间周期很多，性能也被影响。有没有办法使X的数量减少呢？</p><p>我们希望用一些操作把X的空闲时间填充掉，因为ADD与上面的指令有数据依赖，我们希望用一些没有数据依赖的指令去填充掉这些因为数据依赖而产生的空闲时间。</p><p>改变了指令顺序以后，X被消除了。总体的运行时间周期也减少了。</p><p>前提：当然指令重排的原则是不能破坏串行程序的语义，例如a=1,b=a+1，这种指令就不会重排了，因为重排的串行结果和原先的不同。</p><p>指令重排只是编译器或者CPU的优化一种方式，而这种优化就造成了程序间因不可见而的问题。</p><p>如何解决呢？用volatile关键字，这个后面会介绍到。</p><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>而volatile保证可见性的原理是什么呢？<br>如<code>volatile long vl = 0L;</code>简而言之，当另外一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。它是轻量级的synchronized，不会引起线程上下文的切换和调度，执行开销更小。</p><p>使用Violatile修饰的变量在汇编阶段，会多出一条lock前缀指令，它在多核处理器下会引发两件事情：</p><ol><li>将 当前处理器缓存行的数据 写回到系统内存。</li><li>这个写回内存的操作会使在其他 CPU里缓存了该内存地址的数据无效。</li></ol><p>通常处理器和内存之间都有几级缓存来提高处理速度，处理器先将内存中的数据读取到内部缓存后再进行操作，但是对于缓存写会内存的时机则无法得知，因此在一个处理器里修改的变量值，不一定能及时写会缓存，这种变量修改对其他处理器变得“不可见”了。<br>但是，使用Volatile修饰的变量，在写操作的时候，会强制将这个变量所在缓存行的数据写回到内存中，但即使写回到内存，其他处理器也有可能使用内部的缓存数据，从而导致变量不一致，所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期，如果过期，就会将该缓存行设置成无效状态，下次要使用就会重新从内存中读取。</p><font color="ff0000">总结：通过清除缓存，强制cpu重新去内存读取保证可见性。</font><p>对于i++这样的非原子性操作。是分为三个操作来的。<br>可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对i值进行修改。然后虽然volatile能保证线程2对变量i的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p><p>　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。因此在使用Violatile修饰变量时，一定要保证对该变量的写操作是原子性的，例如程序中的状态变量，对该变量的修改不依赖于其当前值。要解决此问题就要使用保证原子性的Atomic类，利用CAS机制来完成。</p>]]></content>
      
      <categories>
          
          <category> 技术原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Java高并发]JDK并发包的使用及原理</title>
      <link href="/2018/06/29/Java%E9%AB%98%E5%B9%B6%E5%8F%91-JDK%E5%B9%B6%E5%8F%91%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
      <url>/2018/06/29/Java%E9%AB%98%E5%B9%B6%E5%8F%91-JDK%E5%B9%B6%E5%8F%91%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>[Java高并发]JDK并发包的使用及原理</p><h1 id="一、同步控制工具"><a href="#一、同步控制工具" class="headerlink" title="一、同步控制工具"></a>一、同步控制工具</h1><h2 id="ReentrantLock-可重入锁"><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock(可重入锁)"></a>ReentrantLock(可重入锁)</h2><p>synchronized的特点：使用简单，一切交给JVM去处理，但是功能上是比较薄弱的。<br>在JDK1.5之前，ReentrantLock的性能要好于synchronized，由于对JVM进行了优化，现在的JDK版本中，两者性能是不相上下的。如果是简单的实现，不要刻意去使用ReentrantLock。</p><p>ReentrantLock的特点：在功能上更加丰富，它具有可重入、可中断、可限时、公平锁等特点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000000</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ReentrantLock必须在finally中进行解锁操作，如果不在 finally解锁，有可能代码出现异常 锁没被释放，而synchronized是由JVM来释放锁。</p><h3 id="特性一：可重入"><a href="#特性一：可重入" class="headerlink" title="特性一：可重入"></a>特性一：可重入</h3><p>单线程可以重复进入，但要重复退出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以反复得到相同的一把锁，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放(重入锁)。这模仿了 synchronized 的语义；如果线程进入由线程<strong>已经拥有的监控器保护</strong>的 synchronized 块，就允许线程继续进行，当线程退出第二个（或者后续） synchronized 块的时候，不释放锁，只有线程退出它进入的监控器保护的第一个synchronized 块时，才释放锁。</p><h3 id="特性二：可中断"><a href="#特性二：可中断" class="headerlink" title="特性二：可中断"></a>特性二：可中断</h3><p>与synchronized不同，ReentrantLock对中断是有响应的。</p><p>普通的lock.lock()是不能响应中断的，lock.lockInterruptibly()能够响应中断。<br>可用中断来处理死锁</p><h3 id="特性三：可限时"><a href="#特性三：可限时" class="headerlink" title="特性三：可限时"></a>特性三：可限时</h3><p>超时不能获得锁，就返回false，不会永久等待构成死锁</p><p>使用<code>lock.tryLock(long timeout, TimeUnit unit)</code>来实现可限时锁，参数为时间和单位。</p><h3 id="特性四：公平锁"><a href="#特性四：公平锁" class="headerlink" title="特性四：公平锁"></a>特性四：公平锁</h3><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock fairLock </span>= <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>一般意义上的锁是不公平的，不一定先来的线程能先得到锁，后来的线程就后得到锁。不公平的锁可能会产生饥饿现象。</p><p>优点：保证线程是先来的先得到锁。不会产生饥饿现象<br>缺点：性能会比非公平锁差很多。</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Condition与ReentrantLock的关系就类似于synchronized与Object.wait()/signal()</p><p>await()方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()时或者signalAll()方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和Object.wait()方法很相似。</p><p>awaitUninterruptibly()方法与await()方法基本相同，但是它并不会再等待过程中响应中断。 singal()方法用于唤醒一个在等待中的线程。相对的singalAll()方法会唤醒所有在等待中的线程。这和Obejct.notify()方法很类似。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">lock.lock();</span><br><span class="line">condition.await();<span class="comment">//等待</span></span><br><span class="line">System.out.println(<span class="string">"Thread is going on"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test t = <span class="keyword">new</span> Test();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(t);</span><br><span class="line">thread.start();</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line">condition.signal();<span class="comment">//唤醒</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Semaphore-（有额度的共享锁）"><a href="#Semaphore-（有额度的共享锁）" class="headerlink" title="Semaphore （有额度的共享锁）"></a>Semaphore （有额度的共享锁）</h2><p>一般的锁，都是排他锁，是独占额。</p><p>而对于Semaphore（中文为信号，旗语）来说，它允许多个线程同时进入临界区。可以认为它是一个共享锁，但是共享的额度是有限制的，额度用完了，其他没有拿到额度的线程还是要阻塞在临界区外。当额度为1时，就相等于lock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">semaphore.acquire();<span class="comment">//线程去获取semaphore</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getId() + <span class="string">" done"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">semaphore.release();<span class="comment">//释放</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个线程都去 Semaphore的许可，Semaphore的许可只有5个，运行后可以看到，5个一批，一批一批地输出。</p><h2 id="ReadWriteLock-读写锁"><a href="#ReadWriteLock-读写锁" class="headerlink" title="ReadWriteLock (读写锁)"></a>ReadWriteLock (读写锁)</h2><p>ReadWriteLock是区分功能的锁。读和写是两种不同的功能，读-读不互斥，读-写互斥，写-写互斥。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ReentrantReadWriteLock readWriteLock=<span class="keyword">new</span> ReentrantReadWriteLock(); <span class="comment">//读写锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = readWriteLock.readLock(); <span class="comment">//从读写锁获取 读锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = readWriteLock.writeLock();<span class="comment">//写锁</span></span><br></pre></td></tr></table></figure></p><p>并且有非常著名的消费者生产者问题。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>倒数计时器<br>长用于全部线程执行计数导数后，在执行主线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Test t = <span class="keyword">new</span> Test();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">System.out.println(<span class="string">"complete"</span>);</span><br><span class="line">countDownLatch.countDown();<span class="comment">//减少</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">executorService.execute(t);</span><br><span class="line">&#125;</span><br><span class="line">countDownLatch.await();</span><br><span class="line">System.out.println(<span class="string">"end"</span>);</span><br><span class="line">executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>和suspend类似，提供线程阻塞原语</p><pre><code>LockSupport.park(); LockSupport.unpark(t1);</code></pre><p>与suspend相比 不容易引起线程冻结</p><p>LockSupport和Semaphore有点相似，内部有一个许可，park的时候拿掉这个许可，unpark的时候申请这个许可。所以如果unpark在park之前，是不会发生线程冻结的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run()</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (u)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;in &quot; + getName());</span><br><span class="line">        //Thread.currentThread().suspend();</span><br><span class="line">        LockSupport.park();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure></p><h1 id="二、ReentrantLock-的实现"><a href="#二、ReentrantLock-的实现" class="headerlink" title="二、ReentrantLock 的实现"></a>二、ReentrantLock 的实现</h1><p>ReentrantLock的实现主要由3部分组成：</p><ul><li>CAS状态</li><li>等待队列</li><li>park()</li></ul><p>ReentrantLock的父类中会有一个state变量来表示同步的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* The synchronization state.</span><br><span class="line">*/</span><br><span class="line">    private volatile int state;</span><br></pre></td></tr></table></figure></p><p>通过<code>CAS</code>操作来设置state来获取锁，如果设置成了1，则将锁的持有者给当前线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))<span class="comment">//锁被设置成1则给当前</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);<span class="comment">//否则申请</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>如果拿锁不成功，则会做一个申请<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<span class="comment">//把自己加到等待队列</span></span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>首先，再去申请下试试看tryAcquire，因为此时可能另一个线程已经释放了锁。<br>如果还是没有申请到锁，就addWaiter，意思是把自己加到等待队列中去<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其间还会有多次尝试去申请锁，如果还是申请不到，就会被挂起<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>同理，如果在unlock操作中，就是释放了锁，然后unpark</p><h1 id="三、并发容器源码分析"><a href="#三、并发容器源码分析" class="headerlink" title="三、并发容器源码分析"></a>三、并发容器源码分析</h1><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>最简单的方式使HashMap变成线程安全就是使用Collections.synchronizedMap，它是对HashMap的一个包装,使用的是synchronized<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Map m=Collections.synchronizedMap(new HashMap());</span><br></pre></td></tr></table></figure></p><p>同理对于List，Set也提供了相似方法。<br>特点：适用于并发量比较小，高并发情况下性能堪忧<br>实现：将HashMap包装在里面，然后将HashMap的每个操作都加上synchronized。<br>由于每个方法都是获取同一把锁(mutex)，这就意味着，put和remove等操作是互斥的，大大减少了并发量。</p><p>而ConcurrentHashMap的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>相当于哈希表的哈希表。第一次hash得到一个HashMap的index，在此上再次hash得到确切的位置。<br>在 ConcurrentHashMap内部有一个Segment段，它将大的HashMap切分成若干个段（小的HashMap），然后让数据在每一段上Hash。</p><p>特点：多个线程在不同段上的Hash操作一定是线程安全的，所以只需要同步同一个段上的线程就可以了，这样实现了锁的分离，大大增加了并发量。</p><p>弊端：在使用ConcurrentHashMap.size时会比较麻烦，因为它要统计每个段的数据和，在这个时候，要把每一个段都加上锁，然后再做数据统计。这个就是把锁分离后的小小弊端，但是size方法应该是不会被高频率调用的方法。</p><p>在实现上，不使用synchronized和lock.lock而是尽量使用trylock，同时在HashMap的实现上，也做了一点优化。</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>BlockingQueue不是一个高性能的容器。但是它是一个非常好的共享数据的容器。是典型的生产者和消费者问题的实现。</p>]]></content>
      
      <categories>
          
          <category> 技术原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>欢迎使用 Cmd Markdown 编辑阅读器</title>
      <link href="/2018/06/26/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8%20Cmd%20Markdown%20%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8/"/>
      <url>/2018/06/26/%E6%AC%A2%E8%BF%8E%E4%BD%BF%E7%94%A8%20Cmd%20Markdown%20%E7%BC%96%E8%BE%91%E9%98%85%E8%AF%BB%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="欢迎使用-Cmd-Markdown-编辑阅读器"><a href="#欢迎使用-Cmd-Markdown-编辑阅读器" class="headerlink" title="欢迎使用 Cmd Markdown 编辑阅读器"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr><p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ul></blockquote><p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p><p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p><h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Windows/Mac/Linux 全平台客户端</a></h3><blockquote><p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p></blockquote><hr><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="noopener">Todo 列表</a></h3><ul><li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li><li style="list-style: none"><input type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li style="list-style: none"><input type="checkbox" checked> 新增 Todo 列表功能</li><li style="list-style: none"><input type="checkbox" checked> 修复 LaTex 公式渲染问题</li><li style="list-style: none"><input type="checkbox" checked> 新增 LaTex 公式编号功能</li></ul><h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p><h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="noopener">流程图</a></h3><div id="flowchart-0" class="flow-chart"></div><h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="noopener">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="noopener">甘特图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure><h3 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="noopener">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p><p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p><hr><h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p><h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p><h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p><p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p><h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p><h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p><h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p><h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p><p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p><p>通过管理工具栏可以：</p><p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p><h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p><p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p><p>工具栏上的五个图标依次为：</p><p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p><h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p><h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p><p>标签： 未分类</p><p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p><p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p><h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p><hr><p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p><p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="noopener">@ghosert</a><br>2016 年 07月 07日    </p><p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p><p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Startop=>operation: Your Operationcond=>condition: Yes or No?e=>endst->op->condcond(yes)->econd(no)->op</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>LeetCode-6 Z字形变换</title>
      <link href="/2018/06/21/LeetCode-6%20Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
      <url>/2018/06/21/LeetCode-6%20Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-6-Z字形变换"><a href="#LeetCode-6-Z字形变换" class="headerlink" title="LeetCode-6 Z字形变换"></a>LeetCode-6 Z字形变换</h1><p>难度：middle</p><p>将字符串 <code>PAYPALISHIRING</code> 以Z字形排列成给定的行数：</p><p>P&nbsp;&nbsp;&nbsp;&nbsp;A  &nbsp;&nbsp;&nbsp; H &nbsp;&nbsp;&nbsp;  N<br>A P&nbsp; L &nbsp;S&nbsp;I&nbsp;&nbsp; I&nbsp; G<br>Y  &nbsp;&nbsp;&nbsp; I &nbsp;&nbsp;&nbsp;  R<br>之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR”</p><p>实现一个将字符串进行指定行数变换的函数:</p><p>string convert(string s, int numRows);</p><blockquote><p>示例 1:</p><p>输入: s = “PAYPALISHIRING”, numRows = 3<br>输出: “PAHNAPLSIIGYIR”</p><p>示例 2:</p><p>输入: s = “PAYPALISHIRING”, numRows = 4<br>输出: “PINALSIGYAHRPI”</p></blockquote><p>解释:</p><p>P  &nbsp;&nbsp;  &nbsp; I  &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; N<br>A  &nbsp; L&nbsp; S &nbsp; &nbsp;&nbsp;I G<br>Y A &nbsp;  H &nbsp;R<br>P   &nbsp;&nbsp; &nbsp; I</p><h1 id="我的解法————考虑首尾行，中间行分前后跳跃"><a href="#我的解法————考虑首尾行，中间行分前后跳跃" class="headerlink" title="我的解法————考虑首尾行，中间行分前后跳跃"></a>我的解法————考虑首尾行，中间行分前后跳跃</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//外层大循环，表示每一行的循环</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> gap1 = <span class="number">2</span> * numRows - <span class="number">3</span>;<span class="comment">//前半段gap</span></span><br><span class="line">        <span class="keyword">int</span> gap2; <span class="comment">//后半段gap</span></span><br><span class="line">        <span class="keyword">int</span> gap = <span class="number">0</span>; <span class="comment">//真实的gap</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//1表示在前半段，-1表示在后半段</span></span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; numRows) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == numRows - <span class="number">1</span>) &#123;</span><br><span class="line">                gap = <span class="number">2</span> * numRows - <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">                    sb.append(s.charAt(j));</span><br><span class="line">                    j += (gap + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//处于中间，要判断下在前面还是后面</span></span><br><span class="line">                gap1 = gap;<span class="comment">//左</span></span><br><span class="line">                gap2 = <span class="number">2</span> * i - <span class="number">1</span>;<span class="comment">//右</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; len) &#123;</span><br><span class="line">                    sb.append(s.charAt(j));</span><br><span class="line">                    j = flag == <span class="number">1</span> ? (j + gap1 + <span class="number">1</span>) : (j + gap2 + <span class="number">1</span>);</span><br><span class="line">                    flag *= -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            gap = gap - <span class="number">2</span> &gt; <span class="number">0</span> ? gap - <span class="number">2</span> : (<span class="number">2</span> * numRows - <span class="number">3</span>);</span><br><span class="line">            i++;</span><br><span class="line">            j = i;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法一简化整理版本"><a href="#解法一简化整理版本" class="headerlink" title="解法一简化整理版本"></a>解法一简化整理版本</h1><p>对于所有整数 k，</p><p>行0中的字符位于索引k(2⋅numRows−2) 处;<br>行numRows−1 中的字符位于索引k(2⋅numRows−2)+numRows−1 处;<br>内部的 行 i中的字符位于索引k(2⋅numRows−2)+i 以及(k+1)(2⋅numRows−2)−i 处;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> cycleLen = <span class="number">2</span> * numRows - <span class="number">2</span>;<span class="comment">//循环的长度，也就是gap+1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; n; j += cycleLen) &#123;</span><br><span class="line">                ret.append(s.charAt(j + i));</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != numRows - <span class="number">1</span> &amp;&amp; j + cycleLen - i &lt; n)<span class="comment">//不是头尾，且没有超过s长度</span></span><br><span class="line">                    ret.append(s.charAt(j + cycleLen - i));<span class="comment">//j + cycleLen - i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二-：按行排序，每行有一个数组。"><a href="#解法二-：按行排序，每行有一个数组。" class="headerlink" title="解法二 ：按行排序，每行有一个数组。"></a>解法二 ：按行排序，每行有一个数组。</h1><p>思路</p><p>通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。</p><p>算法</p><p>我们可以使用 min( numRows, len(s)) 个列表来表示 Z 字形图案中的<strong>非空行</strong>。</p><p>从左到右迭代 s，将每个字符添加到合适的行。<br>可以<strong>使用当前行</strong>和<strong>当前方向</strong>这两个变量对合适的行进行跟踪。</p><p>只有当我们向上移动到最上面的行或向下移动到最下面的行时，<strong>当前方向</strong>才会发生改变。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        List&lt;StringBuilder&gt; rows = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Math.min(numRows, s.length()); i++)&#123;</span><br><span class="line">            rows.add(<span class="keyword">new</span> StringBuilder());<span class="comment">//确定list中有若干个个sb</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> curRow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> goingDown = <span class="keyword">false</span>;<span class="comment">//方向</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            rows.get(curRow).append(c);<span class="comment">//获取正确的sb，添加c</span></span><br><span class="line">            <span class="keyword">if</span> (curRow == <span class="number">0</span> || curRow == numRows - <span class="number">1</span>) goingDown = !goingDown;</span><br><span class="line">            curRow += goingDown ? <span class="number">1</span> : -<span class="number">1</span>;<span class="comment">//是向上还是向下</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder ret = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder row : rows) ret.append(row);</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复习整理————redis</title>
      <link href="/2018/06/08/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94redis/"/>
      <url>/2018/06/08/%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86%E2%80%94%E2%80%94redis/</url>
      <content type="html"><![CDATA[<h1 id="复习整理——redis"><a href="#复习整理——redis" class="headerlink" title="复习整理——redis"></a>复习整理——redis</h1><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>sql优化；</p><p>索引原理；</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>数据库引擎<br>聚合函数<br>聚集索引和非聚集索引的区别，存储引擎的区别？主键使用不重复的字符串会出现什么问题</p><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h2><p>1、<strong>完全基于内存</strong>，绝大部分请求是纯粹的<strong>内存</strong>操作。</p><p>2、<strong>数据结构简单</strong>，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用<strong>单线程</strong>，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的<strong>切换而消耗 CPU</strong>，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用<strong>多路I/O复用模型</strong>，<strong>非阻塞IO</strong>；</p><p>5、使用<strong>底层模型</strong>不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己<strong>构建了VM 机制</strong><br>（<strong>原因：</strong>1.redis对象远小于一个page（4k），所以不能用OS的内存交换，并且list类型，set类型可能位于多个page上,不利于换出。2.redis可以将对象压缩后再IO操作 3.OS交换会阻塞线程，redis可以设置让工作线程完成，主线程可以继续接受请求 )<br>因为用一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p><h2 id="多路-I-O-复用模型"><a href="#多路-I-O-复用模型" class="headerlink" title="多路 I/O 复用模型"></a>多路 I/O 复用模型</h2><p>详细细节见我另一篇博客。</p><p>多路I/O复用模型是利用 select、poll、epoll等系统调用函数。可以同时监控多个描述符的读写就绪情况。</p><p>可以同时<strong>监察多个流的 I/O事件</strong>的能力。<br>在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会<strong>轮询一遍所有的流</strong>（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让 单个线程高效的处理多个连接请求（只处理真正事件的流，尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><h2 id="redis为什么要使用单线程（指的是处理网络请求的线程）"><a href="#redis为什么要使用单线程（指的是处理网络请求的线程）" class="headerlink" title="redis为什么要使用单线程（指的是处理网络请求的线程）"></a>redis为什么要使用单线程（指的是处理网络请求的线程）</h2><p>官方QA:<br>Redis是基于内存的操作，瓶颈不是CPU，最有可能是<strong>机器内存的大小或者网络带宽</strong>。<br>既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。<br>多线程还要考虑原子性，考虑同步，考虑线程间的配合。单线程已经这么快，就没必要了。多核CPU 的问题，可以通过在单机开多个Redis 实例来完善！</p><h2 id="redis有哪些常用的数据结构"><a href="#redis有哪些常用的数据结构" class="headerlink" title="redis有哪些常用的数据结构"></a>redis有哪些常用的数据结构</h2><p>String、List、Set、Hash、ZSet这5种。有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）</p><p>设计一个缓存，你该怎么设计，get和set的时间复杂度怎么算的（答了用LinkedHashMap实现，分析了一下LinkedHashMap但是也没怎么说清）</p><p>Redis有哪些方法</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p><strong>使用：</strong><br>以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中，中途可以使用<strong>DISCARD</strong>放弃事务，表示不玩了最后由 <strong>EXEC</strong> 命令触发事务，一并执行事务中的所有命令。</p><p><strong>特性：</strong><br>事务中有语句执行错误了，不会影响上下文的执行，不回滚。<br>MYSQL的原子性：中途执行失败，回滚保证原子性。<br>redis的原子性：中途执行失败，不管，继续执行完所有的命令。保证原子性。<br><strong>一致性：</strong>添加了错误命令到事务队列中，事务会被拒绝执行。执行事务时停机，会根据AOF文件恢复。<br><strong>隔离性：</strong>事务之间不会相互影响，是因为redis是单线程的方式执行事务，并且执行事务中不会中断，事务总是以串行的方式运行。</p><p><strong>持久性：</strong><br>因为redis事务不过是简单的用队列包裹起来一组redis命令,redis并没有为事务提供任何额外的持久化功能,所以redis事务的耐久性由redis使用的模式决定。</p><h2 id="redis的持久化模式"><a href="#redis的持久化模式" class="headerlink" title="redis的持久化模式"></a><strong>redis的持久化模式</strong></h2><p>通过fork子进程来协助完成持久化</p><ul><li><strong>无持久化</strong>：事务不具有耐久性,一旦服务器停机,包括事务数据在内的所有服务器数据都将丢失 </li><li><strong>RDB持久化模式（bgsave做镜像全量持久化）</strong>： <strong>特点：</strong>耗时长，需要配合aof。原理：fock和cow，fock创建子进程，cow用来copy on write 服务器只会在<strong>特定的保存条件</strong>（定时或者定点保存）满足的时候才会执行BGSAVE命令,对数据库进行保存操作,并且异步执行的BGSAVE 不能保证事务数据被第一时间保存到硬盘里面,因此RDB持久化模式下的事务也不具有耐久性 （ 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。）</li><li><strong>AOF持久化模式，appedfsync的选项的值为always</strong>：程序总会在执行命令之后调用同步函数,将命令数据真正的保存到硬盘里面,因此<br>这种配置下的事务是具有耐久性的。 （每修改同步，消耗性能）</li><li><strong>AOF持久化模式,并且appedfsync的选项的值为everysec</strong>：程序会<strong>每秒</strong>同步一次命令数据到磁盘因为停机可能会恰好发生在等待同步的那一秒内,这种可能造成事务数据丢失,所以这种配置下的事务不具有耐久性</li></ul><p><strong>作用：</strong></p><ul><li><strong>批量操作</strong>  在发送 EXEC 命令前被放入队列缓存。</li><li>在事务执行过程，其他<strong>客户端提交的命令请求不会插入</strong>到事务执行命令序列中。（主要作用）</li></ul><h2 id="Redis和Kafka区别"><a href="#Redis和Kafka区别" class="headerlink" title="Redis和Kafka区别"></a>Redis和Kafka区别</h2><ul><li>kafka用于对于一些常规的消息系统，</li><li>“网站活性跟踪”将网页/用户操作等信息发送到kafka中.并实时监控,或者离线统计分析等</li><li>kafka的特性决定它非常适合作为”日志收集中心”</li></ul><h2 id="redis事务锁-（WATCH，监视数据）"><a href="#redis事务锁-（WATCH，监视数据）" class="headerlink" title="redis事务锁 （WATCH，监视数据）"></a>redis事务锁 （WATCH，监视数据）</h2><p>场景：你想防止某个字段不被修改。WATCH “name”。然后开启事务，若修改了name，在执行EXCT的时候，会拒绝事务操作，返回空值。</p><p>WATCH是一个乐观锁，可以在EXEC命令执行之前，监视任意数量的数据库键，并且在执行时，检查被监视的键是否有至少一个被修改了，是的话就拒绝执行事务。（保护 数据库键，拒绝修改，拒绝事务）<br><img src="http://paxblmm0h.bkt.clouddn.com/redis%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png" alt="此处输入图片的描述"></p><ul><li>如果name被修改，那么所有监视键name的客户端的<code>REDIS_DIRTY_CAS</code>标识将会被打开，表示该客户的事务安全性已经被 表示事务已经不再安全。客户端会拒绝事务的执行。</li></ul><p>Redis的底层的单线程模型和持久化的方式，再深入一点自己模拟实现一个简单的Redis可以吗（LRU算法，再自己想想时间复杂度）</p><h1 id="主从复制-分布式"><a href="#主从复制-分布式" class="headerlink" title="主从复制 分布式"></a>主从复制 分布式</h1><h2 id="为什么要主从复制"><a href="#为什么要主从复制" class="headerlink" title="为什么要主从复制"></a>为什么要主从复制</h2><p><strong>原则：</strong> Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。</p><p>这是一个典型的分布式<strong>读写分离</strong>模型。<br>利用master来插入数据<br>slave提供检索服务。这样可以有效减少单个机器的并发访问数量</p><p>通过slaveof命令复制，主→从。从服务器上：<code>SLAVEOF 127.0.0.1 6379</code><br><strong>旧版主从复制</strong><br><strong>1.同步</strong>：将<strong>从服务器</strong>的数据库状态更新至<strong>主服务器</strong>当前所处状态<br>1）发送SYNC命令<br>2）主服务器执行BGSAVE命令，在后头生成RDB文件，并使用一个缓冲区几率从现在驾驶执行的所有写命令<br>3）完成BGSAVE后，将RDB发送给从服务器，从服务器更新。<br>4）缓冲区写命令发送给从服务器，更新。<br><img src="http://paxblmm0h.bkt.clouddn.com/%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8CSYNC%E5%91%BD%E4%BB%A4.png" alt="此处输入图片的描述"><br><strong>2.命令传播：</strong>同步之后可能会因请求又导致主从不同，故主服务器会将自己执行的命令，同时发给从服务器执行。<br><strong>旧版缺陷：</strong>当主从服务器断线，从服务器需要重新SYNC，很消耗性能。</p><p><strong>新版主从复制：</strong> 2.8版本之后，使用PSYNC替代SYNC<br>PSYNC命令具有<strong>完整重同步</strong>和<strong>部分重同步</strong>两种模式：<br><strong>完整重同步：</strong>处理初次复制情况，和SYNC基本相同<br><strong>部分重同步：</strong>处理断线问题，当断线重连后，<strong>不是执行同步，而主服务器将断线期间命令发送给从服务器</strong>。通过复制偏移量、复制积压缓冲区、服务器运行ID实现。<br>命令传播程序在发送写命令给从服务器时，也会备份一份到积压缓冲区队列。<br>当重连时，根据从服务器提供的复制偏移量来选择执行何种操作。如果偏移量存在于缓存区，那么则部分重同步，如果偏移量之后不存在缓冲区，则执行完整重同步。<br><img src="http://paxblmm0h.bkt.clouddn.com/redis%20PSYNC%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%95%B4%E9%87%8D%E5%90%8C%E6%AD%A5%E5%92%8C%E9%83%A8%E5%88%86%E9%87%8D%E5%90%8C%E6%AD%A5.png" alt="此处输入图片的描述"></p><h2 id="读写分离模型"><a href="#读写分离模型" class="headerlink" title="读写分离模型"></a>读写分离模型</h2><p>通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。</p><p><strong>缺陷：</strong>不管是Master还是Slave，每个节点<strong>都必须保存完整的数据</strong>，如果在<strong>数据量很大</strong>的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。</p><h2 id="数据分片模型"><a href="#数据分片模型" class="headerlink" title="数据分片模型"></a>数据分片模型</h2><p>将每个节点看成都是<strong>独立的master</strong>，然后通过业务实现数据分片。<br>结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。</p><h2 id="Redis哨兵：高可用性解决方案"><a href="#Redis哨兵：高可用性解决方案" class="headerlink" title="Redis哨兵：高可用性解决方案"></a>Redis哨兵：高可用性解决方案</h2><p>由一个或多个哨兵实例组成的系统 监视任意多个主服务器。<br>当主服务器下线时，自动将被监视服务器 下属 某个服务器（从服务器）升级为新主服务器，代替下线服务器处理请求。<br><img src="http://paxblmm0h.bkt.clouddn.com/redis%E5%93%A8%E5%85%B5.png" alt="此处输入图片的描述"><br>当server1的下线时长超过用户设定的下线时长上限，哨兵系统就会对其进行<strong>故障转移操作</strong>。<br>1.挑选一个从服务器成为主服务器<br>2.Sentinel系统发送指令让其他从服务器成为新主服务器的从服务器<br>3.Sentinel系统继续监控下限的server1，重新上线后让其成为新主服务器的从服务器。<br><img src="http://paxblmm0h.bkt.clouddn.com/redis%E5%93%A8%E5%85%B5%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png" alt="此处输入图片的描述"></p><p>Sentinel本质上只是一个运行在特殊模式下的Redis服务器，只是初始化过程不同，执行其专用代码。<br>1.获取主服务器信息，哨兵每十秒一次，以及其从服务器信息<br>2.当发现主服务器有新从服务器出现时，也会向从服务器创建订阅及命令连接。<br>3.发送以及接收主从服务器消息。<br>4.监测主服务器主观下线状态（从主服务器获取），检查主服务器客观下线状态（从其从服务获取是否真的下线）<br>5.选取领头Sentinel去解决下线服务器故障转移：都有可能，先到先得。</p><h2 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h2><p>作用：提供的分布式数据库方案，通过分片来进行数据共享，提供复制和故障转移操作。</p><p>开始的节点是分散在各自独立集群。向节点发送CLUSTER MEET，让节点进行握手，形成集群。<br>1.启动节点<br><img src="http://paxblmm0h.bkt.clouddn.com/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E9%9B%86%E7%BE%A4.png" alt="此处输入图片的描述"><br>节点可以使用所有单机模式组件。</p><p>优势：自动分割数据到不同的节点上。<br>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p><strong>线程锁（JVM)：</strong>主要用来给<strong>方法、代码块</strong>加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠<strong>线程之间共享内存</strong>实现的，比如synchronized是共享<strong>对象头</strong>，显示锁Lock是共享某个变量（state）。<br><strong>进程锁：</strong>为了控制同一操作系统中多个进程访问某个<strong>共享资源</strong>，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。<br><strong>分布式锁：</strong>当多个进程不在同一个系统中，用分布式锁控制多个进程对资源的访问。</p><p>分布式锁一般有三种实现方式：</p><ul><li>数据库乐观锁；</li><li>基于Redis的分布式锁；</li><li>基于ZooKeeper的分布式锁。<h2 id="redis分布锁"><a href="#redis分布锁" class="headerlink" title="redis分布锁"></a><strong>redis分布锁</strong></h2><strong>特性：</strong></li><li>1.互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>具有容错性。 只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们加锁就一行代码：<code>jedis.set(String key, String value, String nxxx, String expx, int time)</code>，这个set()方法一共有五个形参：<br><strong>锁，钥匙，存在则不操作，设置过期时间，时间长度</strong></p><ol><li>key：我们使用key来当锁，因为key是唯一的。</li><li>value：我们传的是requestId，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。（也就是requestId是加锁客户端独有的）</li><li>nxxx，这个参数我们填的是NX，意思是<code>SET IF NOT EXIST</code>，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>expx，这个参数我们传的是PX，意思是我们要给这个key加一个<strong>过期的设置</strong>，具体时间由第五个参数决定。(我们不允许有永久的锁）</li><li>time，与第四个参数相呼应，代表key的过期时间。</li></ol><p>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。</p><p>满足了上述的所有特性，不会发生死锁</p><p><strong>解锁代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一行代码，我们写了一个简单的Lua脚本代码(能够在服务器端 <strong>原子地</strong>执行多个Redis命令）详细介绍见《redis原理和实战》一书第20章。    </p><p>第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS<a href="http://paxblmm0h.bkt.clouddn.com/redis%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png" target="_blank" rel="noopener">1</a>赋值为lockKey，ARGV<a href="http://paxblmm0h.bkt.clouddn.com/redis%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png" target="_blank" rel="noopener">1</a>赋值为requestId。<strong>eval()方法</strong>是将Lua代码交给Redis服务端执行。</p><p>首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。<br>Lua语言能确保上述操作是<strong>原子性</strong>的。</p><p>关于非原子性会带来什么问题，一个场景举例：<br>在判断判断锁和解锁中间，插入了锁过期和其他设置锁。<br>问题在于如果调用jedis.del()方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。<br>比如客户端A加锁，一段时间之后客户端A解锁，在执行jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</p><h2 id="一系列问题"><a href="#一系列问题" class="headerlink" title="一系列问题"></a>一系列问题</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>解释：</strong>由于原有缓存失效，新缓存未到期。这俩时间段之间，大量访问数据库。<br><strong>造成原因：</strong>设置缓存时采用了相同的过期时间，某一时间点大量缓存过期。<br><strong>解决方案：</strong></p><ol><li>分析用户行为，尽量让失效时间点均匀分布。避免缓存雪崩的出现。</li><li>并发量小时，加锁排队，治标不治本的方法</li><li>并发量大时，为缓存加标记记录缓存是否失效，失效则重新更新数据。</li><li>二级缓存：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</li></ol><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>造成原因：</strong>狂TM查询缓存和数据库都没有的东西。穿透攻击。缓存命中率极低。<br><strong>解决方案：</strong></p><ol><li><p><strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。（多个has算法，验证所有bitmap对应位置上是不是都是1，都是的话才存在，会误伤正确访问，但是绝不会通过无效访问）节省空间。</p></li><li><p><strong>快速过期的空值也放到缓存中</strong>！如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个<strong>空结果进行缓存</strong>，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！</p></li></ol><h3 id="缓存预热（开机或者挂了重启加缓存）"><a href="#缓存预热（开机或者挂了重启加缓存）" class="headerlink" title="缓存预热（开机或者挂了重启加缓存）"></a>缓存预热（开机或者挂了重启加缓存）</h3><p>系统上线后，提前将相关的缓存数据直接加载到缓存系统。<br>解决方案：</p><ol><li>直接写个缓存刷新页面，上线时手工添加缓存</li><li>定时刷新缓存</li></ol><h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<br>（1）<strong>定时</strong>去清理过期的缓存；（适合少量缓存<br>（2）当有用户请求过来时，再判断这个<strong>请求所用到的缓存是否过期</strong>，过期的话就去底层系统得到新数据并更新缓存。</p><p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！</p><p>缓存降级</p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点整理 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redis面试题及相关原理</title>
      <link href="/2018/06/08/redis%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/"/>
      <url>/2018/06/08/redis%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="redis面试题及相关原理"><a href="#redis面试题及相关原理" class="headerlink" title="redis面试题及相关原理"></a>redis面试题及相关原理</h1><h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h2><p>1、<strong>完全基于内存</strong>，绝大部分请求是纯粹的<strong>内存</strong>操作。</p><p>2、<strong>数据结构简单</strong>，对数据操作也简单，Redis中的数据结构是专门进行设计的；</p><p>3、采用<strong>单线程</strong>，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的<strong>切换而消耗 CPU</strong>，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>4、使用<strong>多路I/O复用模型</strong>，<strong>非阻塞IO</strong>；</p><p>5、使用<strong>底层模型</strong>不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己<strong>构建了VM 机制</strong><br>（<strong>原因：</strong>1.redis对象远小于一个page（4k），所以不能用OS的内存交换，并且list类型，set类型可能位于多个page上,不利于换出。2.redis可以将对象压缩后再IO操作 3.OS交换会阻塞线程，redis可以设置让工作线程完成，主线程可以继续接受请求 )<br>因为用一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p><h2 id="多路-I-O-复用模型"><a href="#多路-I-O-复用模型" class="headerlink" title="多路 I/O 复用模型"></a>多路 I/O 复用模型</h2><p>详细细节见我另一篇博客。</p><p>多路I/O复用模型是利用 select、poll、epoll等系统调用函数。可以同时监控多个描述符的读写就绪情况。</p><p>可以同时<strong>监察多个流的 I/O事件</strong>的能力。<br>在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会<strong>轮询一遍所有的流</strong>（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让 单个线程高效的处理多个连接请求（只处理真正事件的流，尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><h2 id="redis为什么要使用单线程（指的是处理网络请求的线程）"><a href="#redis为什么要使用单线程（指的是处理网络请求的线程）" class="headerlink" title="redis为什么要使用单线程（指的是处理网络请求的线程）"></a>redis为什么要使用单线程（指的是处理网络请求的线程）</h2><p>官方QA:<br>Redis是基于内存的操作，瓶颈不是CPU，最有可能是<strong>机器内存的大小或者网络带宽</strong>。<br>既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。<br>多线程还要考虑原子性，考虑同步，考虑线程间的配合。单线程已经这么快，就没必要了。多核CPU 的问题，可以通过在单机开多个Redis 实例来完善！</p><h2 id="redis有哪些常用的数据结构"><a href="#redis有哪些常用的数据结构" class="headerlink" title="redis有哪些常用的数据结构"></a>redis有哪些常用的数据结构</h2><p>String、List、Set、Hash、ZSet这5种。有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）</p><p>设计一个缓存，你该怎么设计，get和set的时间复杂度怎么算的（答了用LinkedHashMap实现，分析了一下LinkedHashMap但是也没怎么说清）</p><p>Redis有哪些方法</p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p><strong>使用：</strong><br>以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中，中途可以使用<strong>DISCARD</strong>放弃事务，表示不玩了最后由 <strong>EXEC</strong> 命令触发事务，一并执行事务中的所有命令。</p><p><strong>特性：</strong><br>事务中有语句执行错误了，不会影响上下文的执行，不回滚。<br>MYSQL的原子性：中途执行失败，回滚保证原子性。<br>redis的原子性：中途执行失败，不管，继续执行完所有的命令。保证原子性。<br><strong>一致性：</strong>添加了错误命令到事务队列中，事务会被拒绝执行。执行事务时停机，会根据AOF文件恢复。<br><strong>隔离性：</strong>事务之间不会相互影响，是因为redis是单线程的方式执行事务，并且执行事务中不会中断，事务总是以串行的方式运行。</p><p><strong>持久性：</strong><br>因为redis事务不过是简单的用队列包裹起来一组redis命令,redis并没有为事务提供任何额外的持久化功能,所以redis事务的耐久性由redis使用的模式决定。</p><h2 id="redis的持久化模式"><a href="#redis的持久化模式" class="headerlink" title="redis的持久化模式"></a><strong>redis的持久化模式</strong></h2><p>通过fork子进程来协助完成持久化</p><ul><li><strong>无持久化</strong>：事务不具有耐久性,一旦服务器停机,包括事务数据在内的所有服务器数据都将丢失 </li><li><strong>RDB持久化模式（bgsave做镜像全量持久化）</strong>： <strong>特点：</strong>耗时长，需要配合aof。原理：fock和cow，fock创建子进程，cow用来copy on write 服务器只会在<strong>特定的保存条件</strong>（定时或者定点保存）满足的时候才会执行BGSAVE命令,对数据库进行保存操作,并且异步执行的BGSAVE 不能保证事务数据被第一时间保存到硬盘里面,因此RDB持久化模式下的事务也不具有耐久性 （ 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。）</li><li><strong>AOF持久化模式，appedfsync的选项的值为always</strong>：程序总会在执行命令之后调用同步函数,将命令数据真正的保存到硬盘里面,因此<br>这种配置下的事务是具有耐久性的。 （每修改同步，消耗性能）</li><li><strong>AOF持久化模式,并且appedfsync的选项的值为everysec</strong>：程序会<strong>每秒</strong>同步一次命令数据到磁盘因为停机可能会恰好发生在等待同步的那一秒内,这种可能造成事务数据丢失,所以这种配置下的事务不具有耐久性</li></ul><p><strong>作用：</strong></p><ul><li><strong>批量操作</strong>  在发送 EXEC 命令前被放入队列缓存。</li><li>在事务执行过程，其他<strong>客户端提交的命令请求不会插入</strong>到事务执行命令序列中。（主要作用）</li></ul><h2 id="Redis和Kafka区别"><a href="#Redis和Kafka区别" class="headerlink" title="Redis和Kafka区别"></a>Redis和Kafka区别</h2><ul><li>kafka用于对于一些常规的消息系统，</li><li>“网站活性跟踪”将网页/用户操作等信息发送到kafka中.并实时监控,或者离线统计分析等</li><li>kafka的特性决定它非常适合作为”日志收集中心”</li></ul><h2 id="redis事务锁-（WATCH，监视数据）"><a href="#redis事务锁-（WATCH，监视数据）" class="headerlink" title="redis事务锁 （WATCH，监视数据）"></a>redis事务锁 （WATCH，监视数据）</h2><p>场景：你想防止某个字段不被修改。WATCH “name”。然后开启事务，若修改了name，在执行EXCT的时候，会拒绝事务操作，返回空值。</p><p>WATCH是一个乐观锁，可以在EXEC命令执行之前，监视任意数量的数据库键，并且在执行时，检查被监视的键是否有至少一个被修改了，是的话就拒绝执行事务。（保护 数据库键，拒绝修改，拒绝事务）<br><img src="http://paxblmm0h.bkt.clouddn.com/redis%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png" alt="此处输入图片的描述"></p><ul><li>如果name被修改，那么所有监视键name的客户端的<code>REDIS_DIRTY_CAS</code>标识将会被打开，表示该客户的事务安全性已经被 表示事务已经不再安全。客户端会拒绝事务的执行。</li></ul><p>Redis的底层的单线程模型和持久化的方式，再深入一点自己模拟实现一个简单的Redis可以吗（LRU算法，再自己想想时间复杂度）</p><h1 id="主从复制-分布式"><a href="#主从复制-分布式" class="headerlink" title="主从复制 分布式"></a>主从复制 分布式</h1><h2 id="为什么要主从复制"><a href="#为什么要主从复制" class="headerlink" title="为什么要主从复制"></a>为什么要主从复制</h2><p><strong>原则：</strong> Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。</p><p>这是一个典型的分布式<strong>读写分离</strong>模型。<br>利用master来插入数据<br>slave提供检索服务。这样可以有效减少单个机器的并发访问数量</p><p>通过slaveof命令复制，主→从。从服务器上：<code>SLAVEOF 127.0.0.1 6379</code><br><strong>旧版主从复制</strong><br><strong>1.同步</strong>：将<strong>从服务器</strong>的数据库状态更新至<strong>主服务器</strong>当前所处状态<br>1）发送SYNC命令<br>2）主服务器执行BGSAVE命令，在后头生成RDB文件，并使用一个缓冲区几率从现在驾驶执行的所有写命令<br>3）完成BGSAVE后，将RDB发送给从服务器，从服务器更新。<br>4）缓冲区写命令发送给从服务器，更新。<br><img src="http://paxblmm0h.bkt.clouddn.com/%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%89%A7%E8%A1%8CSYNC%E5%91%BD%E4%BB%A4.png" alt="此处输入图片的描述"><br><strong>2.命令传播：</strong>同步之后可能会因请求又导致主从不同，故主服务器会将自己执行的命令，同时发给从服务器执行。<br><strong>旧版缺陷：</strong>当主从服务器断线，从服务器需要重新SYNC，很消耗性能。</p><p><strong>新版主从复制：</strong> 2.8版本之后，使用PSYNC替代SYNC<br>PSYNC命令具有<strong>完整重同步</strong>和<strong>部分重同步</strong>两种模式：<br><strong>完整重同步：</strong>处理初次复制情况，和SYNC基本相同<br><strong>部分重同步：</strong>处理断线问题，当断线重连后，<strong>不是执行同步，而主服务器将断线期间命令发送给从服务器</strong>。通过复制偏移量、复制积压缓冲区、服务器运行ID实现。<br>命令传播程序在发送写命令给从服务器时，也会备份一份到积压缓冲区队列。<br>当重连时，根据从服务器提供的复制偏移量来选择执行何种操作。如果偏移量存在于缓存区，那么则部分重同步，如果偏移量之后不存在缓冲区，则执行完整重同步。<br><img src="http://paxblmm0h.bkt.clouddn.com/redis%20PSYNC%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%95%B4%E9%87%8D%E5%90%8C%E6%AD%A5%E5%92%8C%E9%83%A8%E5%88%86%E9%87%8D%E5%90%8C%E6%AD%A5.png" alt="此处输入图片的描述"></p><h2 id="读写分离模型"><a href="#读写分离模型" class="headerlink" title="读写分离模型"></a>读写分离模型</h2><p>通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。</p><p><strong>缺陷：</strong>不管是Master还是Slave，每个节点<strong>都必须保存完整的数据</strong>，如果在<strong>数据量很大</strong>的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。</p><h2 id="数据分片模型"><a href="#数据分片模型" class="headerlink" title="数据分片模型"></a>数据分片模型</h2><p>将每个节点看成都是<strong>独立的master</strong>，然后通过业务实现数据分片。<br>结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。</p><h2 id="Redis哨兵：高可用性解决方案"><a href="#Redis哨兵：高可用性解决方案" class="headerlink" title="Redis哨兵：高可用性解决方案"></a>Redis哨兵：高可用性解决方案</h2><p>由一个或多个哨兵实例组成的系统 监视任意多个主服务器。<br>当主服务器下线时，自动将被监视服务器 下属 某个服务器（从服务器）升级为新主服务器，代替下线服务器处理请求。<br><img src="http://paxblmm0h.bkt.clouddn.com/redis%E5%93%A8%E5%85%B5.png" alt="此处输入图片的描述"><br>当server1的下线时长超过用户设定的下线时长上限，哨兵系统就会对其进行<strong>故障转移操作</strong>。<br>1.挑选一个从服务器成为主服务器<br>2.Sentinel系统发送指令让其他从服务器成为新主服务器的从服务器<br>3.Sentinel系统继续监控下限的server1，重新上线后让其成为新主服务器的从服务器。<br><img src="http://paxblmm0h.bkt.clouddn.com/redis%E5%93%A8%E5%85%B5%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB.png" alt="此处输入图片的描述"></p><p>Sentinel本质上只是一个运行在特殊模式下的Redis服务器，只是初始化过程不同，执行其专用代码。<br>1.获取主服务器信息，哨兵每十秒一次，以及其从服务器信息<br>2.当发现主服务器有新从服务器出现时，也会向从服务器创建订阅及命令连接。<br>3.发送以及接收主从服务器消息。<br>4.监测主服务器主观下线状态（从主服务器获取），检查主服务器客观下线状态（从其从服务获取是否真的下线）<br>5.选取领头Sentinel去解决下线服务器故障转移：都有可能，先到先得。</p><h2 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h2><p>作用：提供的分布式数据库方案，通过分片来进行数据共享，提供复制和故障转移操作。</p><p>开始的节点是分散在各自独立集群。向节点发送CLUSTER MEET，让节点进行握手，形成集群。<br>1.启动节点<br><img src="http://paxblmm0h.bkt.clouddn.com/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E9%9B%86%E7%BE%A4.png" alt="此处输入图片的描述"><br>节点可以使用所有单机模式组件。</p><p>优势：自动分割数据到不同的节点上。<br>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</p><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p><strong>线程锁（JVM)：</strong>主要用来给<strong>方法、代码块</strong>加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠<strong>线程之间共享内存</strong>实现的，比如synchronized是共享<strong>对象头</strong>，显示锁Lock是共享某个变量（state）。<br><strong>进程锁：</strong>为了控制同一操作系统中多个进程访问某个<strong>共享资源</strong>，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。<br><strong>分布式锁：</strong>当多个进程不在同一个系统中，用分布式锁控制多个进程对资源的访问。</p><p>分布式锁一般有三种实现方式：</p><ul><li>数据库乐观锁；</li><li>基于Redis的分布式锁；</li><li>基于ZooKeeper的分布式锁。<h2 id="redis分布锁"><a href="#redis分布锁" class="headerlink" title="redis分布锁"></a><strong>redis分布锁</strong></h2><strong>特性：</strong></li><li>1.互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>具有容错性。 只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们加锁就一行代码：<code>jedis.set(String key, String value, String nxxx, String expx, int time)</code>，这个set()方法一共有五个形参：<br><strong>锁，钥匙，存在则不操作，设置过期时间，时间长度</strong></p><ol><li>key：我们使用key来当锁，因为key是唯一的。</li><li>value：我们传的是requestId，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。（也就是requestId是加锁客户端独有的）</li><li>nxxx，这个参数我们填的是NX，意思是<code>SET IF NOT EXIST</code>，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>expx，这个参数我们传的是PX，意思是我们要给这个key加一个<strong>过期的设置</strong>，具体时间由第五个参数决定。(我们不允许有永久的锁）</li><li>time，与第四个参数相呼应，代表key的过期时间。</li></ol><p>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。</p><p>满足了上述的所有特性，不会发生死锁</p><p><strong>解锁代码</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一行代码，我们写了一个简单的Lua脚本代码(能够在服务器端 <strong>原子地</strong>执行多个Redis命令）详细介绍见《redis原理和实战》一书第20章。    </p><p>第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS<a href="http://paxblmm0h.bkt.clouddn.com/redis%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png" target="_blank" rel="noopener">1</a>赋值为lockKey，ARGV<a href="http://paxblmm0h.bkt.clouddn.com/redis%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png" target="_blank" rel="noopener">1</a>赋值为requestId。<strong>eval()方法</strong>是将Lua代码交给Redis服务端执行。</p><p>首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。<br>Lua语言能确保上述操作是<strong>原子性</strong>的。</p><p>关于非原子性会带来什么问题，一个场景举例：<br>在判断判断锁和解锁中间，插入了锁过期和其他设置锁。<br>问题在于如果调用jedis.del()方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。<br>比如客户端A加锁，一段时间之后客户端A解锁，在执行jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</p><h2 id="一系列问题"><a href="#一系列问题" class="headerlink" title="一系列问题"></a>一系列问题</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>解释：</strong>由于原有缓存失效，新缓存未到期。这俩时间段之间，大量访问数据库。<br><strong>造成原因：</strong>设置缓存时采用了相同的过期时间，某一时间点大量缓存过期。<br><strong>解决方案：</strong></p><ol><li>分析用户行为，尽量让失效时间点均匀分布。避免缓存雪崩的出现。</li><li>并发量小时，加锁排队，治标不治本的方法</li><li>并发量大时，为缓存加标记记录缓存是否失效，失效则重新更新数据。</li><li>二级缓存：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期</li></ol><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>造成原因：</strong>狂TM查询缓存和数据库都没有的东西。穿透攻击。缓存命中率极低。<br><strong>解决方案：</strong></p><ol><li><p><strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。（多个has算法，验证所有bitmap对应位置上是不是都是1，都是的话才存在，会误伤正确访问，但是绝不会通过无效访问）节省空间。</p></li><li><p><strong>快速过期的空值也放到缓存中</strong>！如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个<strong>空结果进行缓存</strong>，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！</p></li></ol><h3 id="缓存预热（开机或者挂了重启加缓存）"><a href="#缓存预热（开机或者挂了重启加缓存）" class="headerlink" title="缓存预热（开机或者挂了重启加缓存）"></a>缓存预热（开机或者挂了重启加缓存）</h3><p>系统上线后，提前将相关的缓存数据直接加载到缓存系统。<br>解决方案：</p><ol><li>直接写个缓存刷新页面，上线时手工添加缓存</li><li>定时刷新缓存</li></ol><h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<br>（1）<strong>定时</strong>去清理过期的缓存；（适合少量缓存<br>（2）当有用户请求过来时，再判断这个<strong>请求所用到的缓存是否过期</strong>，过期的话就去底层系统得到新数据并更新缓存。</p><p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！</p><p>缓存降级</p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点整理 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM部分</title>
      <link href="/2018/04/14/JVM%E9%83%A8%E5%88%86/"/>
      <url>/2018/04/14/JVM%E9%83%A8%E5%88%86/</url>
      <content type="html"><![CDATA[<h1 id="JVM部分"><a href="#JVM部分" class="headerlink" title="JVM部分"></a>JVM部分</h1><p>##运行时数据区： </p><h3 id="线程私有部分：三个"><a href="#线程私有部分：三个" class="headerlink" title="线程私有部分：三个"></a>线程私有部分：三个</h3><p>1.程序计数器：可看作当前线程所执行的字节码的行号指示器。<br>字节码解释器通过便便这个计数器的值来完成分支，循环、跳转、异常处理、线程恢复操作。</p><p>2.Java虚拟机栈（大部分所说的栈）：<br>生命周期：同线程<br>每个方法产生栈帧：存放存储局部变量表、操作数栈、动态链接、方法出口。<br>存储局部变量表：各种基本数据类型，对象引用，returnAddress地址。</p><p>3.本地方法栈：<br>与虚拟机栈区别：虚拟机栈为Java方法（字节码）服务。本地方法栈为虚拟机用到的Native方法服务。</p><h3 id="线程共享部分：三个"><a href="#线程共享部分：三个" class="headerlink" title="线程共享部分：三个"></a>线程共享部分：三个</h3><p>1.Java堆<br>特点：内存最大，可不连续，可选定大小，可扩展。线程共享。</p><p>唯一目的：存放对象实例及数组。（非绝对：有栈上分配和标量替换技术）</p><p>区域细分：新生代、老年代。或是Eden空间、From Survivor空间、To Survivor空间。</p><p>2.方法区<br>特点：线程共享。内存可不连续，可选定大小，可扩展。<br>不完全等同“永久代”。<br>目的：存放已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码。<br>2.1 <strong>运行时常量池</strong>（方法区一部分）</p><p>Class文件的具体组成结构：类的版本、字段、方法、接口，常量池。常量池存放编译期生成的各种字面量和符号引用。在类加载后进入运行时常量池。<br>对比其他Class文件组成，它的重要特点：<strong>动态性</strong>。在运行时，也能添加到常量池。实例：String类的intern()方法</p><h2 id="对象的创建-普通对象-不包括数组和Class对象）"><a href="#对象的创建-普通对象-不包括数组和Class对象）" class="headerlink" title="对象的创建(普通对象,不包括数组和Class对象）"></a>对象的创建(普通对象,不包括数组和Class对象）</h2><p>###1.接收new指令，<br>检查指令参数在常量池是否有类的符号引用。（存不存在这个类），并检查类是否被加载、解析和初始化。没有则请看<strong>类的初始化</strong>。</p><h3 id="2-为新生对象分配内存。"><a href="#2-为新生对象分配内存。" class="headerlink" title="2.为新生对象分配内存。"></a>2.为新生对象分配内存。</h3><p>内存分配方式（由Java堆是否规整绝对（收集器，GC算法），请看压缩整理部分）：<br><code>1.指针碰撞</code>假设此时堆中内存规整（无碎片），分界指针向空闲部分移动对象大小距离。<br><code>2.空闲列表</code>JVM维护一个列表，记录空间位置。</p><p>线程安全问题解决方式：<br>1.同步处理————CAS机制<br>2.本地线程分配缓冲：先分块区域给不同线程，在各自空间创建，用完再考虑同步锁定。</p><h3 id="设置对象必要信息"><a href="#设置对象必要信息" class="headerlink" title="设置对象必要信息"></a>设置对象必要信息</h3><p>设置对象头内容：类信息，类元数据信息，对象哈希码，对象的GC分代年龄等<br>是否启用偏向锁。<br>接下来才是<code>&lt;init&gt;</code>方法，为对象设置各种属性</p><h2 id="对象的内存布局，内容？"><a href="#对象的内存布局，内容？" class="headerlink" title="对象的内存布局，内容？"></a>对象的内存布局，内容？</h2><p><strong>对象头</strong>：包括<strong>对象自身的运行时数据</strong>(哈希码、GC年龄、锁状态、偏向线程ID、偏向时间戳）  、 <strong>类型指针</strong>（指向哪个类）<br><strong>实例数据</strong>：父类继承的、子类定义的。<br><strong>填充对齐</strong>：占位符作用，使对象大小必须是8字节的整数倍。</p><h2 id="对象的访问与定位是怎样的？"><a href="#对象的访问与定位是怎样的？" class="headerlink" title="对象的访问与定位是怎样的？"></a>对象的访问与定位是怎样的？</h2><p><img src="http://paxblmm0h.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F.jpg" alt="此处输入图片的描述"></p><p><strong>使用句柄：</strong>堆中有个句柄池，栈的reference指向句柄地址，<br>特点：稳定，移动时只改句柄<br><strong>直接指针：</strong>堆对象内部有个对象类型数据指针。<br>特点: 快，一次引用</p><h2 id="异常：OutOfMemoryError-精简版本"><a href="#异常：OutOfMemoryError-精简版本" class="headerlink" title="异常：OutOfMemoryError 精简版本"></a>异常：OutOfMemoryError 精简版本</h2><p>1.堆溢出</p><p>区分：内存泄漏和内存溢出<br><strong>内存泄漏memory leak：</strong>程序在申请内存后，无法释放已申请的内存空间（游离）<br>解决：查看泄露对象到GC ROOTS 的引用链，造成的无法GC</p><p><strong>内存溢出 out of memory</strong> :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。 </p><p>2.虚拟机栈和本地方法栈溢出<br>1.一般是StackOverFlowError</p><p>有趣的现象：栈分配内存越大，越容易产生内存溢出。<br>原因：内存固定，每个栈的分配内存越大，总共的栈数（线程数）就越少。在多线程时更容易溢出。</p><h1 id="第三章-垃圾收集器和内存分配策略"><a href="#第三章-垃圾收集器和内存分配策略" class="headerlink" title="第三章 垃圾收集器和内存分配策略"></a>第三章 垃圾收集器和内存分配策略</h1><h2 id="对象已死吗？是否可回收？"><a href="#对象已死吗？是否可回收？" class="headerlink" title="对象已死吗？是否可回收？"></a>对象已死吗？是否可回收？</h2><p>1.<strong>引用计数算法：</strong>添加一个计数器，被引用一次值+1<br>存在问题：循环引用问题，<br>2.<strong>可达性分析算法：</strong><br><img src="http://paxblmm0h.bkt.clouddn.com/JVM3-1%20%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt="此处输入图片的描述"><br>原理：从GC ROOTS 开始向下通过引用链搜索，判断是否可达。<br>GC ROOTS： 虚拟机栈中（栈帧中的本地变量表）<strong>引用的</strong>对象。<br>方法区中类<strong>static属性</strong>引用的 对象<br>方法区中<strong>常量引用</strong>的对象<br>本地方法栈中 <strong>Native方法</strong>引用的对象</p><h2 id="引用的类型"><a href="#引用的类型" class="headerlink" title="引用的类型"></a>引用的类型</h2><p>引用如果只是 0 1 那未免太绝对，故存在四种等级：强软弱虚</p><p>强引用：代码之中普遍存在的。用 “=” 连接实例的，绝不会被回收<br>软引用：有用但非必须的对象。只有在内存溢出异常前才会加入回收。<br>弱引用：非必须，下次GC到来之时会回收。有内存时只回收弱引用。<br>虚引用：不影响对象生命周期，只作为系统通知而存在。 </p><h2 id="leave-or-die"><a href="#leave-or-die" class="headerlink" title="leave or die"></a>leave or die</h2><p>必死对象：不可达对象会被标记（下通缉令），若对象没重写finalize()方法（免死金牌？），或者免死金牌用过了。 那么请die吧。</p><p>非必死对象：有没用过的免死金牌，对象放到F-Queue中，等待Finalizer线程去执行，免死金牌finalizer要使用得当（重新与GC root建立连接），并第二次标记（解除通缉令），如果使用不当，那么还是得over。</p><h3 id="方法区（永久代）的回收————条件严苛"><a href="#方法区（永久代）的回收————条件严苛" class="headerlink" title="方法区（永久代）的回收————条件严苛"></a>方法区（永久代）的回收————条件严苛</h3><p>对象：废弃常量和无用的类<br>废弃常量：String s = “abc”，当没有引用的时候，回收<br>无用的类（需同时满足）：1.该类所有实例被回收 2.该类的ClassLoader已被回收<br>3.该类对应的Class对象没有被引用，无法反射访问</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p><strong>一、标记-清除算法（Mark-Sweep）算法</strong><br>原理：可达性分析，标记清除对象，清除。<br>缺点：1.效率低下。 2.产生大量不连续的内存碎片，浪费空间</p><p><strong>二、复制算法（用于新生代）</strong><br>原理：将内存二分，每次用一块，不够用了就复制 有用对象 到另一块。然后本块全部清除。<br>优点：分配内存方便，直接用指针碰撞。<br>缺点：1.内存缩为一般。<br>应用：Eden和From Survivor空间的有用对象 复制到To Survivor空间，然后清除掉自生空间。E : FS : TS = 8 : 1 : :1<br>所以可用空间有9。</p><p><strong>三、标记—整理算法（Mark-Compact）（年老代）</strong><br>原理：标记完，不是清除，而是整理，存活对象都向一端移动。清除边界外的对象。</p><p><strong>四、目前商用————分代收集算法</strong><br>新生代（大量对象死去）用复制算法，年老代（存活率高）用标记—整理算法（或者标记—清除算法）</p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><p><strong>枚举根节点：</strong>为了快速检查GC ROOTS的引用，采用了：OopMap数据结构，在类加载完成时，会记录下引用。<br><strong>安全点：</strong> hotspot在线程达到安全点的时候才会考虑一次OopMap，并且开始GC。<br>问题：若多线程下不在安全点怎么办？ 1.抢先式中断（没JVM在用）：停下所有线程，若发现线程不在安全点上，则恢复让其达到安全点并停止。<br><strong>2主动式中断：</strong>设置一个标志，让各线程去轮询这个标志，发现中断标志后就自己中断挂起。轮询标志与安全点位置重合。</p><h2 id="多种GC收集器（仅讨论HotSpot的）"><a href="#多种GC收集器（仅讨论HotSpot的）" class="headerlink" title="多种GC收集器（仅讨论HotSpot的）"></a>多种GC收集器（仅讨论HotSpot的）</h2><p><img src="http://paxblmm0h.bkt.clouddn.com/HotSpot%E7%9A%84gc%E6%94%B6%E9%9B%86%E5%99%A8.png" alt="连线是配合"><br><strong>连线表示了两种收集器能否配合使用。</strong></p><p>新生代：<br>1.Serial收集器：单线程，GC时暂停所有工作线程<br>2.parNew收集器：上述的多线程版本，其他区别不大<br>3.Parallel Scavaenge：平行扫描，新生代并行回收（无法配合<br>老年代：<br>1.Serial Old：那家伙的老年代版本，使用标记—整理算法<br>2.parNew Old:多线程，标记—整理算法，只能配合上面的3<br><strong>3.CMS（Concurrent Mark Sweep)收集器</strong>：并发收集，低停顿。<br>缺点：1.对CPU资源敏感2.无法处理浮动垃圾3.属于清除算法，会产生碎片</p><p><strong>G1收集器</strong> 1.7开始<br>特点：<br>1.并行与并发：利用CPU、多核来减少StopTheWorld的时间<br>2.分代收集：可独立管理GC堆，不用其他收集器<br>3.空间整合:整体基于清除-整理算法，不同于CMS的清理。<br>4.可预测的停顿：可建立可预测的停顿模型</p><h2 id="一图搞懂内存分配与回收策略"><a href="#一图搞懂内存分配与回收策略" class="headerlink" title="一图搞懂内存分配与回收策略"></a>一图搞懂内存分配与回收策略</h2><p><img src="http://paxblmm0h.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%8F%8A%E5%9E%83%E5%9C%BE%E6%B8%85%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="此处输入图片的描述"></p><h1 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h1><h2 id="类的生命周期七阶段"><a href="#类的生命周期七阶段" class="headerlink" title="类的生命周期七阶段"></a>类的生命周期七阶段</h2><p>加载、验证、准备、解析、初始化、使用、卸载</p><p><strong>什么会触发加载：</strong><br>1）遇到new（实例对象化）、getstatic（读取静态字段）、putstatic（设置静态字段）、invokestatic（调用静态方法）字节码时。<br>2）使用java.lang.reflect包的方法对类反射调用时<br>3）初始化一个类必须先初始化其父类<br>4）虚拟机启动，初始化主类。包含main()的类<br>5）java.lang,invoke.MethonHandle实例的方法句柄（这是个啥？？？）</p><p>数组有虚拟机直接创建，不通过类加载器</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><strong>1.加载：虚拟机 ：类名→二进制字节流→静态结构变运行数据结构→Class对象作为入口</strong><br>1）通过一个类的全限定名来获取定义此类的二进制字节流。<br>2）将这个字节流所代表的<code>静态储存结构</code>转化为<strong>方法区</strong>的<code>运行时数据结构</code>，并储存在方法区。<br>3)在内存中产生这个类的java.lang.Class对象，储存在方法区，作为方法区的这个类的各种资源访问入口</p><p><strong>2.验证：格式、元数据、字节码、符号</strong><br>确保Class文件的字节流符合当前虚拟机要求，防止有害字节流导致系统崩溃。会验证：<br>1）文件格式 （开头，版本，类型）2）元数据信息（父类，继承是否符合规定，是否矛盾）3）字节码（类型转换有效）4）符号引用</p><p><strong>3.准备：</strong> 类变量分配内存<br>为<strong>类变量分配内存</strong> 并设置 <strong>类变量初始值</strong>的阶段，类变量也就是static变量都在方法区进行分配。不包括实例变量（只在对象实例化的时候随对象分配在Java堆中）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure></p><p>此时只会赋0值，因为复制的putStatic指令是编译后，存放在类构造器<code>&lt;client&gt;()</code>方法中，在初始化阶段才会进行。</p><p><strong>4.解析：将常量值内<code>符号引用</code>转化为<code>直接引用</code></strong><br>类或接口的解析，字段解析，类方法解析，接口方法解析。</p><p><strong>5.初始化 为静态属性初始化值</strong><br>前面均有虚拟机来完成，初始化才开始执行类中定义的字节码。执行类构造器<code>&lt;clinit&gt;()</code>方法，从java.oang.Object开始依次向下执行。由父到子。</p><h2 id="类加载器-作用"><a href="#类加载器-作用" class="headerlink" title="类加载器 作用"></a>类加载器 作用</h2><p>1.加载 类</p><ol start="2"><li>判别类，同类是由同一个类加载器加载出来的，比如同Class文件，同JVM，而不同类加载器。出来的类是不相等的</li></ol><p>你可以手写一个简单的类加载器，并加载一个Class文件，然后判断加载出来的类与系统加载出来的类是否相同，答案当然是不同的！！</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p><strong>类加载器 从 JVM角度 分类：</strong><br>1.启动类加载器（JVM的一部分）<br>2.其他类加载器（独立于JVM，继承抽象类java.lang.ClassLoader）</p><p>细分：</p><ul><li>启动类加载器：加载\lib中的<strong>类库</strong>到虚拟机内存中，无法被Java程序直接引用。</li><li>扩展类加载器：加载\lib\ext目录中的，或者被指定路径中的所有类库</li><li>应用程序类加载器：由ClassLoader实现，<code>ClassLoader.getSystemClassLoader()</code>，负责ClassPath上所制定的类库。若没有自定义类加载器，<strong>一般这个就是程序默认的加载器</strong>。</li></ul><p><img src="http://paxblmm0h.bkt.clouddn.com/%E5%9B%BE7-2%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" alt="双亲委派模型"></p><p><strong>要求：</strong>除了顶层的启动类加载器外，其余的类加载器都用当有自己的父类加载器，这里不以继承关系而由组合实现复用父类加载器代码。</p><p><strong>工作过程：</strong><br>1.类加载器 收到 加载类请求，先委派给 父类加载器完成<br>2.所以，所有类都是先由 <strong>启动类加载器</strong> 先尝试加载<br>3.当前类加载器无法完成加载（没找到所需的类），交由子加载器加载。</p><p><strong>优点：</strong>使Java类随类加载器一起具备了带有优先级的层次关系。如java.lang.Object。他存放在rt.jar中。所以无论哪个加载器加载Object类，都会委托给启动类加载器加载，保证了Object唯一性。以免用户自己写一个Object类，避免混乱，你若自己写一个，你会发现可以正常编译，但无法被加载运行。</p><p><strong>逻辑：</strong><br>1.先检查是否加载，没加载调用父类加载器的LoadClass()，若父类为空则调用启动类加载器。若加载失败，抛出<code>ClassNotFoundException</code>后调用自生的findClass()加载</p><p><img src="http://paxblmm0h.bkt.clouddn.com/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B.png" alt="此处输入图片的描述"></p><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>双亲是推荐加载机制而非强制。曾有三次破坏。</p><p>1.为了<strong>向前兼容JDK1.2以前的自定义类加载器</strong>，添加了一个findClass()方法，（这里有点晕）</p><p><strong>2.模型的缺陷导致</strong>：若基础类（本由启动类加载器加载）要调用回用户代码（由应用程序加载器加载）咋办（启动类加载器不认ClassPath路径）。<br>比如：JNDI(命名和目录接口) 服务，目的是对资源进行集中和查找，需要调用 JNDI接口提供者的代码。</p><p>不优雅的设计：<strong>线程上下文类加载器</strong>，线程若未设置则从父类继承，全局都没有则默认为应用程序类加载器。<br>使用：基础类程序（比如JNDI）可以<strong>使用这个加载器（未设定时为应用程序加载器）</strong>加载所需要的SPI代码，也就是父类加载器请亲子类加载器去完成类加载。<br>在JNDI、JDBC 、JCE、JAXB和JBI</p><p>3.<strong>为了追求程序动态性：代码热替换（不关机的替换），模块热部署。</strong></p><p>JSR-291(Java 规范提案) (即OSGi R4.2)时目前Java模块化的标准，实现模块化的热部署的关键是其自定义类加载器机制的实现。每一个程序模块（Bundle）都有一个自己的类加载器。更换bundle时连同类加载器一起替换掉以实现热替换。</p><p>此时，类加载器不是双亲委派的树结构，而是网结构（即有双亲委派模式，又有平行的类加载器）</p><h1 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h1><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>用处：屏蔽各种硬件和操作系统的内存访问差异，让Java程序达到一致性。<br><img src="http://paxblmm0h.bkt.clouddn.com/%E7%BA%BF%E7%A8%8B%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E3%80%81%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E4%B8%89%E8%80%85%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="此处输入图片的描述"><br>主内存：主要对应堆中对象实例数据部分。<br>工作内存：对应虚拟机栈的部分区域。<br>虚拟机回让工作内存有限存储于 寄存器和高速缓存中，因为主要访问读写的时工作内存。</p><h2 id="volatile型变量"><a href="#volatile型变量" class="headerlink" title="volatile型变量"></a>volatile型变量</h2><p>轻量级同步机制，可保证可见性但是不能保证原子性。其在各个线程的工作内存中不存在一致性问题（在线程中不同，但是每次使用前要刷新）。但是不能保证原子性。</p><h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>指的是系统为线程分配处理器使用权的过程。<br><strong>1.协同式调度：</strong>执行时间由线程本身控制。执行完自己后再通知系统切换<br>好处：实现简单，操作可知。<br>坏处：线程执行时间不可控，阻塞问题难以解决</p><p><strong>2.抢占式调度：</strong>执行时间由系统来分配，线程的切换由系统控制，可以辅助设置线程优先级别，越高越易被系统执行。</p><h1 id="第13章-线程安全与锁优化"><a href="#第13章-线程安全与锁优化" class="headerlink" title="第13章 线程安全与锁优化"></a>第13章 线程安全与锁优化</h1><p>定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行格外的同步，或者在调用方法进行任何其他的协调操作，都能得到正确的结果，那么是线程安全的。</p><h2 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h2><p>1.互斥同步<br><strong>synchronized：</strong>JVM层面，经过编译后会在同步块前后产生monitorEnter和monitorExit两个字节码指令。根据虚拟机规范执行此Enter指令时，首先获取对象锁，获取到则计数器由0变1，获取失败则线程阻塞。<br>阻塞和唤醒一个线程，需要操作系统来帮忙，从用户态转换到核心态，需要消耗很多的处理器时间，所以synchronized是一个<strong>重量级的锁</strong>。<br><strong>ReentrantLock  三个新特性</strong><br><strong>等待可中断：</strong>lock可设置等待参数，没获取到则放弃获取<br><strong>可实现公平锁：</strong>同一个锁，线程按照排队顺序来获取。ReentrantLock虽然也是非公平，但是可以通过带布尔的构造函数显示公平<br><strong>可绑定多条件：</strong></p><p>Class文件的具体组成结构：类的版本、字段、方法、接口，常量池。</p>]]></content>
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识点整理 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>操作系统面试题及相关原理</title>
      <link href="/2018/02/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/"/>
      <url>/2018/02/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="操作系统面试题及相关原理"><a href="#操作系统面试题及相关原理" class="headerlink" title="操作系统面试题及相关原理"></a>操作系统面试题及相关原理</h1><h2 id="linux查看进程"><a href="#linux查看进程" class="headerlink" title="linux查看进程"></a>linux查看进程</h2><p>1.查进程<br>    ps 命令查找与进程相关的PID号：</p><pre><code>ps a 显示现行终端机下的**所有程序**，包括其他用户的程序。ps -A 显示**所有**程序。ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。最常用的方法是ps aux,然后再通过管道使用grep命令过滤查找特定的进程,然后再对特定的进程进行操作。`ps aux | grep   program_filter_word,ps -ef |grep tomcat</code></pre><p><code>ps -ef|grep java</code><br><code>ps -ef|grep java|grep -v grep</code> 显示出所有的java进程，去处掉当前的grep进程。</p><h2 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h2><p><code>netstat</code>命令各个参数说明如下：</p><pre><code>-t : 指明显示TCP端口-u : 指明显示UDP端口-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。-n : 不进行DNS轮询，显示IP(可以加速操作)</code></pre><p>即可显示当前服务器上所有端口及进程服务，于grep结合可查看某个具体端口及服务情况··</p><p>netstat -ntlp    //查看当前所有tcp端口·<br>netstat -ntulp |grep 80   //查看所有80端口使用情况·<br>netstat -an | grep 3306   //查看所有3306端口使用情况·</p><pre><code>`netstat  -lanp` 查看一台服务器上面哪些服务及端口ps -ef |grep mysqld查看一个**服务有几个端口**。比如要查看mysqldnetstat -pnt |grep :3306 |wc 查看某一端口的**连接数量**,比如3306端口netstat -anp |grep 3306    查看某一端口的连接客户端IP 比如3306端口</code></pre><p>netstat -an 查看网络端口 </p><p>lsof -i :port，使用lsof -i :port就能看见所指定端口运行的程序，同时还有当前连接。 </p><p>nmap 端口扫描<br>netstat -nupl  (UDP类型的端口)<br>netstat -ntpl  (TCP类型的端口)<br>netstat -anp <strong>显示系统端口使用情况</strong></p><h2 id="搜索文件中匹配符"><a href="#搜索文件中匹配符" class="headerlink" title="搜索文件中匹配符"></a>搜索文件中匹配符</h2><pre><code>命令：grep 格式：grep [option] pattern filenames 功能：逐行搜索所指定的文件或标准输入，并显示匹配模式的每一行。 选项：-i    匹配时忽略大小写 </code></pre><p>  -v 找出模式失配的行 </p><pre><code>例如：% grep -i &apos;java*&apos; ./test/run.sh </code></pre><h2 id="寻找文件"><a href="#寻找文件" class="headerlink" title="寻找文件"></a>寻找文件</h2><pre><code>命令：find 格式：find pathname [option] expression 功能：在 所给的路经名下 寻找符合表达式相匹配的文件。 选项：-name     表示文件名       -user     用户名，选取该用户所属的文件       -size     按大小查找，以block为单位，一个block是512B       -mtime n  按最后一次修改时间查找，选取n天内被修改的文件 </code></pre><p>  -perm     按权限查找<br>          -type     按文件类型查找<br>  -atime    按最后一次访问时间查找 </p><pre><code>例如：% find ./ -name &apos;*abc*&apos; -print </code></pre><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><pre><code>命令：ftp (file transfer program) 格式：ftp hostname 功能：网络文件传输及远程操作。 </code></pre><h2 id="线程进程区别"><a href="#线程进程区别" class="headerlink" title="线程进程区别"></a>线程进程区别</h2><p>实现并发的方式有多种：比如<strong>多进程</strong>、<strong>多线程</strong>、<strong>IO多路复用</strong>。</p><p>一句话总结：进程关注资源分配，线程关注程序运行。<br>Why：因为CPU与其他PC资源速度不协调， 为了实现“同时执行”，  计算机需要进程来 保存和切换上下文。 </p><p>可以类比于火车 和 车厢。</p><p><strong>进程：关注的是内存资源的管理与分配</strong><br>进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。<br>程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。</p><p>Linux系统函数fork()可以在父进程中创建一个子进程，但是成本昂贵<br>父进程：负责监控请求的到来，交由子进程处理<br>子进程：多个 处理多个请求</p><p><strong>线程：关注的是系统的调度，cpu的使用</strong><br>线程是程序执行时的<strong>最小单位</strong>，它是进程的一个<strong>执行流（也就是一系列的操作）</strong>，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。<br>线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。</p><h2 id="线程和进程de区别和优劣呢？"><a href="#线程和进程de区别和优劣呢？" class="headerlink" title="线程和进程de区别和优劣呢？"></a>线程和进程de区别和优劣呢？</h2><p>原因：！！区别完全由地址空间造成，进程地址不同，线程用进程下的地址空间。</p><ul><li>进程是<strong>资源分配</strong>的最小单位，线程是<strong>程序执行</strong>的最小单位。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它<strong>分配地址空间，建立数据表(所以说是资源分配最小单位）</strong>来维护代码段、堆栈段和数据段，这种操作非常<strong>昂贵</strong>。     而线程是<strong>共享进程中的数据的，使用相同的地址空间</strong>，因此CPU切换一个线程的花费远比进程要小很多（在一个相同地址空间切换自然轻松），同时创建一个线程的开销也比进程要小很多。</li><li>线程之间的通信更方便，切换更快，同一进程下的<strong>线程共享全局变量、静态变量</strong>等数据，而进程之间的通信需要以通信的方式（IPC)进行。</li><li>多进程程序<strong>更健壮</strong>。多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己<strong>独立的地址空间</strong>。</li></ul><h2 id="五种进程通信（IPC，InterProcess-Communication）的方式"><a href="#五种进程通信（IPC，InterProcess-Communication）的方式" class="headerlink" title="五种进程通信（IPC，InterProcess Communication）的方式"></a>五种进程通信（IPC，InterProcess Communication）的方式</h2><p>管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket和Streams（这俩支持不同主机之间进程IPC）</p><p><strong>一、管道（无名管道）</strong><br>管道，通常指<strong>无名管道</strong>，是 UNIX 系统IPC最古老的形式。</p><p><strong>1、特点：</strong></p><ul><li>半双工（数据只能在一个方向上流动），具有固定的读端和写端。</li><li>只能用于具有<strong>亲缘关系的进程</strong>之间的通信（也是父子进程或者兄弟进程之间）。因为子进程继承父继承的<strong>文件描述符</strong>，除了父子进程，其他进程不知道fd的值，所以通常调用pipe的进程接着调用fork，在父子之间通信。</li><li>可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write<br>等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。</li></ul><p><strong>二、FIFO（命名管道）</strong><br>命名管道，它是一种文件类型。</p><p><strong>1、特点</strong></p><ul><li>可以在<strong>无关的进程</strong>之间交换数据，与无名管道不同。</li><li>FIFO有<strong>路径名</strong>与之相关联，它以一种<strong>特殊设备文件形式</strong>存在于文件系统中。</li></ul><p>FIFO的通信方式类似于<strong>在进程中使用文件来传输数据</strong>，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。</p><p><strong>三、消息队列</strong><br>消息队列，是<strong>消息的链接表</strong>，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。<br><strong>1、特点</strong></p><ul><li>面向记录，其中的<strong>消息具有特定的格式</strong>以及特定的优先级。</li><li>消息队列<strong>独立于</strong>发送与接收进程。进程终止时，消息队列及其内容并不会被删除。(管道不同，进程终止管道内容删除）</li><li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的<strong>类型</strong>读取。</li></ul><p><strong>四、信号量（用于同步不用于存储）</strong><br>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个<strong>计数器</strong>。信号量用于实现进程间的<strong>互斥与同步</strong>，而不是用于存储进程间通信数据。</p><p><strong>1、特点</strong></p><ul><li>用于进程间同步，若要在进程间传递数据需要结合共享内存。</li><li>基于操作系统的 PV 操作（信号量的处理相关，P表示通过的意思，V表示释放的意思），程序对信号量的操作都是原子操作。</li><li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。</li><li>支持信号量组。</li></ul><p><strong>五、共享内存</strong><br>共享内存（Shared Memory），指两个或多个进程<strong>共享一个给定的存储区</strong>。</p><p><strong>1、特点</strong></p><ul><li><strong>最快</strong>的IPC，因为进程是直接对内存进行存取。</li><li>因为多个进程可以同时操作，所以<strong>需要进行同步</strong>。</li><li>信号量+共享内存 通常结合在一起使用，信号量<strong>用来同步</strong>对共享内存的访问。</li></ul><p><strong>例子</strong><br>使用【共享内存+信号量+消息队列】的组合来实现服务器进程与客户进程间的通信。<br>共享内存用来<strong>传递数据</strong>；信号量用来<strong>同步</strong>；消息队列用来 在客户端修改了共享内存后 <strong>通知服务器读取</strong>。</p><h2 id="孤儿进程与僵尸进程"><a href="#孤儿进程与僵尸进程" class="headerlink" title="孤儿进程与僵尸进程"></a>孤儿进程与僵尸进程</h2><p><strong>父进程→子进程→新的进程</strong><br>子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束（生出来就管不了了）。<br>当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。<strong>（状态收集:电话联系）</strong></p><p><strong>孤儿进程：</strong>一个父进程退出，而它的一个或<strong>多个子进程还在运行</strong>，那么那些子进程将成为孤儿进程。孤儿进程将被<strong>init进程(进程号为1</strong>)所<strong>收养</strong>，并由init进程对它们完成状态收集工作。</p><p><strong>僵尸进程：</strong>一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。（子进程已死，父进程都没联系儿子，都不知道他死了，跟系统说还活着）<br>　　<br><strong>危害：</strong><br><strong>孤儿危害：</strong>联系孤儿进程的重任就落到了init进程身上，init进程就好像是一个民政局，专门负责孤儿的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。因此孤儿进程并不会有什么危害。<br><strong>僵尸危害：</strong>如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其<strong>进程号</strong>就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有<strong>可用的进程号</strong>而导致系统不能产生新的进程。</p><p><strong>原因：有僵尸召唤者</strong><br>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是<strong>留下一个称为僵尸进程(Zombie)的数据结构</strong>，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。<br>如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p><p><strong>解决：杀僵尸不治本，要杀死僵尸召唤者</strong><br>就像僵尸片我们不能怪僵尸，要怪召唤僵尸的人。僵尸进程也应该归罪于父进程没有善后（没有调用wait / waitpid），所以我们只要消灭父进程，让他不要继续生产僵尸。僵尸也会因为没了父亲变为孤儿进程，被init消灭。</p><p>死锁（代码实现）<br>作业调度方式<br>协程</p><p>怎么实现管道，为什么管道都是用于父子进程或兄弟进程（fork机制的原因），我说了子进程完全继承了父进程的内容，又问我信号会继承吗，我说是的，他说真的吗，难道有什么问题吗（信号掩码之类继承，但是pending的信号就直接丢了。）</p><p>IO复用很熟吧，说说怎么用的</p><p>怎么看进程占用的系统资源，<br>怎么用命令给一个文件里面的数字按次数排序</p>]]></content>
      
      <categories>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 整理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式沉思录（十）之 组合模式</title>
      <link href="/2017/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E5%8D%81%EF%BC%89%E4%B9%8B%20%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E5%8D%81%EF%BC%89%E4%B9%8B%20%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式沉思录（十）之-组合模式"><a href="#设计模式沉思录（十）之-组合模式" class="headerlink" title="设计模式沉思录（十）之 组合模式"></a>设计模式沉思录（十）之 组合模式</h1><p>设计模式目录</p><h1 id="组合模式（Composite-Pattern）"><a href="#组合模式（Composite-Pattern）" class="headerlink" title="组合模式（Composite Pattern）"></a>组合模式（Composite Pattern）</h1><p>，又叫<strong>部分整体模式</strong>，是用于把一组相似的对象当作一个单一的对象。组合模式<strong>依据树形结构</strong>来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><p>本文整理自四人帮著作：<strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong></p><p>这种模式创建了一个包含自己对象组的类。该类提供了<strong>修改相同对象组</strong>的方式。</p><p>我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>概念：</strong>把多个对象组成树状结构来表示局部与整体，这样用户可以一样的对待单个对象和对象的组合。（维基百科）</p><p><strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像<strong>处理简单元素一样来处理复杂元素</strong>，从而使得客户程序与复杂元素的内部结构解耦。</p><p><strong>何时使用：</strong><br>1、您想表示对象的部分-整体层次结构（树形结构）。<br>2、您希望用户 忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。</p><p><strong>关键代码：</strong>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p><p><strong>应用实例：</strong><br>1、算术表达式包括操作数、操作符和<strong>另一个操作数</strong>，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 例如：1 + (2+6)<br>2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p><p><strong>优点：</strong> 1、高层模块调用简单。 2、节点自由增加。</p><p><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了<strong>依赖倒置原则</strong>(高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象)。</p><p><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。</p><p><strong>注意事项：</strong>定义时为具体类。,这也是缺点所在，没有抽象出来</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。<br><img src="http://www.runoob.com/wp-content/uploads/2014/08/composite_pattern_uml_diagram.jpg" alt="此处输入图片的描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;pre <span class="class"><span class="keyword">class</span></span>=<span class="string">"prettyprint"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates;<span class="comment">//此人的下属列表</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">//构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,String dept, <span class="keyword">int</span> sal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.dept = dept;</span><br><span class="line">      <span class="keyword">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getSubordinates</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">"Employee :[ Name : "</span>+ name </span><br><span class="line">      +<span class="string">", dept : "</span>+ dept + <span class="string">", salary :"</span></span><br><span class="line">      + salary+<span class="string">" ]"</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤 2<br>使用 Employee 类来创建和 打印员工 的层次结构。<br>每个人的都有一个下属属性。里面存放着包含的下属关系。<br>便利的画很简单</p><p>缺点：通过具体的类，添加到属性中，而没有抽象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePat</span> <span class="title">ternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Employee CEO = <span class="keyword">new</span> Employee(<span class="string">"John"</span>,<span class="string">"CEO"</span>, <span class="number">30000</span>);</span><br><span class="line"> </span><br><span class="line">      Employee headSales = <span class="keyword">new</span> Employee(<span class="string">"Robert"</span>,<span class="string">"Head Sales"</span>, <span class="number">20000</span>);</span><br><span class="line"> </span><br><span class="line">      Employee headMarketing = <span class="keyword">new</span> Employee(<span class="string">"Michel"</span>,<span class="string">"Head Marketing"</span>, <span class="number">20000</span>);</span><br><span class="line"> </span><br><span class="line">      Employee clerk1 = <span class="keyword">new</span> Employee(<span class="string">"Laura"</span>,<span class="string">"Marketing"</span>, <span class="number">10000</span>);</span><br><span class="line">      Employee clerk2 = <span class="keyword">new</span> Employee(<span class="string">"Bob"</span>,<span class="string">"Marketing"</span>, <span class="number">10000</span>);</span><br><span class="line"> </span><br><span class="line">      Employee salesExecutive1 = <span class="keyword">new</span> Employee(<span class="string">"Richard"</span>,<span class="string">"Sales"</span>, <span class="number">10000</span>);</span><br><span class="line">      Employee salesExecutive2 = <span class="keyword">new</span> Employee(<span class="string">"Rob"</span>,<span class="string">"Sales"</span>, <span class="number">10000</span>);</span><br><span class="line"> </span><br><span class="line">      CEO.add(headSales);</span><br><span class="line">      CEO.add(headMarketing);</span><br><span class="line"> </span><br><span class="line">      headSales.add(salesExecutive1);</span><br><span class="line">      headSales.add(salesExecutive2);</span><br><span class="line"> </span><br><span class="line">      headMarketing.add(clerk1);</span><br><span class="line">      headMarketing.add(clerk2);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//打印该组织的所有员工</span></span><br><span class="line">      System.out.println(CEO); </span><br><span class="line">      <span class="keyword">for</span> (Employee headEmployee : CEO.getSubordinates()) &#123;</span><br><span class="line">         System.out.println(headEmployee);</span><br><span class="line">         <span class="keyword">for</span> (Employee employee : headEmployee.getSubordinates()) &#123;</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对一开始的那个树进行分析，这课数有叶子节点和树枝节点，他们的共同之处是我们都要获取他们的信息，树枝节点比叶子节点多的东西是有一个孩子节点的定义，所以我们定义了一个CEO类，其中有ADD方法，这是叶子和树枝的共有方法。</p><p>在树枝节点中，我们添加了一个List类型的subordinate下属列表，然后添加了添加子节点，删除子节点，获取子节点列表的方法。这就是一个组合模式的应用，把这些对象表示成了部分-整体结构。</p><p>我们定义了一个静态的方法，来对这棵树进行遍历、我们只需要知道根节点就能知道所有的其他的对象，这样，我们就把单个对象和组合起来的对象等同对待。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>组合模式，对于高层模块来说，调用局部的元素和调用整体的元素，没有任何区别。  高层模块不用关心这是一个单个对象还是一个组合结构，所以在这个设计下，我们很容易进行节点的扩展。方便维护。</p><p>但是他的缺点也很明显，不符合依赖倒置原则。我们在进行构造的时候，对于树枝节点和叶子节点，需要声明为具体的类来进行构造，对于这种情况，我们可以使用所谓透明的组合模式，就是在原生的组合模式的基础上，完全抹去叶子节点和树枝节点的区别，所有的节点不分是叶子还是树枝。<strong>都有孩子节点这一个属性，只不过孩子节点个数是0的时候，就认为他是一个叶子节点。</strong>这种模式如果处理不好，很容易出现安全问题。我们通常把<strong>区分</strong>叶子节点和树枝节点的组合模式叫安全模式，不区分的叫透明模式。</p>]]></content>
      
      <categories>
          
          <category> 原理理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式沉思录（九）之 装饰器模式</title>
      <link href="/2017/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8B%20%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/08/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E4%B9%9D%EF%BC%89%E4%B9%8B%20%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式沉思录（九）之-装饰器模式"><a href="#设计模式沉思录（九）之-装饰器模式" class="headerlink" title="设计模式沉思录（九）之 装饰器模式"></a>设计模式沉思录（九）之 装饰器模式</h1><h1 id="装饰器模式（Decorator-Pattern）"><a href="#装饰器模式（Decorator-Pattern）" class="headerlink" title="装饰器模式（Decorator Pattern）"></a>装饰器模式（Decorator Pattern）</h1><p>允许向一个现有的对象<strong>添加新的功能</strong>，同时又<strong>不改变其结构</strong>。这种类型的设计模式属于结构型模式，它是作为现有的类的一个<strong>包装</strong>。</p><p>动态地给一个对象附加额外的职责。装饰者为功能的扩展提供了一个比使用子类继承更加灵活的选择</p><p>本文整理自四人帮著作：<strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong></p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式<strong>相比生成子类更为灵活</strong>。<br>在一个功能的基础上添加新功能，除了继承，我们还可以使用组合。即把<strong>A类当做B类的一个属性，在B类中使用A类的方法。</strong>从而实现B类对A类功能的继承。这种组合的模式比继承更加的灵活。这个就是装饰者模式的基础。</p><p><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><p><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。</p><p><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。</p><p><strong>关键代码：</strong> 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p><p><strong>应用实例：</strong><br>1.IO流中。在InputStream外面套上一层InputStreamReader,再套上一层BufferedReader。</p><p><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。<br><strong>缺点：</strong>多层装饰比较复杂。</p><p>使用场景： 1、扩展一个类的功能。 2、<strong>动态增加功能，动态撤销</strong>。</p><p>注意事项：可代替继承。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们将创建一个 Shape <strong>接口</strong>和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的<strong>抽象装饰类</strong> ShapeDecorator，并把 Shape 对象作为它的实例变量。</p><p>RedShapeDecorator 是实现了 ShapeDecorator 的实体类。</p><h2 id="步骤-1-创建shape接口："><a href="#步骤-1-创建shape接口：" class="headerlink" title="步骤 1 创建shape接口："></a>步骤 1 创建shape接口：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤-2-创建实现接口的-实体类Rectangle和Circle。"><a href="#步骤-2-创建实现接口的-实体类Rectangle和Circle。" class="headerlink" title="步骤 2 创建实现接口的 实体类Rectangle和Circle。"></a>步骤 2 创建实现接口的 实体类Rectangle和Circle。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Shape: Rectangle"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Circle.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Shape: Circle"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤-3-关键）创建实现了-Shape-接口的-抽象装饰类"><a href="#步骤-3-关键）创建实现了-Shape-接口的-抽象装饰类" class="headerlink" title="步骤 3 (关键）创建实现了 Shape 接口的 抽象装饰类"></a>步骤 3 <strong>(关键）</strong>创建实现了 Shape 接口的 抽象装饰类</h2><p>内部有个装饰对象属性，构造时需引入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeDecorator</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> Shape decoratedShape;<span class="comment">//内部有个装饰对象属性</span></span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ShapeDecorator</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.decoratedShape = decoratedShape;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">      decoratedShape.draw();</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤-4-关键）创建扩展了-ShapeDecorator-类的-实体装饰类。"><a href="#步骤-4-关键）创建扩展了-ShapeDecorator-类的-实体装饰类。" class="headerlink" title="步骤 4 (关键）创建扩展了 ShapeDecorator 类的 实体装饰类。"></a>步骤 4 <strong>(关键）</strong>创建扩展了 ShapeDecorator 类的 实体装饰类。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> <span class="keyword">extends</span> <span class="title">ShapeDecorator</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RedShapeDecorator</span><span class="params">(Shape decoratedShape)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(decoratedShape);<span class="comment">//传入shape构造 带有shape属性</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      decoratedShape.draw();         </span><br><span class="line">      setRedBorder(decoratedShape);<span class="comment">//带有redBorder</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setRedBorder</span><span class="params">(Shape decoratedShape)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Border Color: Red"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤-5-使用-RedShapeDecorator-来装饰-Shape-对象。"><a href="#步骤-5-使用-RedShapeDecorator-来装饰-Shape-对象。" class="headerlink" title="步骤 5  使用 RedShapeDecorator 来装饰 Shape 对象。"></a>步骤 5  使用 RedShapeDecorator 来装饰 Shape 对象。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      Shape circle = <span class="keyword">new</span> Circle();</span><br><span class="line"> </span><br><span class="line">      Shape redCircle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Circle());<span class="comment">//通过传入shape到装饰器构造一个修饰后的redCir</span></span><br><span class="line"> </span><br><span class="line">      Shape redRectangle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Rectangle());</span><br><span class="line">      System.out.println(<span class="string">"Circle with normal border"</span>);</span><br><span class="line">      circle.draw();</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">"\nCircle of red border"</span>);</span><br><span class="line">      redCircle.draw();</span><br><span class="line"> </span><br><span class="line">      System.out.println(<span class="string">"\nRectangle of red border"</span>);</span><br><span class="line">      redRectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>一般情况：新建shape接口，circle接口继承shape接口，redcirle实体类实现circle接口</p><p>装饰器模式：<br>1.新建shape接口，<br>2.抽象类ShapeDecorator实现shape接口，并且其构造方法接收shape实例。<br>3.RedShapeDecorator实体装饰类继承ShapeDecorator 类（不同的实现类可实现不同的，继承自shape的方法，以体现诸如color等特点）</p><p>优点：若我想修改color，则只需要修改RedShapeDecorator，不用修改shape。<br>同样，若我只想修改shape，也不用去修改color。<br><img src="https://wangjingxin.top/wp-content/uploads/2016/10/15-1.png" alt="此处输入图片的描述"></p><ul><li>Component接口</li></ul><p>这个是一个抽象组件，是原始的最核心的接口，是被装饰者的抽象</p><ul><li><p>ConcreteComponent类。</p><p>这个类实现了Component接口，是<strong>具体的</strong>被装饰组件。在这个是最核心，最原始，最基本的组件。是具体的被装饰的组件。他实现了Component接口中的核心Operation方法。</p></li><li><p>Decorator抽象类。</p><p>这类一般是个抽象类。是所有装饰者的父类，他实现了Component接口。它里面有一个<strong>私有的Component类型的属性！！！</strong>。在构造方法中初始化这个属性。在实现Component的Operation方法的时候调用的是他的Component属性的Operation方法。这个抽象类中这个组件就像上面的Decorator。</p></li><li><p>ConcreteDecorator类 装饰者具体实现类。</p><p>这个是具体的装饰者类。继承自Decorator类。并且在每一个ConcreteDecorator里中有一个<strong>私有的新功能方法</strong>。然后在重写父类的Operation方法的时候。可以根据<strong>新添加的方法的执行位置</strong>，在super.Operation()之前或者之后<strong>调用本类的修饰方法（就可以体现清除不同实现的区别了）</strong>。灵活的向被修饰的类中添加新功能。</p></li></ul><p><code>BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(path))));</code><br>与<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shape redRectangle = <span class="keyword">new</span> RedShapeDecorator(<span class="keyword">new</span> Circle());</span><br></pre></td></tr></table></figure></p><p>类似</p><p> IO流是 在path下的File中读出数据封装成一个FileInputStream流，然后被InputStreamReader装饰成一个Reader流，然后被BufferedReader装饰成为一个带缓冲的Reader。每一层封装都是对原始流的一次装饰，动态的 并且独立地 向原始的文件流中添加职责与功能。最后成为一种我们可以很方便的处理的流。</p>]]></content>
      
      <categories>
          
          <category> 原理理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式沉思录（七）之 过滤器模式</title>
      <link href="/2017/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%20%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E4%B8%83%EF%BC%89%E4%B9%8B%20%E8%BF%87%E6%BB%A4%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式沉思录（七）之-过滤器模式"><a href="#设计模式沉思录（七）之-过滤器模式" class="headerlink" title="设计模式沉思录（七）之 过滤器模式"></a>设计模式沉思录（七）之 过滤器模式</h1><p>设计模式目录</p><p>过滤器模式（Filter Pattern）<br>或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。</p><p>本文整理自四人帮著作：<strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person 对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。</p><p>实现起来很简单。设计过滤器接口，带有过滤方法，能将list对象过滤到一个新的list并返回，多重过滤器实现起来也很简单。在过滤器内部使用单个过滤器多次即可。</p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建一个类，在该类上应用标准。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String gender;</span><br><span class="line">   <span class="keyword">private</span> String maritalStatus;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,String gender,String maritalStatus)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.gender = gender;</span><br><span class="line">      <span class="keyword">this</span>.maritalStatus = maritalStatus;    </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> gender;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getMaritalStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> maritalStatus;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>为标准（Criteria）创建一个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><p>创建实现了 Criteria 接口的实体类。CriteriaMale</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriteriaMale</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">      List&lt;Person&gt; malePersons = <span class="keyword">new</span> ArrayList&lt;Person&gt;(); </span><br><span class="line">      <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">         <span class="keyword">if</span>(person.getGender().equalsIgnoreCase(<span class="string">"MALE"</span>))&#123;</span><br><span class="line">            malePersons.add(person);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> malePersons;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单身狗过滤器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CriteriaSingle</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">      List&lt;Person&gt; singlePersons = <span class="keyword">new</span> ArrayList&lt;Person&gt;(); </span><br><span class="line">      <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">         <span class="keyword">if</span>(person.getMaritalStatus().equalsIgnoreCase(<span class="string">"SINGLE"</span>))&#123;</span><br><span class="line">            singlePersons.add(person);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> singlePersons;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>组合起来就是~~~~男性单生狗过滤器！！！！！！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">AndCriteria.java</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndCriteria</span> <span class="keyword">implements</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> Criteria criteria;<span class="comment">//过滤器1</span></span><br><span class="line">   <span class="keyword">private</span> Criteria otherCriteria;<span class="comment">//过滤器2</span></span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">AndCriteria</span><span class="params">(Criteria criteria, Criteria otherCriteria)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.criteria = criteria;</span><br><span class="line">      <span class="keyword">this</span>.otherCriteria = otherCriteria; </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">meetCriteria</span><span class="params">(List&lt;Person&gt; persons)</span> </span>&#123;</span><br><span class="line">      List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);     <span class="comment">//过滤器1过滤一遍</span></span><br><span class="line">      <span class="keyword">return</span> otherCriteria.meetCriteria(firstCriteriaPersons);<span class="comment">//过滤器2过滤一遍</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后得到的就是男性单生狗啦。。至于女性，那叫单身贵族。O(∩_∩)O</p>]]></content>
      
      <categories>
          
          <category> 原理理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式沉思录（六）之 适配器模式</title>
      <link href="/2017/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%20%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%20%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式沉思录（六）之-适配器模式"><a href="#设计模式沉思录（六）之-适配器模式" class="headerlink" title="设计模式沉思录（六）之 适配器模式"></a>设计模式沉思录（六）之 适配器模式</h1><p>本文整理自四人帮著作：<strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong></p><p>适配器模式<br>适配器模式（Adapter Pattern）是作为<strong>两个不兼容的接口之间的桥梁</strong>。</p><p>这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><p><strong>概念：</strong>将一个类的接口转接成用户所期待的。一个适配使得因接口不兼容而不能在一起工作的类工作在一起，做法是将类自己的接口包裹在一个已存在的类中。（维基百科）</p><p>举个真实的例子，<strong>读卡器是作为内存卡和笔记本之间的适配器</strong>。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>意图：</strong> 将一个类的接口<strong>转换</strong>成客户希望的另外一个接口。适配器模式使得原本由于<strong>接口不兼容</strong>而不能一起工作的那些类可以一起工作。</p><p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。<br>（我想用电脑读sd卡，但是接口不通，所以要一个适配器）</p><p><strong>何时使用：</strong><br>1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。<br>3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个<strong>飞虎</strong>，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p><p><strong>如何解决</strong>：继承或<strong>依赖</strong>（推荐）。</p><p><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。</p><p><strong>应用实例：</strong><br>2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。<br>将枚举接口转换为可迭代接口</p><p>3、在 LINUX 上运行 WINDOWS 程序。<br>4、JAVA 中的 jdbc。</p><p><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p><p><strong>缺点：</strong><br>1、过多地使用适配器，会让<strong>系统非常零乱</strong>，不易整体进行把握。比如，明明看到<strong>调用的是 A 接口</strong>，其实<strong>内部被适配成了 B 接口的实现</strong>，一个系统如果太多出现这种情况，无异于一场灾难。因此如果<strong>不是很有必要，可以不使用适配器，而是直接对系统进行重构</strong>。<br>2.由于 JAVA 至多继承一个类，所以至多<strong>只能适配一个适配者类</strong>，而且目标类必须是抽象类。</p><p><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p><strong>注意事项：</strong>适配器<strong>不是在详细设计时添加的</strong>，而是解决正在服役的项目的问题。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。</p><p>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer 可以播放 mp3 格式的音频文件。</p><p>我们还有另一个接口 AdvancedMediaPlayer （升级版媒体播放器接口）和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4 格式的文件。</p><p>我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的<strong>适配器类 MediaAdapter</strong>，并使用 AdvancedMediaPlayer 对象来播放所需的格式。</p><p>AudioPlayer 使用适配器类 MediaAdapter <strong>传递</strong>所需的音频类型，不需要知道能播放所需格式音频的实际类。AdapterPatternDemo，我们的演示类使用 AudioPlayer 类来播放各种格式。</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/08/adapter_pattern_uml_diagram.jpg" alt="此处输入图片的描述"></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><p>步骤1：为媒体播放器 和更高级的媒体播放器创建接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123; </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤 2 创建实现了 AdvancedMediaPlayer 接口的实体类VlcPlayer和Mp4Player。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VlcPlayer</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Playing vlc file. Name: "</span>+ fileName);      </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//什么也不做</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4Player</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//什么也不做</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Playing mp4 file. Name: "</span>+ fileName);      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>步骤 3 (关键！！！）</strong>创建实现了 MediaPlayer 接口的<strong>适配器类MediaAdapter</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适配器实现老接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaAdapter</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   AdvancedMediaPlayer advancedMusicPlayer;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//用老播放器的构造方法，但是内部实现实际是根据参数（播放器名）创建了一个新的 更具体的 播放器对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MediaAdapter</span><span class="params">(String audioType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>) )&#123;</span><br><span class="line">         advancedMusicPlayer = <span class="keyword">new</span> VlcPlayer();       </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">         advancedMusicPlayer = <span class="keyword">new</span> Mp4Player();</span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//实现了老播放器的播放功能</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>))&#123;</span><br><span class="line">         advancedMusicPlayer.playVlc(fileName);</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">         advancedMusicPlayer.playMp4(fileName);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>步骤4 <strong>（重点！！！）</strong>创建实现了 MediaPlayer 接口的实体类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   MediaAdapter mediaAdapter; <span class="comment">//这老播放器，内部有个适配器对象，用于播放老播放器无法完成的</span></span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String fileName)</span> </span>&#123;    </span><br><span class="line"> </span><br><span class="line">      <span class="comment">//播放 mp3 音乐文件的内置支持</span></span><br><span class="line">      <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp3"</span>))&#123;</span><br><span class="line">         System.out.println(<span class="string">"Playing mp3 file. Name: "</span>+ fileName);         </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">//mediaAdapter 提供了播放其他文件格式的支持</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>) </span><br><span class="line">         || audioType.equalsIgnoreCase(<span class="string">"mp4"</span>))&#123;</span><br><span class="line">         mediaAdapter = <span class="keyword">new</span> MediaAdapter(audioType);</span><br><span class="line">         mediaAdapter.play(audioType, fileName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Invalid media. "</span>+</span><br><span class="line">            audioType + <span class="string">" format not supported"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 原理理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式沉思录（八）之 桥接(梁）模式</title>
      <link href="/2017/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%20%E6%A1%A5%E6%8E%A5(%E6%A2%81%EF%BC%89%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B2%89%E6%80%9D%E5%BD%95%EF%BC%88%E5%85%AB%EF%BC%89%E4%B9%8B%20%E6%A1%A5%E6%8E%A5(%E6%A2%81%EF%BC%89%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="设计模式沉思录（八）之-桥接-梁）模式"><a href="#设计模式沉思录（八）之-桥接-梁）模式" class="headerlink" title="设计模式沉思录（八）之 桥接(梁）模式"></a>设计模式沉思录（八）之 桥接(梁）模式</h1><p>设计模式目录</p><p>桥接模式<br>桥接（Bridge）是用于把<strong>抽象化</strong>与<strong>实现化</strong>解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的<strong>桥接结构</strong>，来实现二者的解耦。</p><p>本文整理自四人帮著作：<strong>Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）</strong></p><p>这种模式涉及到一个<strong>作为桥接的接口</strong>，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p><p>使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>意图：将<strong>抽象部分</strong>与<strong>实现部分</strong>分离，使它们都可以独立的变化。</p><p>主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题（会产生太多需要的类？？），扩展起来不灵活。</p><p>何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。</p><p>如何解决：把这种多角度分类分离出来，让它们<strong>独立变化</strong>，减少它们之间耦合。</p><p>关键代码：抽象类依赖实现类。</p><p>应用实例：<br>1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</p><p>优点：<br>1、抽象和实现的分离。<br>2、优秀的扩展能力。<br>3、实现细节对客户透明。</p><p>缺点：桥接模式的引入会增加系统的理解与设计难度，由于<strong>聚合关联关系</strong>建立在抽象层，要求开发者针对抽象进行设计与编程。</p><p>使用场景：<br>1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，<font color="#dd0000">避免在两个层次之间建立静态的继承联系</font>，通过桥接模式可以使它们在抽象层建立一个关联关系。<br>2、对于那些<font color="#dd0000">不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统</font>，桥接模式尤为适用。<br>3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。(多维度扩展）</p><p>注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。</p><p>Shape 是一个抽象类，将使用 DrawAPI 的对象。<br>Shape会用到DrawAPI<br>BridgePatternDemo，我们的演示类使用 Shape 类来画出不同颜色的圆。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>你看哪里解耦了呢！这里我们放弃了继承，选择了组合。</p><p>原本思路是让接口Shape去继承DrawAPI接口，然后有个确切的redCircle去实现接口Shape，这样就能覆盖到颜色，和形状两个维度。<br>问题1:当我们需要添加一个颜色蓝色，画出所有图形，怎么办？ 只能给所有的Shape接口都添加上画蓝色方法，之下的实现类也全部添加。</p><p>问题2：当我们需要添加一个形状矩形，要画出所有颜色，怎么办？<br>只能，让rectangle接口继承DrawApi，再实现各种颜色的类。</p><p>为什么会出现这种状况，我明明指向加一个维度，却要修改多个方式。这要是数量多起来了，繁琐程度那还得了。也就是说这两个维度是严重耦合的。改变其中一个，就会受另外一个的影响。那么我们就要把这两个维度分开，让他们解耦。</p><p>我们可以让构造Shape的时候，颜色作为属性的方式存在，这样就能在构造shape的时候通过传入color，而不是用类名来区分。</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/08/bridge_pattern_uml_diagram.jpg" alt="此处输入图片的描述"></p><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><p>创建桥接实现接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;<span class="comment">//画画方法：根据x，y，半径，画圈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><p>创建实现了 DrawAPI 接口的实体桥接实现类。GreenCircle同理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//确定下颜色来，draw方法是带颜色的</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedCircle</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Drawing Circle[ color: red, radius: "</span></span><br><span class="line">         + radius +<span class="string">", x: "</span> +x+<span class="string">", "</span>+ y +<span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h2><p>创建抽象类 Shape</p><p>这个抽象类依赖DrawAPI构造，拥有DrawAPI属性，也就能通过这个属性来明确color<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">Shape</span><span class="params">(DrawAPI drawAPI)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.drawAPI = drawAPI;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><p>创建实现了 Shape 接口的实体类。doaw方法会调用自生drawAPI的drow方法<br>这样就能明确颜色了呢<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> x, y, radius;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> radius, DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(drawAPI);</span><br><span class="line">      <span class="keyword">this</span>.x = x;  </span><br><span class="line">      <span class="keyword">this</span>.y = y;  </span><br><span class="line">      <span class="keyword">this</span>.radius = radius;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      drawAPI.drawCircle(radius,x,y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h2><p>使用 Shape 和 DrawAPI 类画出不同颜色的圆。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgePatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Shape redCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>, <span class="number">10</span>, <span class="keyword">new</span> RedCircle());<span class="comment">//传一个颜色进去</span></span><br><span class="line">      Shape greenCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>, <span class="number">10</span>, <span class="keyword">new</span> GreenCircle());</span><br><span class="line"> </span><br><span class="line">      redCircle.draw();</span><br><span class="line">      greenCircle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 原理理解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql 锁的机制</title>
      <link href="/2017/05/31/%E9%94%81%E7%9A%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/05/31/%E9%94%81%E7%9A%84%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="锁的机制"><a href="#锁的机制" class="headerlink" title="锁的机制"></a>锁的机制</h1><p>数据库锁定机制目的：保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。<br>对于任何一种数据库来说都需要有相应的锁定机制，所以MySQL自然也不能例外。<br>MySQL数据库由于其自身架构的特点，<strong>存在多种数据存储引擎</strong>，每种存储引擎所针对的应用场景特点都不太一样，为了满足各自特定应用场景的需求，每种存储引擎的锁定机制都是<strong>为各自所面对的特定场景而优化设计</strong>，所以各存储引擎的锁定机制也有较大区别。<br>MySQL各存储引擎使用了<strong>三种类型（级别）的锁定机制</strong>：表级锁定，行级锁定和页级锁定。</p><h2 id="表级锁定（table-level）"><a href="#表级锁定（table-level）" class="headerlink" title="表级锁定（table-level）"></a>表级锁定（table-level）</h2><p>表级别的锁定是MySQL各存储引擎中<strong>最大颗粒度的锁定机制</strong>。该锁定机制最大的</p><font color="ff0000" size="4"><strong>特点：实现逻辑非常简单，带来的系统负面影响最小。</strong></font><br>获取锁和释放锁的速度很<strong>快</strong>。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。<br><strong>缺点</strong>：锁定颗粒度大所带来最大的<strong>负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣</strong>。<br>使用表级锁定的主要是<strong>MyISAM，MEMORY，CSV</strong>等一些<strong>非事务性</strong>存储引擎。<br>## 行级锁定（row-level）<br>行级锁定最大的特点就是锁定对象的颗粒度很小，也是目前各大数据库管理软件所实现的<strong>锁定颗粒度最小</strong>的。由于锁定颗粒度很小，所以发生<strong>锁定资源争用的概率也最小</strong>，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。<br>优势：在并发处理能力较强<br>弊端：由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要<strong>做的事情也更多，带来的消耗自然也就更大</strong>了。此外，行级锁定也<strong>最容易发生死锁</strong>。<br>使用行级锁定的主要是<strong>InnoDB</strong>存储引擎。<br>##  页级锁定（page-level）<br>页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。<br>特点：<strong>1.锁定颗粒度介于行级锁定与表级锁之间</strong>，<br><strong>2.获取锁定所需要的资源开销</strong>，<br>以及<strong>所能提供的并发处理能力</strong>也同样是介于上面二者之间。<br><br>另外，页级锁定和行级锁定一样，<strong>会发生死锁</strong>。<br>在数据库实现资源锁定的过程中，随着锁定资源<strong>颗粒度的减小</strong>，锁定相同数据量的数据所需要<strong>消耗的内存数量是越来越多</strong>的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到<strong>锁等待的可能性也会随之降低</strong>，系统整体<strong>并发度</strong>也随之提升。<br>使用页级锁定的主要是<strong>BerkeleyDB</strong>存储引擎。<br><br><font color="ff0000">总的来说，MySQL这3种锁的特性可大致归纳如下：</font><br><strong>表</strong>级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；<br><strong>行</strong>级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；<br><strong>页面</strong>锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<br><br>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。<br># 表级锁定<br>由于MyISAM存储引擎使用的锁定机制完全是由MySQL提供的表级锁定实现，所以下面我们将以MyISAM存储引擎作为示例存储引擎。<br><br>## MySQL表级锁的锁模式<br>MySQL的表级锁有两种模式：<strong>表共享读锁</strong>（Table Read Lock）和<strong>表独占写锁</strong>（Table Write Lock）。<br>锁模式的兼容性：<br>对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；<strong>(读阻塞写）</strong><br>对MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；<strong>（写阻塞读写）</strong><br>MyISAM表的读操作与写操作之间，以及写操作之间是<strong>串行</strong>的。当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新操作。其他线程的读、写操作都会等待，直到锁被释放为止。<br><br>## 如何加表锁（MyISAM引擎）<br>MyISAM在执行查询语句<strong>（SELECT）前</strong>，会<font color="ff0000">自动</font>给涉及的所有表<strong>加读锁</strong>，在执行更新操作<strong>（UPDATE、DELETE、INSERT等）前</strong>，会自动给涉及的表加<strong>写锁</strong>，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。<br><br>## MyISAM表锁优化建议<br>对于MyISAM存储引擎，虽然使用表级锁定在锁定实现的过程中比实现行级锁定或者页级锁所带来的附加成本都要小，锁定本身所消耗的资源也是最少。但是由于锁定的<strong>颗粒度比较大</strong>，所以造成<strong>锁定资源的争用</strong>情况也会比其他的锁定级别都要多，从而在较大程度上会<strong>降低并发处理能力</strong>。所以，在优化MyISAM存储引擎锁定问题的时候，最关键的就是如何让其<strong>提高并发度</strong>。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让<strong>锁定的时间变短</strong>，然后就是让可能并发进行的操作尽可能的并发。<br>（1）查询表级锁争用情况<br>MySQL内部有<strong>两组专门的状态变量</strong>记录系统内部锁资源争用情况：<br><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'table%';</span><br><span class="line">+<span class="comment">----------------------------+---------+</span></span><br><span class="line">| Variable_name              | Value   |</span><br><span class="line">+<span class="comment">----------------------------+---------+</span></span><br><span class="line">| Table_locks_immediate      | 100     |</span><br><span class="line">| Table_locks_waited         | 11      |</span><br><span class="line">+<span class="comment">----------------------------+---------+</span></span><br></pre></td></tr></table></figure><br><br>这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：<br>Table_locks_immediate：产生<strong>表级锁定的次数</strong>；<br>Table_locks_waited：<strong>出现表级锁定争用而发生等待的次数</strong>；<br>两个状态值都是从系统启动后开始记录，出现一次对应的事件则数量加1。如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了。<br><br>（2）缩短锁定时间<br>如何让锁定时间尽可能的短呢？唯一的办法就是让我们的Query执行时间尽可能的短。<br>a)尽两<strong>减少大的复杂Query</strong>，将复杂Query分<strong>拆成几个小的Query</strong>分布进行；<br>b)尽可能的建立<strong>足够高效的索引</strong>，让数据检索更迅速；<br>c)尽量让MyISAM存储引擎的表<strong>只存放必要的信息</strong>，控制字段类型；<br>d)利用合适的机会优化MyISAM表数据文件。<br><br>（3）分离能并行的操作<br>说到MyISAM的表锁，而且是读写互相阻塞的表锁，可能有些人会认为在MyISAM存储引擎的表上就只能是完全的串行化，没办法再并行了。大家不要忘记了，<font color="ff0000">MyISAM的存储引擎还有一个非常有用的特性，那就是Concurrent Insert（并发插入）的特性。</font><p>MyISAM存储引擎有一个控制是否打开Concurrent Insert功能的参数选项：concurrent_insert，可以设置为0，1或者2。三个值的具体说明如下：<br><code>concurrent_insert=2</code>，无论MyISAM表中有没有空洞，都允许在<strong>表尾并发插入记录</strong>；<br><code>concurrent_insert=1</code>，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程<strong>读表的同时</strong>，另一个进程从<strong>表尾插入</strong>记录。这也是<strong>MySQL的默认设置</strong>；<br><code>concurrent_insert=0</code>，不允许并发插入。<br>可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入的锁争用。例如，将concurrent_insert系统变量设为2，总是允许并发插入；同时，通过定期在系统空闲时段执行OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录而产生的中间空洞。</p><p>（4）合理利用读写优先级(写先于读）<br>MyISAM存储引擎的是读写互相阻塞的，那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？<br>答案是<strong>写进程先获得锁</strong>。不仅如此，即使读请求先到锁等待队列，写请求后到，<strong>写锁也会插到读锁请求之前</strong>。<br>这是因为MySQL的表级锁定对于读和写是有不同优先级设定的，默认情况下是写优先级要大于读优先级。<br>所以，如果我们可以根据各自系统环境的差异决定读与写的优先级：<br>通过执行命令<code>SET LOW_PRIORITY_UPDATES=1</code>，使该连接读比写的优先级高。如果我们的<strong>系统是一个以读为主，可以设置此参数，如果以写为主，则不用设置</strong>；<br>通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。<br>虽然上面方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。<br>另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数<code>max_write_lock_count</code>设置一个合适的值，当一个表的<strong>读锁达到这个值后，MySQL就暂时将写请求的优先级降低（有很多读锁的时候，将写请求优先级降低）</strong>，给读进程一定获得锁的机会。<br>这里还要强调一点：一些需要<strong>长时间运行的查询操作</strong>，也会使写进程“饿死”，因此，应用中应尽量避免出现长时间运行的查询操作，不要总想用一条SELECT语句来解决问题，因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在<strong>数据库空闲时段执行</strong>，比如<strong>一些定期统计可以安排在夜间执行。</strong>    </p><h1 id="行级锁定-InnoDB存储引擎"><a href="#行级锁定-InnoDB存储引擎" class="headerlink" title="行级锁定(InnoDB存储引擎)"></a>行级锁定(InnoDB存储引擎)</h1><p>行级锁定不是MySQL自己实现的锁定方式，而是由其他存储引擎自己所实现的，如广为大家所知的<strong>InnoDB存储引擎</strong>，以及MySQL的<strong>分布式存储引擎NDBCluster</strong>等都是实现了行级锁定。考虑到行级锁定君由各个存储引擎自行实现，而且具体实现也各有差别，而InnoDB是目前<strong>事务型存储引擎</strong>中使用最为广泛的存储引擎，所以这里我们就主要分析一下InnoDB的锁定特性。</p><h2 id="InnoDB锁定模式及实现机制"><a href="#InnoDB锁定模式及实现机制" class="headerlink" title="InnoDB锁定模式及实现机制"></a>InnoDB锁定模式及实现机制</h2><p>考虑到行级锁定君由各个存储引擎自行实现，而且具体实现也各有差别，而InnoDB是目前事务型存储引擎中使用最为广泛的存储引擎，所以这里我们就主要分析一下InnoDB的锁定特性。<br>总的来说，InnoDB的锁定机制和Oracle数据库有不少相似之处。InnoDB的行级锁定同样分为两种类型，共享锁和排他锁，而在锁定机制的实现过程中为了让行级锁定和表级锁定共存，InnoDB也同样使用了意向锁（表级锁定）的概念，也就有了<strong>意向共享锁</strong>和<strong>意向排他锁</strong>这两种。</p><p>当一个事务需要给自己需要的某个资源<strong>加锁的时候</strong>，如果遇到一个<strong>共享锁正锁定着</strong>自己需要的资源的时候，自己可以<strong>再加一个共享锁</strong>，不过<strong>不能加排他锁</strong>。但是，如果遇到自己需要锁定的资源已经被一个排他锁占有之后，则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定。<br>共享锁：遇到可继续往上加共享锁。但不可加排他锁。<br>排它锁：遇到后只能等待。</p><p><strong>意向锁的作用</strong>就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源<strong>已经被排他锁占用</strong>的时候，该事务可以在 需要锁定行的表上面<strong>添加一个合适的意向锁</strong>。</p><p>如果自己<strong>需要一个共享锁</strong>，那么就先在表上面添加一个<strong>意向共享锁</strong>。而如果自己需要的是某行（或者某些行）上面添加一个<strong>排他锁</strong>的话，则先在表上面添加一个<strong>意向排他锁</strong>。<br><strong>意向共享锁可以同时并存多个</strong>，但是<strong>意向排他锁同时只能有一个存在</strong>。所以，可以说InnoDB的锁定模式实际上可以分为四种：共享锁（S），排他锁（X），意向共享锁（IS）和意向排他锁（IX），我们可以通过以下表格来总结上面这四种所的共存逻辑关系：<br><img src="https://img-blog.csdn.net/20180619160318738?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phZV9QZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>如果一个事务请求的锁模式与当前的锁<strong>兼容</strong>，InnoDB就将请求的锁授予该事务；反之，如果两者<strong>不兼容</strong>，该事务<strong>就要等待</strong>锁释放。<br>意向锁是InnoDB自动加的，不需用户干预。<br><strong>UPDATE、DELETE和INSERT</strong>语句，InnoDB会自动给涉及数据集加<strong>排他锁（X)</strong>；对于<strong>普通SELECT语句，InnoDB不会加任何锁</strong>；事务可以通过以下语句显示给记录集加共享锁或排他锁。<br>共享锁（S）：LOCK IN SHARE<br>排他锁（X)：FOR UPDATE<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">共享锁（S）：<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line">排他锁（X)：<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure></p><p>用<code>SELECT ... IN SHARE MODE</code>获得共享锁，主要用在需要数据依存关系时来确认某行<strong>记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作</strong>。<br>但是如果当前事务也需要对该记录进行<strong>更新操作</strong>，则很有可能造成死锁，对于<strong>锁定行记录后  需要进行更新</strong>操作的应用，应该使用<strong>SELECT… FOR UPDATE方式获得排他锁。</strong></p><h2 id="InnoDB行锁实现方式（给索引上的索引项加锁）"><a href="#InnoDB行锁实现方式（给索引上的索引项加锁）" class="headerlink" title="InnoDB行锁实现方式（给索引上的索引项加锁）"></a>InnoDB行锁实现方式（给索引上的索引项加锁）</h2><p>InnoDB行锁是通过<strong>给索引上的索引项加锁</strong>来实现的，只有<strong>通过索引条件检索数据</strong>，InnoDB才使用<strong>行级锁</strong>， 否则，InnoDB将使用<strong>表锁</strong><br>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><p>实际例子加以说明：<br>（1）在<strong>不通过索引条件查询</strong>的时候，InnoDB确实使用的是<strong>表锁</strong>，<strong>而不是行锁</strong>。<br>（2）由于MySQL的行锁是<strong>针对索引加的锁</strong>，不是针对记录加的锁，所以虽然是访问<strong>不同行（通过相同索引 查询不同行）</strong>的记录，但是如果是<strong>使用相同的索引键</strong>，是会出现<strong>锁冲突</strong>的。<br>（3）当表有多个索引的时候，<strong>不同的事务可以使用不同的索引锁定不同的行</strong>，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。<br>（4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，<strong>如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引</strong>，这种情况下InnoDB将<strong>使用表锁，而不是行锁</strong>。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p><h2 id="间隙锁（Next-Key锁）（键值在条件范围内但并不存在的记录）"><a href="#间隙锁（Next-Key锁）（键值在条件范围内但并不存在的记录）" class="headerlink" title="间隙锁（Next-Key锁）（键值在条件范围内但并不存在的记录）"></a>间隙锁（Next-Key锁）（键值在条件范围内但并不存在的记录）</h2><p>当我们用<strong>范围条件</strong>而不是<strong>相等条件</strong>检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；<br>对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。<br>例：<br>假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from emp where empid &gt; 100 for update;</span><br></pre></td></tr></table></figure><p>一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，<strong>也会对empid大于101（这些记录并不存在）的“间隙”加锁</strong>。</p><p><strong>InnoDB使用间隙锁的目的：</strong><br>（1）防止幻读，以满足相关隔离级别的要求。对于上面的例子，要是不使用间隙锁，如果<strong>其他事务插入了empid大于100的任何记录</strong>，那么本事务如果<strong>再次执行</strong>上述语句，就会发生幻读；<br>（2）为了满足<strong>其恢复</strong>和<strong>复制</strong>的需要。<br>很显然，在使用范围条件检索并锁定记录时，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候<strong>无法插入</strong>锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害。</p><p>除了间隙锁给InnoDB带来性能的负面影响之外，通过索引实现锁定的方式还存在其他几个较大的性能隐患：<br>（1）当Query <strong>无法利用索引的时候</strong>，InnoDB会<strong>放弃使用行级别</strong>锁定而改用<strong>表级别</strong>的锁定，造成并发性能的降低；<br>（2）当Query使用的索引并<strong>不包含所有过滤条件</strong>的时候，数据检索使用到的索引键所只想的数据可能有部分并不属于该Query的结果集的行列，但是也会被锁定，因为间隙锁锁定的是一个范围，而不是具体的索引键；<br>（3）当Query在使用索引定位数据的时候，如果使用的<strong>索引键一样但访问的数据行不同的时候</strong>（索引只是过滤条件的一部分，例如一个索引，一个其他过滤条件），一样会被锁定。<br>因此，在实际应用开发中，尤其是<strong>并发插入比较多的应用</strong>，我们要尽量优化业务逻辑，<strong>尽量使用相等条件</strong>来访问更新数据，<strong>避免使用范围条件</strong>。</p><p>还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个<strong>不存在的记录</strong>加锁，InnoDB也会使用间隙锁。</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>上文讲过，<strong>MyISAM表锁</strong>是deadlock free的，这是因为MyISAM总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。<br>但在InnoDB中，除单个SQL组成的事务外，锁是<strong>逐步</strong>获得的，当两个事务<strong>都需要获得对方持有的排他锁</strong>才能继续完成事务，这种循环锁等待就是典型的死锁。<br>在InnoDB的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就<strong>检测</strong>到该死锁的存在。当InnoDB检测到系统中产生了死锁之后，InnoDB会通过相应的判断来选这产生死锁的两个事务中<strong>较小的事务来回滚</strong>，而让另外一个<strong>较大的事务成功完成</strong>。<br>那InnoDB是以什么来为标准判定事务的大小的呢？MySQL官方手册中也提到了这个问题，实际上在InnoDB发现死锁之后，会计算出两个事务<strong>各自插入、更新或者删除的数据量来判定两个事务的大小</strong>。也就是说哪个事务所改变的记录条数越多，在死锁中就越不会被回滚掉。<br>但是有一点需要注意的就是，当产生死锁的场景中涉及到<strong>不止InnoDB存储引擎</strong>的时候，InnoDB是没办法检测到该死锁的，这时候就只能通过<strong>锁定超时限制参数InnoDB_lock_wait_timeout</strong>来解决。<br>需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。<br>通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小，以及访问数据库的SQL语句，绝大部分死锁都可以避免。</p><p>下面就通过实例来介绍<strong>几种避免死锁的常用方法</strong>：<br>（1）在应用中，如果不同的程序会并发存取多个表，应尽量<strong>约定以相同的顺序（按顺序持有锁，不易冲突）</strong>来访问表，这样可以大大降低产生死锁的机会。<br>（2）在程序以批量方式处理数据的时候，如果<strong>事先对数据排序</strong>，保证每个<strong>线程按固定的顺序来处理记录</strong>，也可以大大降低出现死锁的可能。<br>（3）在事务中，如果<strong>要更新（不管先后，直接申请排他锁）</strong>记录，应该直接<strong>申请足够级别的锁，即排他锁</strong>，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。<br>（4）在REPEATABLE-READ（可重复读）隔离级别下，如果两个线程同时对相同条件记录用<strong>SELECT…FOR UPDATE加排他锁</strong>，在没有符合该条件记录情况下（即不存在的记录），两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可避免问题。<br>（5）当隔离级别为READ COMMITTED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，<strong>如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待</strong>，当第1个线程提交后，第2个线程会因主键重出错，<strong>但虽然这个线程出错了，却会获得一个排他锁</strong>。这时如果有第3个线程又来申请排他锁，也会出现死锁。对于这种情况，可以<strong>直接做插入操作</strong>，然后再捕获主键重异常，或者在<strong>遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。</strong></p><h1 id="什么时候使用表锁"><a href="#什么时候使用表锁" class="headerlink" title="什么时候使用表锁"></a>什么时候使用表锁</h1><p>对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为<strong>事务和行锁</strong>往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁：<br>（1）事务需要<strong>更新大部分或全部数据，表又比较大</strong>，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。<br>（2）事务<strong>涉及多个表</strong>，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。<br>当然，应用中<strong>这两种事务不能太多，否则，就应该考虑使用MyISAM表</strong>了。</p><p>在InnoDB下，使用表锁要注意以下两点。<br>（1）使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0、InnoDB_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁（相互感知），这种情况下，<strong>InnoDB才能自动识别涉及表级锁的死锁</strong>，否则，InnoDB将无法自动检测并处理这种死锁。<br>（2）在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0（关闭自动提交），否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为<strong>UNLOCK TABLES会隐含地提交事务</strong>；<strong>COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁</strong>。正确的方式见如下语句：<br>例如，如果需要写表t1并从表t读，可以按如下做：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> t1 WRITE, t2 <span class="keyword">READ</span>, ...;</span><br><span class="line">[<span class="keyword">do</span> something <span class="keyword">with</span> <span class="keyword">tables</span> t1 <span class="keyword">and</span> t2 here];</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">UNLOCK</span> <span class="keyword">TABLES</span>;</span><br></pre></td></tr></table></figure><font color="ff0000">关提交，锁表，处理事务，提交，解除表锁</font><h1 id="InnoDB行锁优化建议"><a href="#InnoDB行锁优化建议" class="headerlink" title="InnoDB行锁优化建议"></a>InnoDB行锁优化建议</h1><p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体<strong>并发处理能力方面</strong>要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。但是，InnoDB的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。<br>（1）要想合理利用InnoDB的行级锁定，做到扬长避短，我们必须做好以下工作：</p><p>a)尽可能<strong>让所有的数据检索都通过索引来完成</strong>，从而<strong>避免InnoDB因为无法通过索引键加锁而升级为表级锁定</strong>；<br>b)合理设计索引，让InnoDB在索引键上面<strong>加锁</strong>的时候尽可能<strong>准确</strong>，尽可能的<strong>缩小锁定范围</strong>，避免造成不必要的锁定而影响其他Query的执行；<br>c)尽可能<strong>减少基于范围的数据检索</strong>过滤条件，<strong>避免因为间隙锁带来的负面影响而锁定了不该锁定的记录</strong>；<br>d)尽量<strong>控制事务的大小</strong>，<strong>减少锁定的资源量和锁定时间长度</strong>；<br>e)在业务环境允许的情况下，尽量<strong>使用较低级别的事务隔离</strong>，以减少MySQL因为实现事务隔离级别所带来的附加成本。</p><p>（2）由于InnoDB的行级锁定和事务性，所以肯定会产生死锁，下面是一些比较常用的减少死锁产生概率的小建议：<br>a)类似业务模块中，尽可能按照<strong>相同的访问顺序来访问</strong>，防止产生死锁；<br>b)在同一个事务中，尽可能做到<strong>一次锁定所需要的所有资源</strong>，减少死锁产生概率；<br>c)对于非常容易产生死锁的业务部分，可以尝试使用<strong>升级锁定颗粒度，通过表级锁定来减少死锁产生的概率</strong>。<br>（3）可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like 'InnoDB_row_lock%';</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| InnoDB_row_lock_current_waits | 0     |</span><br><span class="line">| InnoDB_row_lock_time          | 0     |</span><br><span class="line">| InnoDB_row_lock_time_avg      | 0     |</span><br><span class="line">| InnoDB_row_lock_time_max      | 0     |</span><br><span class="line">| InnoDB_row_lock_waits         | 0     |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br></pre></td></tr></table></figure><p>InnoDB 的行级锁定状态变量不仅记录了锁定等待次数，还记录了锁定总时长，每次平均时长，以及最大时长，此外还有一个非累积状态量显示了当前正在等待锁定的等待数量。对各个状态量的说明如下：<br>InnoDB_row_lock_current_waits：当前<strong>正在等待锁定</strong>的数量；<br>InnoDB_row_lock_time：从系统启动到现在<strong>锁定总时间长度</strong>；<br>InnoDB_row_lock_time_avg：<strong>每次等待所花平均时间</strong>；<br>InnoDB_row_lock_time_max：从系统启动到现在<strong>等待最长的一次所花的时间</strong>；<br>InnoDB_row_lock_waits：系统启动后到现在<strong>总共等待的次数；</strong><br>对于这5个状态变量，比较重要的主要是InnoDB_row_lock_time_avg（等待平均时长），InnoDB_row_lock_waits（等待总次数）以及InnoDB_row_lock_time（等待总时长）这三项。尤其是当等待<strong>次数很高</strong>，而且每次等待<strong>时长也不小</strong>的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</p><p>如果发现<strong>锁争用比较严重</strong>，如InnoDB_row_lock_waits和InnoDB_row_lock_time_avg的值比较高，还可以通过设置InnoDB Monitors 来进一步观察发生<strong>锁冲突的表</strong>、<strong>数据行</strong>等，并分析锁争用的原因。<br>锁冲突的表、数据行等，并分析锁争用的原因。具体方法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table InnoDB_monitor(a INT) engine=InnoDB;</span><br></pre></td></tr></table></figure><p>然后就可以用下面的语句来进行查看：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine InnoDB status;</span><br></pre></td></tr></table></figure><p>监视器可以通过发出下列语句来停止查看：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop table InnoDB_monitor;</span><br></pre></td></tr></table></figure><p>设置监视器后，会有详细的当前锁等待的信息，包括表名、锁类型、锁定记录的情况等，便于进行进一步的分析和问题的确定。为什么要先创建一个叫InnoDB_monitor的表呢？因为创建该表实际上就是告诉InnoDB我们开始要监控他的细节状态了，然后InnoDB就会将比较详细的事务以及锁定信息记录进入MySQL的errorlog中，以便我们后面做进一步分析使用。打开监视器以后，默认情况下每15秒会向日志中记录监控的内容，如果长时间打开会导致.err文件变得非常的巨大，所以用户在确认问题原因之后，要记得删除监控表以关闭监视器，或者通过使用“–console”选项来启动服务器以关闭写日志文件。</p>]]></content>
      
      <categories>
          
          <category> 技术原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
