---
title: 设计模式沉思录（八）之 桥接(梁）模式
date: 2017-08-20 15:25:41
tags: [设计模式]
categories: 原理理解

---


# 设计模式沉思录（八）之 桥接(梁）模式

设计模式目录

桥接模式
桥接（Bridge）是用于把**抽象化**与**实现化**解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的**桥接结构**，来实现二者的解耦。

本文整理自四人帮著作：**Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）**


这种模式涉及到一个**作为桥接的接口**，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。

使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。

# 介绍
意图：将**抽象部分**与**实现部分**分离，使它们都可以独立的变化。

主要解决：在有多种可能会变化的情况下，用继承会造成类爆炸问题（会产生太多需要的类？？），扩展起来不灵活。

何时使用：实现系统可能有多个角度分类，每一种角度都可能变化。

如何解决：把这种多角度分类分离出来，让它们**独立变化**，减少它们之间耦合。

关键代码：抽象类依赖实现类。

应用实例： 
1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。

优点： 
1、抽象和实现的分离。 
2、优秀的扩展能力。 
3、实现细节对客户透明。

缺点：桥接模式的引入会增加系统的理解与设计难度，由于**聚合关联关系**建立在抽象层，要求开发者针对抽象进行设计与编程。

使用场景： 
1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，<font color="#dd0000">避免在两个层次之间建立静态的继承联系</font>，通过桥接模式可以使它们在抽象层建立一个关联关系。 
2、对于那些<font color="#dd0000">不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统</font>，桥接模式尤为适用。 
3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。(多维度扩展）

注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。

# 实现
我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。

Shape 是一个抽象类，将使用 DrawAPI 的对象。
Shape会用到DrawAPI
BridgePatternDemo，我们的演示类使用 Shape 类来画出不同颜色的圆。

## 对比
你看哪里解耦了呢！这里我们放弃了继承，选择了组合。

原本思路是让接口Shape去继承DrawAPI接口，然后有个确切的redCircle去实现接口Shape，这样就能覆盖到颜色，和形状两个维度。
问题1:当我们需要添加一个颜色蓝色，画出所有图形，怎么办？ 只能给所有的Shape接口都添加上画蓝色方法，之下的实现类也全部添加。

问题2：当我们需要添加一个形状矩形，要画出所有颜色，怎么办？
只能，让rectangle接口继承DrawApi，再实现各种颜色的类。

为什么会出现这种状况，我明明指向加一个维度，却要修改多个方式。这要是数量多起来了，繁琐程度那还得了。也就是说这两个维度是严重耦合的。改变其中一个，就会受另外一个的影响。那么我们就要把这两个维度分开，让他们解耦。

我们可以让构造Shape的时候，颜色作为属性的方式存在，这样就能在构造shape的时候通过传入color，而不是用类名来区分。



![此处输入图片的描述][1]

## 步骤 1
创建桥接实现接口。
```Java
public interface DrawAPI {
   public void drawCircle(int radius, int x, int y);//画画方法：根据x，y，半径，画圈
}
```
## 步骤 2
创建实现了 DrawAPI 接口的实体桥接实现类。GreenCircle同理
```Java
//确定下颜色来，draw方法是带颜色的
public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println("Drawing Circle[ color: red, radius: "
         + radius +", x: " +x+", "+ y +"]");
   }
}
```
## 步骤3
创建抽象类 Shape

这个抽象类依赖DrawAPI构造，拥有DrawAPI属性，也就能通过这个属性来明确color
```Java
public abstract class Shape {
   protected DrawAPI drawAPI;
   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   
   public abstract void draw();  
}
```
## 步骤 4
创建实现了 Shape 接口的实体类。doaw方法会调用自生drawAPI的drow方法
这样就能明确颜色了呢
```Java
public class Circle extends Shape {
   private int x, y, radius;
 
   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }
 
   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}
```

## 步骤 5
使用 Shape 和 DrawAPI 类画出不同颜色的圆。

```java
public class BridgePatternDemo {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new RedCircle());//传一个颜色进去
      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());
 
      redCircle.draw();
      greenCircle.draw();
   }
}
```





  [1]: http://www.runoob.com/wp-content/uploads/2014/08/bridge_pattern_uml_diagram.jpg