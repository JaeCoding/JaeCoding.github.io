---
title: 设计模式沉思录（十）之 组合模式
date: 2017-08-25 11:24:51
tags: [设计模式]
categories: 原理理解

---


# 设计模式沉思录（十）之 组合模式

设计模式目录

# 组合模式（Composite Pattern）
，又叫**部分整体模式**，是用于把一组相似的对象当作一个单一的对象。组合模式**依据树形结构**来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。

本文整理自四人帮著作：**Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）**

这种模式创建了一个包含自己对象组的类。该类提供了**修改相同对象组**的方式。

我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。

# 介绍
**概念：**把多个对象组成树状结构来表示局部与整体，这样用户可以一样的对待单个对象和对象的组合。（维基百科）

**意图：**将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。


**主要解决：**它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像**处理简单元素一样来处理复杂元素**，从而使得客户程序与复杂元素的内部结构解耦。

**何时使用：** 
1、您想表示对象的部分-整体层次结构（树形结构）。 
2、您希望用户 忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

**如何解决：**树枝和叶子实现统一接口，树枝内部组合该接口。

**关键代码：**树枝内部组合该接口，并且含有内部属性 List，里面放 Component。

**应用实例：** 
1、算术表达式包括操作数、操作符和**另一个操作数**，其中，另一个操作符也可以是操作数、操作符和另一个操作数。 例如：1 + (2+6)
2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。

**优点：** 1、高层模块调用简单。 2、节点自由增加。

**缺点：**在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了**依赖倒置原则**(高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象)。

**使用场景：**部分、整体场景，如树形菜单，文件、文件夹的管理。

**注意事项：**定义时为具体类。,这也是缺点所在，没有抽象出来

# 实现
我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee 类来添加部门层次结构，并打印所有员工。
![此处输入图片的描述][1]

  [1]: http://www.runoob.com/wp-content/uploads/2014/08/composite_pattern_uml_diagram.jpg
  
```Java
<pre class="prettyprint">
import java.util.ArrayList;
import java.util.List;
 
public class Employee {
   private String name;
   private String dept;
   private int salary;
   private List<Employee> subordinates;//此人的下属列表
 
   //构造函数
   public Employee(String name,String dept, int sal) {
      this.name = name;
      this.dept = dept;
      this.salary = sal;
      subordinates = new ArrayList<Employee>();
   }
 
   public void add(Employee e) {
      subordinates.add(e);
   }
 
   public void remove(Employee e) {
      subordinates.remove(e);
   }
 
   public List<Employee> getSubordinates(){
     return subordinates;
   }
 
   public String toString(){
      return ("Employee :[ Name : "+ name 
      +", dept : "+ dept + ", salary :"
      + salary+" ]");
   }   
}
```

步骤 2
使用 Employee 类来创建和 打印员工 的层次结构。
每个人的都有一个下属属性。里面存放着包含的下属关系。
便利的画很简单

缺点：通过具体的类，添加到属性中，而没有抽象。

```java
public class CompositePat ternDemo {
   public static void main(String[] args) {
      Employee CEO = new Employee("John","CEO", 30000);
 
      Employee headSales = new Employee("Robert","Head Sales", 20000);
 
      Employee headMarketing = new Employee("Michel","Head Marketing", 20000);
 
      Employee clerk1 = new Employee("Laura","Marketing", 10000);
      Employee clerk2 = new Employee("Bob","Marketing", 10000);
 
      Employee salesExecutive1 = new Employee("Richard","Sales", 10000);
      Employee salesExecutive2 = new Employee("Rob","Sales", 10000);
 
      CEO.add(headSales);
      CEO.add(headMarketing);
 
      headSales.add(salesExecutive1);
      headSales.add(salesExecutive2);
 
      headMarketing.add(clerk1);
      headMarketing.add(clerk2);
 
      //打印该组织的所有员工
      System.out.println(CEO); 
      for (Employee headEmployee : CEO.getSubordinates()) {
         System.out.println(headEmployee);
         for (Employee employee : headEmployee.getSubordinates()) {
            System.out.println(employee);
         }
      }        
   }
}
```

对一开始的那个树进行分析，这课数有叶子节点和树枝节点，他们的共同之处是我们都要获取他们的信息，树枝节点比叶子节点多的东西是有一个孩子节点的定义，所以我们定义了一个CEO类，其中有ADD方法，这是叶子和树枝的共有方法。

在树枝节点中，我们添加了一个List类型的subordinate下属列表，然后添加了添加子节点，删除子节点，获取子节点列表的方法。这就是一个组合模式的应用，把这些对象表示成了部分-整体结构。

我们定义了一个静态的方法，来对这棵树进行遍历、我们只需要知道根节点就能知道所有的其他的对象，这样，我们就把单个对象和组合起来的对象等同对待。

# 总结

组合模式，对于高层模块来说，调用局部的元素和调用整体的元素，没有任何区别。  高层模块不用关心这是一个单个对象还是一个组合结构，所以在这个设计下，我们很容易进行节点的扩展。方便维护。

但是他的缺点也很明显，不符合依赖倒置原则。我们在进行构造的时候，对于树枝节点和叶子节点，需要声明为具体的类来进行构造，对于这种情况，我们可以使用所谓透明的组合模式，就是在原生的组合模式的基础上，完全抹去叶子节点和树枝节点的区别，所有的节点不分是叶子还是树枝。**都有孩子节点这一个属性，只不过孩子节点个数是0的时候，就认为他是一个叶子节点。**这种模式如果处理不好，很容易出现安全问题。我们通常把**区分**叶子节点和树枝节点的组合模式叫安全模式，不区分的叫透明模式。