---
title: 设计模式沉思录（一）之工厂模式
date: 2018-07-12 11:21:41
tags: [设计模式]
categories: 原理理解

---


# 设计模式沉思录（二）之抽象工厂模式

本文整理自四人帮著作：**Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）**

抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该**超级工厂又称为其他工厂的工厂**。这种类型的设计模式属于创建型模式。

在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

介绍
意图：提供一个 **创建一系列相关或相互依赖对象** 的接口，而无需指定它们具体的类。
主要解决：主要解决**接口选择**的问题。
何时使用：系统的产品有**多于一个的产品族（需要多个产品工厂），比如需要手机工厂，又需要手机壳工厂**，而系统只消费其中某一族的产品。

如何解决：在一个产品族里面，定义多个产品。
关键代码：在一个工厂里聚合多个同类产品。手机工厂既生产小米手机，又生产华为手机（富土康？？？），也有对应的手机壳工厂

应用实例：
工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即**一系列**具体产品。

假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的**衣柜**（具体工厂）都是**衣柜类**的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。

优点：当一个产品族中的多个对象被设计成**一起工作**时，它能保证客户端始终**只使用同一个产品族**中的对象。
缺点：**产品族扩展非常困难**，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。如果想要添加一个新的产品，需要对接口进行改动，对接口的改动就意味着要改动所有实现该接口的类，这是很可怕的事情。这里要注意是不容易添加产品族，而不是添加产品等级，因为添加产品等级不需要对现有的接口进行改变。（举例：

使用场景： 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。
注意事项：产品族难扩展，产品等级易扩展。


实现

[此处输入链接的描述][1]
ShapeFactory和ColorFactory继承AbstractFactory，生产实现了shape和color的实现类


1.前面的shape和color接口，以及各自的实现类可以类比。
```Java
public interface Shape {
   void draw();
}

public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
```

2.获取对应工厂， 为 Color 和 Shape 对象创建抽象类 。
```Java
//工厂类的父类————抽象工厂
public abstract class AbstractFactory {
   //这个抽象工厂抽象类吧，有两个建造产品类
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape) ;
   
}
```
3.只写出shapeFactory，继承自抽象工厂，若需要增加工厂，直接添加工厂类并且继承抽象工厂
```Java
public class ShapeFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      return null;
   }
}
```
4.创建一个工厂创造器/生成器类，通过传递形状或颜色信息来**获取工厂**。
```Java
public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){
      if(choice.equalsIgnoreCase("SHAPE")){
         return new ShapeFactory();
      } else if(choice.equalsIgnoreCase("COLOR")){
         return new ColorFactory();
      }
      return null;
   }
}
```
4.Demo
```Java
public class AbstractFactoryPatternDemo {
   public static void main(String[] args) {
   
      //获取形状工厂,抽象工厂对象 指向 具体工厂实例
      AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
 
      //获取形状为 Circle 的对象
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();
    }
}
```

# 拓展

1.在抽象工厂模式中，假设我们需要增加一个工厂
很简单，直接增加一个工厂类（继承抽象工厂），并且实现这个新工厂的所有产品方法

2.在抽象工厂模式中，假设我们需要增加一个产品
很麻烦，因为要修改接口，多一个生产方法，导致所有继承了这个抽象工厂的工厂都要加上。
再添加新产品父类。



  [1]: http://www.runoob.com/wp-content/uploads/2014/08/abstractfactory_pattern_uml_diagram.jpg