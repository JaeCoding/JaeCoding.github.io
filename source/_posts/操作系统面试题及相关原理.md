---
title: 操作系统面试题及相关原理
date: 2018-02-18 16:31:26
tags: [面试题,操作系统]
categories: 原理

---

# 操作系统面试题及相关原理

# 操作指令
## linux查看进程
1.查进程
    ps 命令查找与进程相关的PID号：

    ps a 显示现行终端机下的**所有程序**，包括其他用户的程序。
    ps -A 显示**所有**程序。
    ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。
   
    最常用的方法是ps aux,然后再通过管道使用grep命令过滤查找特定的进程,然后再对特定的进程进行操作。
    `ps aux | grep   program_filter_word,ps -ef |grep tomcat

`ps -ef|grep java`
`ps -ef|grep java|grep -v grep` 显示出所有的java进程，去处掉当前的grep进程。

## 查看端口
`netstat`命令各个参数说明如下：

    -t : 指明显示TCP端口
    -u : 指明显示UDP端口
    -l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)
    -p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。
    -n : 不进行DNS轮询，显示IP(可以加速操作)

即可显示当前服务器上所有端口及进程服务，于grep结合可查看某个具体端口及服务情况··

netstat -ntlp    //查看当前所有tcp端口·
netstat -ntulp |grep 80   //查看所有80端口使用情况·
netstat -an | grep 3306   //查看所有3306端口使用情况·

    `netstat  -lanp` 查看一台服务器上面哪些服务及端口
    
    ps -ef |grep mysqld查看一个**服务有几个端口**。比如要查看mysqld

    netstat -pnt |grep :3306 |wc 查看某一端口的**连接数量**,比如3306端口

    netstat -anp |grep 3306    查看某一端口的连接客户端IP 比如3306端口



netstat -an 查看网络端口 

lsof -i :port，使用lsof -i :port就能看见所指定端口运行的程序，同时还有当前连接。 

nmap 端口扫描
netstat -nupl  (UDP类型的端口)
netstat -ntpl  (TCP类型的端口)
netstat -anp **显示系统端口使用情况**


## 搜索文件中匹配符 
    命令：grep 
    格式：grep [option] pattern filenames 
    功能：逐行搜索所指定的文件或标准输入，并显示匹配模式的每一行。 
    选项：-i    匹配时忽略大小写 
  -v 找出模式失配的行 

    例如：% grep -i 'java*' ./test/run.sh 

## 寻找文件 
    命令：find 
    格式：find pathname [option] expression 
    功能：在 所给的路经名下 寻找符合表达式相匹配的文件。 
    选项：-name     表示文件名 
          -user     用户名，选取该用户所属的文件 
          -size     按大小查找，以block为单位，一个block是512B 
          -mtime n  按最后一次修改时间查找，选取n天内被修改的文件 
  -perm     按权限查找 
          -type     按文件类型查找 
  -atime    按最后一次访问时间查找 

    例如：% find ./ -name '*abc*' -print 



## 文件传输
    命令：ftp (file transfer program) 
    格式：ftp hostname 
    功能：网络文件传输及远程操作。 
    

# 线程 与 进程

## 线程进程区别
实现并发的方式有多种：比如**多进程**、**多线程**、**IO多路复用**。

一句话总结：进程关注资源分配，线程关注程序运行。
Why：因为CPU与其他PC资源速度不协调， 为了实现“同时执行”，  计算机需要进程来 保存和切换上下文。 

可以类比于火车 和 车厢。

**进程：关注的是内存资源的管理与分配**
进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。
程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。

Linux系统函数fork()可以在父进程中创建一个子进程，但是成本昂贵
父进程：负责监控请求的到来，交由子进程处理
子进程：多个 处理多个请求

**线程：关注的是系统的调度，cpu的使用**
线程是程序执行时的**最小单位**，它是进程的一个**执行流（也就是一系列的操作）**，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。
线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。

## 线程和进程de区别和优劣呢？
原因：！！区别完全由地址空间造成，进程地址不同，线程用进程下的地址空间。

 - 进程是**资源分配**的最小单位，线程是**程序执行**的最小单位。
 - 进程有自己的独立地址空间，每启动一个进程，系统就会为它**分配地址空间，建立数据表(所以说是资源分配最小单位）**来维护代码段、堆栈段和数据段，这种操作非常**昂贵**。     而线程是**共享进程中的数据的，使用相同的地址空间**，因此CPU切换一个线程的花费远比进程要小很多（在一个相同地址空间切换自然轻松），同时创建一个线程的开销也比进程要小很多。
 - 线程之间的通信更方便，切换更快，同一进程下的**线程共享全局变量、静态变量**等数据，而进程之间的通信需要以通信的方式（IPC)进行。
 - 多进程程序**更健壮**。多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己**独立的地址空间**。

## 五种进程通信（IPC，InterProcess Communication）的方式
管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket和Streams（这俩支持不同主机之间进程IPC）

**一、管道（无名管道）**
管道，通常指**无名管道**，是 UNIX 系统IPC最古老的形式。

**1、特点：**
 - 半双工（数据只能在一个方向上流动），具有固定的读端和写端。
 - 只能用于具有**亲缘关系的进程**之间的通信（也是父子进程或者兄弟进程之间）。因为子进程继承父继承的**文件描述符**，除了父子进程，其他进程不知道fd的值，所以通常调用pipe的进程接着调用fork，在父子之间通信。
 - 可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write
   等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。

**二、FIFO（命名管道）**
命名管道，它是一种文件类型。

**1、特点**

 - 可以在**无关的进程**之间交换数据，与无名管道不同。
 - FIFO有**路径名**与之相关联，它以一种**特殊设备文件形式**存在于文件系统中。

FIFO的通信方式类似于**在进程中使用文件来传输数据**，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。

**三、消息队列**
消息队列，是**消息的链接表**，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。
**1、特点**

 - 面向记录，其中的**消息具有特定的格式**以及特定的优先级。
 - 消息队列**独立于**发送与接收进程。进程终止时，消息队列及其内容并不会被删除。(管道不同，进程终止管道内容删除）
 - 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的**类型**读取。

**四、信号量（用于同步不用于存储）**
信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个**计数器**。信号量用于实现进程间的**互斥与同步**，而不是用于存储进程间通信数据。

**1、特点**

 - 用于进程间同步，若要在进程间传递数据需要结合共享内存。
 - 基于操作系统的 PV 操作（信号量的处理相关，P表示通过的意思，V表示释放的意思），程序对信号量的操作都是原子操作。
 - 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
 - 支持信号量组。

**五、共享内存**
共享内存（Shared Memory），指两个或多个进程**共享一个给定的存储区**。

**1、特点**

 - **最快**的IPC，因为进程是直接对内存进行存取。
 - 因为多个进程可以同时操作，所以**需要进行同步**。
 - 信号量+共享内存 通常结合在一起使用，信号量**用来同步**对共享内存的访问。

**例子**
使用【共享内存+信号量+消息队列】的组合来实现服务器进程与客户进程间的通信。
共享内存用来**传递数据**；信号量用来**同步**；消息队列用来 在客户端修改了共享内存后 **通知服务器读取**。
 

## 孤儿进程与僵尸进程

**父进程→子进程→新的进程**
子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束（生出来就管不了了）。 
当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。**（状态收集:电话联系）**

**孤儿进程：**一个父进程退出，而它的一个或**多个子进程还在运行**，那么那些子进程将成为孤儿进程。孤儿进程将被**init进程(进程号为1**)所**收养**，并由init进程对它们完成状态收集工作。

**僵尸进程：**一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。（子进程已死，父进程都没联系儿子，都不知道他死了，跟系统说还活着）
　　
**危害：**
**孤儿危害：**联系孤儿进程的重任就落到了init进程身上，init进程就好像是一个民政局，专门负责孤儿的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。因此孤儿进程并不会有什么危害。
**僵尸危害：**如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其**进程号**就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有**可用的进程号**而导致系统不能产生新的进程。

**原因：有僵尸召唤者**
任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是**留下一个称为僵尸进程(Zombie)的数据结构**，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。
如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

**解决：杀僵尸不治本，要杀死僵尸召唤者**
就像僵尸片我们不能怪僵尸，要怪召唤僵尸的人。僵尸进程也应该归罪于父进程没有善后（没有调用wait / waitpid），所以我们只要消灭父进程，让他不要继续生产僵尸。僵尸也会因为没了父亲变为孤儿进程，被init消灭。







死锁（代码实现）
作业调度方式
协程


怎么实现管道，为什么管道都是用于父子进程或兄弟进程（fork机制的原因），我说了子进程完全继承了父进程的内容，又问我信号会继承吗，我说是的，他说真的吗，难道有什么问题吗（信号掩码之类继承，但是pending的信号就直接丢了。）

IO复用很熟吧，说说怎么用的

怎么看进程占用的系统资源，
怎么用命令给一个文件里面的数字按次数排序



